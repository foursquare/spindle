
/**
 * GENERATED CODE - DO NOT EDIT!
 * Generated by foursquare.thrift.codegen
 * 

 */


package com.twitter.thrift.descriptors

import scalaj.collection.Imports._



sealed abstract class SimpleBaseType private (
    override val id: Int,
    override val name: String,
    override val stringValue: String
) extends com.foursquare.recordv2.runtime.Enum[SimpleBaseType] with org.apache.thrift.TEnum {
  override def toString: String = name
  override def getValue: Int = id
  override def meta: SimpleBaseType.type = SimpleBaseType
}

object SimpleBaseType extends com.foursquare.recordv2.runtime.EnumMeta[SimpleBaseType] {

    object BOOL extends SimpleBaseType(0, "BOOL", "BOOL")
    object BYTE extends SimpleBaseType(1, "BYTE", "BYTE")
    object I16 extends SimpleBaseType(2, "I16", "I16")
    object I32 extends SimpleBaseType(3, "I32", "I32")
    object I64 extends SimpleBaseType(4, "I64", "I64")
    object DOUBLE extends SimpleBaseType(5, "DOUBLE", "DOUBLE")
    object STRING extends SimpleBaseType(6, "STRING", "STRING")
    object BINARY extends SimpleBaseType(7, "BINARY", "BINARY")

  override val values: Vector[SimpleBaseType] =
    Vector(
      BOOL,
      BYTE,
      I16,
      I32,
      I64,
      DOUBLE,
      STRING,
      BINARY
    )

  override def findByIdOrNull(id: Int): SimpleBaseType = id match {
    case 0 => BOOL
    case 1 => BYTE
    case 2 => I16
    case 3 => I32
    case 4 => I64
    case 5 => DOUBLE
    case 6 => STRING
    case 7 => BINARY
    case _ => null
  }

  override def findByNameOrNull(name: String): SimpleBaseType = name match {
    case "BOOL" => BOOL
    case "BYTE" => BYTE
    case "I16" => I16
    case "I32" => I32
    case "I64" => I64
    case "DOUBLE" => DOUBLE
    case "STRING" => STRING
    case "BINARY" => BINARY
    case _ => null
  }

  override def findByStringValueOrNull(v: String): SimpleBaseType = v match {
    case "BOOL" => SimpleBaseType.BOOL
    case "BYTE" => SimpleBaseType.BYTE
    case "I16" => SimpleBaseType.I16
    case "I32" => SimpleBaseType.I32
    case "I64" => SimpleBaseType.I64
    case "DOUBLE" => SimpleBaseType.DOUBLE
    case "STRING" => SimpleBaseType.STRING
    case "BINARY" => SimpleBaseType.BINARY
    case _ => null
  }
}

sealed abstract class Requiredness private (
    override val id: Int,
    override val name: String,
    override val stringValue: String
) extends com.foursquare.recordv2.runtime.Enum[Requiredness] with org.apache.thrift.TEnum {
  override def toString: String = name
  override def getValue: Int = id
  override def meta: Requiredness.type = Requiredness
}

object Requiredness extends com.foursquare.recordv2.runtime.EnumMeta[Requiredness] {

    object REQUIRED extends Requiredness(0, "REQUIRED", "REQUIRED")
    object OPTIONAL extends Requiredness(1, "OPTIONAL", "OPTIONAL")

  override val values: Vector[Requiredness] =
    Vector(
      REQUIRED,
      OPTIONAL
    )

  override def findByIdOrNull(id: Int): Requiredness = id match {
    case 0 => REQUIRED
    case 1 => OPTIONAL
    case _ => null
  }

  override def findByNameOrNull(name: String): Requiredness = name match {
    case "REQUIRED" => REQUIRED
    case "OPTIONAL" => OPTIONAL
    case _ => null
  }

  override def findByStringValueOrNull(v: String): Requiredness = v match {
    case "REQUIRED" => Requiredness.REQUIRED
    case "OPTIONAL" => Requiredness.OPTIONAL
    case _ => null
  }
}




object Include
    extends com.foursquare.recordv2.runtime.MetaRecord[Include]
    with com.foursquare.recordv2.runtime.RecordProvider[Include] {
  override def recordName: String = "Include"


  // Thrift descriptors.
  val INCLUDE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Include")

  val PATH_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "path",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "path" -> PATH_DESC
  )

  object _Fields {
    case object path extends _Fields(1, "path")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.path
  )

  // Record v2
  override type Self = Include.type
  override type Trait = Include
  override type Mutable = MutableInclude
  override type Raw = RawInclude

  override def createRecord: Include = createRawRecord
  override def createRawRecord: Include.Raw = new Include.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Include] = {
    if (x.isInstanceOf[Include]) Some(x.asInstanceOf[Include]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val path =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Include, Include.type](
      name = "path",
      longName = "path",
      id = 1,
      annotations = Map(),
      owner = Include,
      getter = _.pathOption,
      setterRaw = (r: Include.Raw, v: String) => { r.path_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Include, Include.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Include, Include.type]](
      path
    )


  def apply(
      path: String
  ): Include = {
    val ret = Include.createRawRecord
    ret.path_=(path)
    ret
  }



  object Builder {
    sealed trait HasPath

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasPath
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Include] (private var obj: Include.Raw) {
    def path(v: String): Include.Builder[State with Builder.HasPath] = {
      obj.path_=(v)
      this.asInstanceOf[Include.Builder[State with Builder.HasPath]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasPath): Include.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Include.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasPath): Include = resultMutable()(ev0)
  }

  def newBuilder: Include.Builder.AllUnspecified = new Builder(Include.createRawRecord)

  implicit val companionProvider: IncludeCompanionProvider = new IncludeCompanionProvider
}

class IncludeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Include] {
  type CompanionT = Include.type
  override def provide: Include.type = Include
}



trait Include

    extends com.foursquare.recordv2.runtime.Record[Include]
    with scala.Ordered[Include]
    with org.apache.thrift.TBase[Include, Include._Fields] {

  override type MetaT = Include.type


  def path: String
  def pathOption: Option[String]
  def pathOrNull: String
  def pathOrThrow: String
  def pathIsSet: Boolean
  override def compare(that: Include): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.pathIsSet.compareTo(that.pathIsSet)
      cmp != 0 }) cmp
    else if (this.pathIsSet && {
      cmp = this.pathOrNull.compareTo(that.pathOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Include

  def copy(
      path: String = pathOrNull
  ): Include

  def mutableCopy(): Include.Mutable = {
    val ret = Include.createRawRecord

    if (pathIsSet) ret.path_=(pathOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Include.Mutable

  def toBuilder() = {
    val ret = new Include.Builder(Include.createRawRecord)

    if (pathIsSet) ret.path(pathOrNull)
    ret
  }

  def mergeCopy(that: Include): Include

}


trait IncludeProxy extends Include {
  protected def underlying: Include

  override def meta: Include.type = underlying.meta

// field/proxy_ref.ssp

  override def path: String = underlying.path
  override def pathOption: Option[String] = underlying.pathOption
  override def pathOrNull: String = underlying.pathOrNull
  override def pathOrThrow: String = underlying.pathOrThrow
  override def pathIsSet: Boolean = underlying.pathIsSet

  override def compare(that: Include): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      path: String = pathOrNull
  ): Include = underlying.copy(
    path = path
  )

  override def mutableCopy(): Include.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Include): Include = underlying.mergeCopy(that)

  override def mutable: Include.Mutable = underlying.mutable

  override def deepCopy(): Include = underlying.deepCopy()

  override def fieldForId(id: Int): Include._Fields = underlying.fieldForId(id)
  override def isSet(field: Include._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Include._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Include._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableInclude extends Include {
  def path_=(x: String): Unit
  def pathUnset(): Unit

  def merge(that: Include): Unit

  def copy(
      path: String = pathOrNull
  ): Include.Mutable

  override def mutable: Include.Mutable = this
}

trait MutableIncludeProxy extends MutableInclude with IncludeProxy {
  protected def underlying: MutableInclude

  override def path_=(x: String): Unit = { underlying.path_=(x) }
  override def pathUnset(): Unit = { underlying.pathUnset() }

  override def copy(
      path: String = pathOrNull
  ): Include.Mutable = underlying.copy(
    path = path
  )

  override def merge(that: Include): Unit = underlying.merge(that)
}



final class RawInclude extends MutableInclude {
  override def meta: Include.type = Include

  // Field #1 - path
  private var _path: String = null  // Underlying type: String
  override def path: String = pathOrThrow
  override def path_=(x: String): Unit = { _path = x }
  override def pathOption: Option[String] = if (pathIsSet) Some(_path) else None
  override def pathOrNull: String = _path
  override def pathOrThrow: String = if (pathIsSet) _path else throw new java.lang.NullPointerException
  override def pathIsSet: Boolean = _path != null
  override def pathUnset(): Unit = { _path = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Include.INCLUDE_DESC)
    if (pathIsSet) {
      oprot.writeFieldBegin(Include.PATH_DESC)
      oprot.writeString(_path)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Include.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // path

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _path = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Include".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Include): Unit = {
    if (that.pathIsSet && !this.pathIsSet) {
      this.path_=(that.pathOrNull)
    }
  }

  override def mergeCopy(that: Include): Include = {
    val ret = Include.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Include => this.equals(o)
    case _ => false
  }

  def equals(that: Include): Boolean = {
    that != null &&
    (if (this.pathIsSet) (that.pathIsSet && this.pathOrNull == that.pathOrNull) else !that.pathIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (pathIsSet) hasher.append(_path.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (pathIsSet) ret = pathOrNull :: ret
    ret.reverse
  }

  override def clear() {
    pathUnset()
  }

  def fieldForId(id: Int): Include._Fields = id match {
    case 1 => Include._Fields.path
    case _ => null
  }

  def isSet(field: Include._Fields): Boolean = field match {
    case Include._Fields.path => pathIsSet
    case _ => false
  }

  def getFieldValue(field: Include._Fields): AnyRef = field match {
    case Include._Fields.path => pathOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Include._Fields, value: AnyRef) {
    field match {
      case Include._Fields.path => path_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): Include.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Include.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      path: String = pathOrNull
  ): Include.Raw = {
    val ret = new Include.Raw
    if (path != null) ret.path_=(path)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Namespace
    extends com.foursquare.recordv2.runtime.MetaRecord[Namespace]
    with com.foursquare.recordv2.runtime.RecordProvider[Namespace] {
  override def recordName: String = "Namespace"


  // Thrift descriptors.
  val NAMESPACE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Namespace")

  val LANGUAGE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "language",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "language" -> LANGUAGE_DESC,
    "name" -> NAME_DESC
  )

  object _Fields {
    case object language extends _Fields(1, "language")
    case object name extends _Fields(2, "name")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.language,
    2.toShort -> _Fields.name
  )

  // Record v2
  override type Self = Namespace.type
  override type Trait = Namespace
  override type Mutable = MutableNamespace
  override type Raw = RawNamespace

  override def createRecord: Namespace = createRawRecord
  override def createRawRecord: Namespace.Raw = new Namespace.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Namespace] = {
    if (x.isInstanceOf[Namespace]) Some(x.asInstanceOf[Namespace]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val language =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Namespace, Namespace.type](
      name = "language",
      longName = "language",
      id = 1,
      annotations = Map(),
      owner = Namespace,
      getter = _.languageOption,
      setterRaw = (r: Namespace.Raw, v: String) => { r.language_=(v) },
      manifest = manifest[String]
    )

  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Namespace, Namespace.type](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = Namespace,
      getter = _.nameOption,
      setterRaw = (r: Namespace.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Namespace, Namespace.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Namespace, Namespace.type]](
      language,
      name
    )


  def apply(
      language: String,
      name: String
  ): Namespace = {
    val ret = Namespace.createRawRecord
    ret.language_=(language)
    ret.name_=(name)
    ret
  }



  object Builder {
    sealed trait HasLanguage
    sealed trait HasName

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasLanguage with HasName
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Namespace] (private var obj: Namespace.Raw) {
    def language(v: String): Namespace.Builder[State with Builder.HasLanguage] = {
      obj.language_=(v)
      this.asInstanceOf[Namespace.Builder[State with Builder.HasLanguage]]
    }
    def name(v: String): Namespace.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Namespace.Builder[State with Builder.HasName]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasLanguage, ev1: State <:< Builder.HasName): Namespace.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Namespace.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasLanguage, ev1: State <:< Builder.HasName): Namespace = resultMutable()(ev0, ev1)
  }

  def newBuilder: Namespace.Builder.AllUnspecified = new Builder(Namespace.createRawRecord)

  implicit val companionProvider: NamespaceCompanionProvider = new NamespaceCompanionProvider
}

class NamespaceCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Namespace] {
  type CompanionT = Namespace.type
  override def provide: Namespace.type = Namespace
}



trait Namespace

    extends com.foursquare.recordv2.runtime.Record[Namespace]
    with scala.Ordered[Namespace]
    with org.apache.thrift.TBase[Namespace, Namespace._Fields] {

  override type MetaT = Namespace.type


  def language: String
  def languageOption: Option[String]
  def languageOrNull: String
  def languageOrThrow: String
  def languageIsSet: Boolean

  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  override def compare(that: Namespace): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.languageIsSet.compareTo(that.languageIsSet)
      cmp != 0 }) cmp
    else if (this.languageIsSet && {
      cmp = this.languageOrNull.compareTo(that.languageOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Namespace

  def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): Namespace

  def mutableCopy(): Namespace.Mutable = {
    val ret = Namespace.createRawRecord

    if (languageIsSet) ret.language_=(languageOrNull)

    if (nameIsSet) ret.name_=(nameOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Namespace.Mutable

  def toBuilder() = {
    val ret = new Namespace.Builder(Namespace.createRawRecord)

    if (languageIsSet) ret.language(languageOrNull)

    if (nameIsSet) ret.name(nameOrNull)
    ret
  }

  def mergeCopy(that: Namespace): Namespace

}


trait NamespaceProxy extends Namespace {
  protected def underlying: Namespace

  override def meta: Namespace.type = underlying.meta

// field/proxy_ref.ssp

  override def language: String = underlying.language
  override def languageOption: Option[String] = underlying.languageOption
  override def languageOrNull: String = underlying.languageOrNull
  override def languageOrThrow: String = underlying.languageOrThrow
  override def languageIsSet: Boolean = underlying.languageIsSet
// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet

  override def compare(that: Namespace): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): Namespace = underlying.copy(
    language = language,
    name = name
  )

  override def mutableCopy(): Namespace.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Namespace): Namespace = underlying.mergeCopy(that)

  override def mutable: Namespace.Mutable = underlying.mutable

  override def deepCopy(): Namespace = underlying.deepCopy()

  override def fieldForId(id: Int): Namespace._Fields = underlying.fieldForId(id)
  override def isSet(field: Namespace._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Namespace._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Namespace._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableNamespace extends Namespace {
  def language_=(x: String): Unit
  def languageUnset(): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit

  def merge(that: Namespace): Unit

  def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): Namespace.Mutable

  override def mutable: Namespace.Mutable = this
}

trait MutableNamespaceProxy extends MutableNamespace with NamespaceProxy {
  protected def underlying: MutableNamespace

  override def language_=(x: String): Unit = { underlying.language_=(x) }
  override def languageUnset(): Unit = { underlying.languageUnset() }
  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }

  override def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): Namespace.Mutable = underlying.copy(
    language = language,
    name = name
  )

  override def merge(that: Namespace): Unit = underlying.merge(that)
}



final class RawNamespace extends MutableNamespace {
  override def meta: Namespace.type = Namespace

  // Field #1 - language
  private var _language: String = null  // Underlying type: String
  override def language: String = languageOrThrow
  override def language_=(x: String): Unit = { _language = x }
  override def languageOption: Option[String] = if (languageIsSet) Some(_language) else None
  override def languageOrNull: String = _language
  override def languageOrThrow: String = if (languageIsSet) _language else throw new java.lang.NullPointerException
  override def languageIsSet: Boolean = _language != null
  override def languageUnset(): Unit = { _language = null }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Namespace.NAMESPACE_DESC)
    if (languageIsSet) {
      oprot.writeFieldBegin(Namespace.LANGUAGE_DESC)
      oprot.writeString(_language)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(Namespace.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Namespace.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // language

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _language = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Namespace".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Namespace): Unit = {
    if (that.languageIsSet && !this.languageIsSet) {
      this.language_=(that.languageOrNull)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
  }

  override def mergeCopy(that: Namespace): Namespace = {
    val ret = Namespace.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Namespace => this.equals(o)
    case _ => false
  }

  def equals(that: Namespace): Boolean = {
    that != null &&
    (if (this.languageIsSet) (that.languageIsSet && this.languageOrNull == that.languageOrNull) else !that.languageIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (languageIsSet) hasher.append(_language.##)
    if (nameIsSet) hasher.append(_name.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (languageIsSet) ret = languageOrNull :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    ret.reverse
  }

  override def clear() {
    languageUnset()
    nameUnset()
  }

  def fieldForId(id: Int): Namespace._Fields = id match {
    case 1 => Namespace._Fields.language
    case 2 => Namespace._Fields.name
    case _ => null
  }

  def isSet(field: Namespace._Fields): Boolean = field match {
    case Namespace._Fields.language => languageIsSet
    case Namespace._Fields.name => nameIsSet
    case _ => false
  }

  def getFieldValue(field: Namespace._Fields): AnyRef = field match {
    case Namespace._Fields.language => languageOrNull.asInstanceOf[AnyRef]
    case Namespace._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Namespace._Fields, value: AnyRef) {
    field match {
      case Namespace._Fields.language => language_=(value.asInstanceOf[String])
      case Namespace._Fields.name => name_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): Namespace.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Namespace.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): Namespace.Raw = {
    val ret = new Namespace.Raw
    if (language != null) ret.language_=(language)
    if (name != null) ret.name_=(name)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Annotation
    extends com.foursquare.recordv2.runtime.MetaRecord[Annotation]
    with com.foursquare.recordv2.runtime.RecordProvider[Annotation] {
  override def recordName: String = "Annotation"


  // Thrift descriptors.
  val ANNOTATION_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Annotation")

  val KEY_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "key",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val VALUE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "value",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "key" -> KEY_DESC,
    "value" -> VALUE_DESC
  )

  object _Fields {
    case object key extends _Fields(1, "key")
    case object value extends _Fields(2, "value")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.key,
    2.toShort -> _Fields.value
  )

  // Record v2
  override type Self = Annotation.type
  override type Trait = Annotation
  override type Mutable = MutableAnnotation
  override type Raw = RawAnnotation

  override def createRecord: Annotation = createRawRecord
  override def createRawRecord: Annotation.Raw = new Annotation.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Annotation] = {
    if (x.isInstanceOf[Annotation]) Some(x.asInstanceOf[Annotation]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val key =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Annotation, Annotation.type](
      name = "key",
      longName = "key",
      id = 1,
      annotations = Map(),
      owner = Annotation,
      getter = _.keyOption,
      setterRaw = (r: Annotation.Raw, v: String) => { r.key_=(v) },
      manifest = manifest[String]
    )

  val value =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Annotation, Annotation.type](
      name = "value",
      longName = "value",
      id = 2,
      annotations = Map(),
      owner = Annotation,
      getter = _.valueOption,
      setterRaw = (r: Annotation.Raw, v: String) => { r.value_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Annotation, Annotation.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Annotation, Annotation.type]](
      key,
      value
    )


  def apply(
      key: String,
      value: String
  ): Annotation = {
    val ret = Annotation.createRawRecord
    ret.key_=(key)
    ret.value_=(value)
    ret
  }



  object Builder {
    sealed trait HasKey
    sealed trait HasValue

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasKey with HasValue
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Annotation] (private var obj: Annotation.Raw) {
    def key(v: String): Annotation.Builder[State with Builder.HasKey] = {
      obj.key_=(v)
      this.asInstanceOf[Annotation.Builder[State with Builder.HasKey]]
    }
    def value(v: String): Annotation.Builder[State with Builder.HasValue] = {
      obj.value_=(v)
      this.asInstanceOf[Annotation.Builder[State with Builder.HasValue]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasKey, ev1: State <:< Builder.HasValue): Annotation.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Annotation.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasKey, ev1: State <:< Builder.HasValue): Annotation = resultMutable()(ev0, ev1)
  }

  def newBuilder: Annotation.Builder.AllUnspecified = new Builder(Annotation.createRawRecord)

  implicit val companionProvider: AnnotationCompanionProvider = new AnnotationCompanionProvider
}

class AnnotationCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Annotation] {
  type CompanionT = Annotation.type
  override def provide: Annotation.type = Annotation
}



trait Annotation

    extends com.foursquare.recordv2.runtime.Record[Annotation]
    with scala.Ordered[Annotation]
    with org.apache.thrift.TBase[Annotation, Annotation._Fields] {

  override type MetaT = Annotation.type


  def key: String
  def keyOption: Option[String]
  def keyOrNull: String
  def keyOrThrow: String
  def keyIsSet: Boolean

  def value: String
  def valueOption: Option[String]
  def valueOrNull: String
  def valueOrThrow: String
  def valueIsSet: Boolean
  override def compare(that: Annotation): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.keyIsSet.compareTo(that.keyIsSet)
      cmp != 0 }) cmp
    else if (this.keyIsSet && {
      cmp = this.keyOrNull.compareTo(that.keyOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueIsSet.compareTo(that.valueIsSet)
      cmp != 0 }) cmp
    else if (this.valueIsSet && {
      cmp = this.valueOrNull.compareTo(that.valueOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Annotation

  def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): Annotation

  def mutableCopy(): Annotation.Mutable = {
    val ret = Annotation.createRawRecord

    if (keyIsSet) ret.key_=(keyOrNull)

    if (valueIsSet) ret.value_=(valueOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Annotation.Mutable

  def toBuilder() = {
    val ret = new Annotation.Builder(Annotation.createRawRecord)

    if (keyIsSet) ret.key(keyOrNull)

    if (valueIsSet) ret.value(valueOrNull)
    ret
  }

  def mergeCopy(that: Annotation): Annotation

}


trait AnnotationProxy extends Annotation {
  protected def underlying: Annotation

  override def meta: Annotation.type = underlying.meta

// field/proxy_ref.ssp

  override def key: String = underlying.key
  override def keyOption: Option[String] = underlying.keyOption
  override def keyOrNull: String = underlying.keyOrNull
  override def keyOrThrow: String = underlying.keyOrThrow
  override def keyIsSet: Boolean = underlying.keyIsSet
// field/proxy_ref.ssp

  override def value: String = underlying.value
  override def valueOption: Option[String] = underlying.valueOption
  override def valueOrNull: String = underlying.valueOrNull
  override def valueOrThrow: String = underlying.valueOrThrow
  override def valueIsSet: Boolean = underlying.valueIsSet

  override def compare(that: Annotation): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): Annotation = underlying.copy(
    key = key,
    value = value
  )

  override def mutableCopy(): Annotation.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Annotation): Annotation = underlying.mergeCopy(that)

  override def mutable: Annotation.Mutable = underlying.mutable

  override def deepCopy(): Annotation = underlying.deepCopy()

  override def fieldForId(id: Int): Annotation._Fields = underlying.fieldForId(id)
  override def isSet(field: Annotation._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Annotation._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Annotation._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableAnnotation extends Annotation {
  def key_=(x: String): Unit
  def keyUnset(): Unit
  def value_=(x: String): Unit
  def valueUnset(): Unit

  def merge(that: Annotation): Unit

  def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): Annotation.Mutable

  override def mutable: Annotation.Mutable = this
}

trait MutableAnnotationProxy extends MutableAnnotation with AnnotationProxy {
  protected def underlying: MutableAnnotation

  override def key_=(x: String): Unit = { underlying.key_=(x) }
  override def keyUnset(): Unit = { underlying.keyUnset() }
  override def value_=(x: String): Unit = { underlying.value_=(x) }
  override def valueUnset(): Unit = { underlying.valueUnset() }

  override def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): Annotation.Mutable = underlying.copy(
    key = key,
    value = value
  )

  override def merge(that: Annotation): Unit = underlying.merge(that)
}



final class RawAnnotation extends MutableAnnotation {
  override def meta: Annotation.type = Annotation

  // Field #1 - key
  private var _key: String = null  // Underlying type: String
  override def key: String = keyOrThrow
  override def key_=(x: String): Unit = { _key = x }
  override def keyOption: Option[String] = if (keyIsSet) Some(_key) else None
  override def keyOrNull: String = _key
  override def keyOrThrow: String = if (keyIsSet) _key else throw new java.lang.NullPointerException
  override def keyIsSet: Boolean = _key != null
  override def keyUnset(): Unit = { _key = null }
  // Field #2 - value
  private var _value: String = null  // Underlying type: String
  override def value: String = valueOrThrow
  override def value_=(x: String): Unit = { _value = x }
  override def valueOption: Option[String] = if (valueIsSet) Some(_value) else None
  override def valueOrNull: String = _value
  override def valueOrThrow: String = if (valueIsSet) _value else throw new java.lang.NullPointerException
  override def valueIsSet: Boolean = _value != null
  override def valueUnset(): Unit = { _value = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Annotation.ANNOTATION_DESC)
    if (keyIsSet) {
      oprot.writeFieldBegin(Annotation.KEY_DESC)
      oprot.writeString(_key)
      oprot.writeFieldEnd()
    }
    if (valueIsSet) {
      oprot.writeFieldBegin(Annotation.VALUE_DESC)
      oprot.writeString(_value)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Annotation.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // key

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _key = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // value

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _value = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Annotation".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Annotation): Unit = {
    if (that.keyIsSet && !this.keyIsSet) {
      this.key_=(that.keyOrNull)
    }
    if (that.valueIsSet && !this.valueIsSet) {
      this.value_=(that.valueOrNull)
    }
  }

  override def mergeCopy(that: Annotation): Annotation = {
    val ret = Annotation.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Annotation => this.equals(o)
    case _ => false
  }

  def equals(that: Annotation): Boolean = {
    that != null &&
    (if (this.keyIsSet) (that.keyIsSet && this.keyOrNull == that.keyOrNull) else !that.keyIsSet) &&
    (if (this.valueIsSet) (that.valueIsSet && this.valueOrNull == that.valueOrNull) else !that.valueIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (keyIsSet) hasher.append(_key.##)
    if (valueIsSet) hasher.append(_value.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (keyIsSet) ret = keyOrNull :: ret
    if (valueIsSet) ret = valueOrNull :: ret
    ret.reverse
  }

  override def clear() {
    keyUnset()
    valueUnset()
  }

  def fieldForId(id: Int): Annotation._Fields = id match {
    case 1 => Annotation._Fields.key
    case 2 => Annotation._Fields.value
    case _ => null
  }

  def isSet(field: Annotation._Fields): Boolean = field match {
    case Annotation._Fields.key => keyIsSet
    case Annotation._Fields.value => valueIsSet
    case _ => false
  }

  def getFieldValue(field: Annotation._Fields): AnyRef = field match {
    case Annotation._Fields.key => keyOrNull.asInstanceOf[AnyRef]
    case Annotation._Fields.value => valueOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Annotation._Fields, value: AnyRef) {
    field match {
      case Annotation._Fields.key => key_=(value.asInstanceOf[String])
      case Annotation._Fields.value => value_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): Annotation.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Annotation.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): Annotation.Raw = {
    val ret = new Annotation.Raw
    if (key != null) ret.key_=(key)
    if (value != null) ret.value_=(value)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object BaseType
    extends com.foursquare.recordv2.runtime.MetaRecord[BaseType]
    with com.foursquare.recordv2.runtime.RecordProvider[BaseType] {
  override def recordName: String = "BaseType"


  // Thrift descriptors.
  val BASETYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("BaseType")

  val SIMPLEBASETYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "simpleBaseType",
      org.apache.thrift.protocol.TType.I32,
      1,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "simpleBaseType" -> SIMPLEBASETYPE_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object simpleBaseType extends _Fields(1, "simpleBaseType")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.simpleBaseType,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = BaseType.type
  override type Trait = BaseType
  override type Mutable = MutableBaseType
  override type Raw = RawBaseType

  override def createRecord: BaseType = createRawRecord
  override def createRawRecord: BaseType.Raw = new BaseType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[BaseType] = {
    if (x.isInstanceOf[BaseType]) Some(x.asInstanceOf[BaseType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val simpleBaseType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.SimpleBaseType, BaseType, BaseType.type](
      name = "simpleBaseType",
      longName = "simpleBaseType",
      id = 1,
      annotations = Map(),
      owner = BaseType,
      getter = _.simpleBaseTypeOption,
      setterRaw = (r: BaseType.Raw, v: com.twitter.thrift.descriptors.SimpleBaseType) => { r.simpleBaseType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.SimpleBaseType]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], BaseType, BaseType.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = BaseType,
      getter = _.annotationsOption,
      setterRaw = (r: BaseType.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, BaseType, BaseType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, BaseType, BaseType.type]](
      simpleBaseType,
      __annotations
    )


  def apply(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): BaseType = {
    val ret = BaseType.createRawRecord
    ret.simpleBaseType_=(simpleBaseType)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasSimpleBaseType

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasSimpleBaseType
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[BaseType] (private var obj: BaseType.Raw) {
    def simpleBaseType(v: com.twitter.thrift.descriptors.SimpleBaseType): BaseType.Builder[State with Builder.HasSimpleBaseType] = {
      obj.simpleBaseType_=(v)
      this.asInstanceOf[BaseType.Builder[State with Builder.HasSimpleBaseType]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): BaseType.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): BaseType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasSimpleBaseType): BaseType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("BaseType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasSimpleBaseType): BaseType = resultMutable()(ev0)
  }

  def newBuilder: BaseType.Builder.AllUnspecified = new Builder(BaseType.createRawRecord)

  implicit val companionProvider: BaseTypeCompanionProvider = new BaseTypeCompanionProvider
}

class BaseTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[BaseType] {
  type CompanionT = BaseType.type
  override def provide: BaseType.type = BaseType
}



trait BaseType

    extends com.foursquare.recordv2.runtime.Record[BaseType]
    with scala.Ordered[BaseType]
    with org.apache.thrift.TBase[BaseType, BaseType._Fields] {

  override type MetaT = BaseType.type


  def simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType
  def simpleBaseTypeOption: Option[com.twitter.thrift.descriptors.SimpleBaseType]
  def simpleBaseTypeOrNull: com.twitter.thrift.descriptors.SimpleBaseType
  def simpleBaseTypeOrThrow: com.twitter.thrift.descriptors.SimpleBaseType
  def simpleBaseTypeIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: BaseType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.simpleBaseTypeIsSet.compareTo(that.simpleBaseTypeIsSet)
      cmp != 0 }) cmp
    else if (this.simpleBaseTypeIsSet && {
      cmp = this.simpleBaseTypeOrNull.compareTo(that.simpleBaseTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): BaseType

  def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): BaseType

  def mutableCopy(): BaseType.Mutable = {
    val ret = BaseType.createRawRecord

    if (simpleBaseTypeIsSet) ret.simpleBaseType_=(simpleBaseTypeOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: BaseType.Mutable

  def toBuilder() = {
    val ret = new BaseType.Builder(BaseType.createRawRecord)

    if (simpleBaseTypeIsSet) ret.simpleBaseType(simpleBaseTypeOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: BaseType): BaseType

}


trait BaseTypeProxy extends BaseType {
  protected def underlying: BaseType

  override def meta: BaseType.type = underlying.meta

// field/proxy_ref.ssp

  override def simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = underlying.simpleBaseType
  override def simpleBaseTypeOption: Option[com.twitter.thrift.descriptors.SimpleBaseType] = underlying.simpleBaseTypeOption
  override def simpleBaseTypeOrNull: com.twitter.thrift.descriptors.SimpleBaseType = underlying.simpleBaseTypeOrNull
  override def simpleBaseTypeOrThrow: com.twitter.thrift.descriptors.SimpleBaseType = underlying.simpleBaseTypeOrThrow
  override def simpleBaseTypeIsSet: Boolean = underlying.simpleBaseTypeIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: BaseType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): BaseType = underlying.copy(
    simpleBaseType = simpleBaseType,
    __annotations = __annotations
  )

  override def mutableCopy(): BaseType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: BaseType): BaseType = underlying.mergeCopy(that)

  override def mutable: BaseType.Mutable = underlying.mutable

  override def deepCopy(): BaseType = underlying.deepCopy()

  override def fieldForId(id: Int): BaseType._Fields = underlying.fieldForId(id)
  override def isSet(field: BaseType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: BaseType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: BaseType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableBaseType extends BaseType {
  def simpleBaseType_=(x: com.twitter.thrift.descriptors.SimpleBaseType): Unit
  def simpleBaseTypeUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: BaseType): Unit

  def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): BaseType.Mutable

  override def mutable: BaseType.Mutable = this
}

trait MutableBaseTypeProxy extends MutableBaseType with BaseTypeProxy {
  protected def underlying: MutableBaseType

  override def simpleBaseType_=(x: com.twitter.thrift.descriptors.SimpleBaseType): Unit = { underlying.simpleBaseType_=(x) }
  override def simpleBaseTypeUnset(): Unit = { underlying.simpleBaseTypeUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): BaseType.Mutable = underlying.copy(
    simpleBaseType = simpleBaseType,
    __annotations = __annotations
  )

  override def merge(that: BaseType): Unit = underlying.merge(that)
}



final class RawBaseType extends MutableBaseType {
  override def meta: BaseType.type = BaseType

  // Field #1 - simpleBaseType
  private var _simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = null  // Underlying type: com.twitter.thrift.descriptors.SimpleBaseType
  override def simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrThrow
  override def simpleBaseType_=(x: com.twitter.thrift.descriptors.SimpleBaseType): Unit = { _simpleBaseType = x }
  override def simpleBaseTypeOption: Option[com.twitter.thrift.descriptors.SimpleBaseType] = if (simpleBaseTypeIsSet) Some(_simpleBaseType) else None
  override def simpleBaseTypeOrNull: com.twitter.thrift.descriptors.SimpleBaseType = _simpleBaseType
  override def simpleBaseTypeOrThrow: com.twitter.thrift.descriptors.SimpleBaseType = if (simpleBaseTypeIsSet) _simpleBaseType else throw new java.lang.NullPointerException
  override def simpleBaseTypeIsSet: Boolean = _simpleBaseType != null
  override def simpleBaseTypeUnset(): Unit = { _simpleBaseType = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(BaseType.BASETYPE_DESC)
    if (simpleBaseTypeIsSet) {
      oprot.writeFieldBegin(BaseType.SIMPLEBASETYPE_DESC)
      oprot.writeI32(_simpleBaseType.getValue())
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(BaseType.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        BaseType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // simpleBaseType

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32 || field_header.`type` == org.apache.thrift.protocol.TType.ENUM) {
              _simpleBaseType = com.twitter.thrift.descriptors.SimpleBaseType.findByIdOrNull(iprot.readI32())
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure BaseType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: BaseType): Unit = {
    if (that.simpleBaseTypeIsSet && !this.simpleBaseTypeIsSet) {
      this.simpleBaseType_=(that.simpleBaseTypeOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: BaseType): BaseType = {
    val ret = BaseType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: BaseType => this.equals(o)
    case _ => false
  }

  def equals(that: BaseType): Boolean = {
    that != null &&
    (if (this.simpleBaseTypeIsSet) (that.simpleBaseTypeIsSet && this.simpleBaseTypeOrNull == that.simpleBaseTypeOrNull) else !that.simpleBaseTypeIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (simpleBaseTypeIsSet) hasher.append(_simpleBaseType.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (simpleBaseTypeIsSet) ret = simpleBaseTypeOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    simpleBaseTypeUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): BaseType._Fields = id match {
    case 1 => BaseType._Fields.simpleBaseType
    case 99 => BaseType._Fields.__annotations
    case _ => null
  }

  def isSet(field: BaseType._Fields): Boolean = field match {
    case BaseType._Fields.simpleBaseType => simpleBaseTypeIsSet
    case BaseType._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: BaseType._Fields): AnyRef = field match {
    case BaseType._Fields.simpleBaseType => simpleBaseTypeOrNull.asInstanceOf[AnyRef]
    case BaseType._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: BaseType._Fields, value: AnyRef) {
    field match {
      case BaseType._Fields.simpleBaseType => simpleBaseType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SimpleBaseType])
      case BaseType._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): BaseType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = BaseType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): BaseType.Raw = {
    val ret = new BaseType.Raw
    if (simpleBaseType != null) ret.simpleBaseType_=(simpleBaseType)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object ListType
    extends com.foursquare.recordv2.runtime.MetaRecord[ListType]
    with com.foursquare.recordv2.runtime.RecordProvider[ListType] {
  override def recordName: String = "ListType"


  // Thrift descriptors.
  val LISTTYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("ListType")

  val ELEMENTTYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "elementTypeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "elementTypeId" -> ELEMENTTYPEID_DESC
  )

  object _Fields {
    case object elementTypeId extends _Fields(1, "elementTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.elementTypeId
  )

  // Record v2
  override type Self = ListType.type
  override type Trait = ListType
  override type Mutable = MutableListType
  override type Raw = RawListType

  override def createRecord: ListType = createRawRecord
  override def createRawRecord: ListType.Raw = new ListType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[ListType] = {
    if (x.isInstanceOf[ListType]) Some(x.asInstanceOf[ListType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val elementTypeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, ListType, ListType.type](
      name = "elementTypeId",
      longName = "elementTypeId",
      id = 1,
      annotations = Map(),
      owner = ListType,
      getter = _.elementTypeIdOption,
      setterRaw = (r: ListType.Raw, v: String) => { r.elementTypeId_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, ListType, ListType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, ListType, ListType.type]](
      elementTypeId
    )


  def apply(
      elementTypeId: String
  ): ListType = {
    val ret = ListType.createRawRecord
    ret.elementTypeId_=(elementTypeId)
    ret
  }



  object Builder {
    sealed trait HasElementTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasElementTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[ListType] (private var obj: ListType.Raw) {
    def elementTypeId(v: String): ListType.Builder[State with Builder.HasElementTypeId] = {
      obj.elementTypeId_=(v)
      this.asInstanceOf[ListType.Builder[State with Builder.HasElementTypeId]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasElementTypeId): ListType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("ListType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasElementTypeId): ListType = resultMutable()(ev0)
  }

  def newBuilder: ListType.Builder.AllUnspecified = new Builder(ListType.createRawRecord)

  implicit val companionProvider: ListTypeCompanionProvider = new ListTypeCompanionProvider
}

class ListTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[ListType] {
  type CompanionT = ListType.type
  override def provide: ListType.type = ListType
}



trait ListType

    extends com.foursquare.recordv2.runtime.Record[ListType]
    with scala.Ordered[ListType]
    with org.apache.thrift.TBase[ListType, ListType._Fields] {

  override type MetaT = ListType.type


  def elementTypeId: String
  def elementTypeIdOption: Option[String]
  def elementTypeIdOrNull: String
  def elementTypeIdOrThrow: String
  def elementTypeIdIsSet: Boolean
  override def compare(that: ListType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.elementTypeIdIsSet.compareTo(that.elementTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.elementTypeIdIsSet && {
      cmp = this.elementTypeIdOrNull.compareTo(that.elementTypeIdOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): ListType

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): ListType

  def mutableCopy(): ListType.Mutable = {
    val ret = ListType.createRawRecord

    if (elementTypeIdIsSet) ret.elementTypeId_=(elementTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: ListType.Mutable

  def toBuilder() = {
    val ret = new ListType.Builder(ListType.createRawRecord)

    if (elementTypeIdIsSet) ret.elementTypeId(elementTypeIdOrNull)
    ret
  }

  def mergeCopy(that: ListType): ListType

}


trait ListTypeProxy extends ListType {
  protected def underlying: ListType

  override def meta: ListType.type = underlying.meta

// field/proxy_ref.ssp

  override def elementTypeId: String = underlying.elementTypeId
  override def elementTypeIdOption: Option[String] = underlying.elementTypeIdOption
  override def elementTypeIdOrNull: String = underlying.elementTypeIdOrNull
  override def elementTypeIdOrThrow: String = underlying.elementTypeIdOrThrow
  override def elementTypeIdIsSet: Boolean = underlying.elementTypeIdIsSet

  override def compare(that: ListType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): ListType = underlying.copy(
    elementTypeId = elementTypeId
  )

  override def mutableCopy(): ListType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: ListType): ListType = underlying.mergeCopy(that)

  override def mutable: ListType.Mutable = underlying.mutable

  override def deepCopy(): ListType = underlying.deepCopy()

  override def fieldForId(id: Int): ListType._Fields = underlying.fieldForId(id)
  override def isSet(field: ListType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: ListType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: ListType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableListType extends ListType {
  def elementTypeId_=(x: String): Unit
  def elementTypeIdUnset(): Unit

  def merge(that: ListType): Unit

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): ListType.Mutable

  override def mutable: ListType.Mutable = this
}

trait MutableListTypeProxy extends MutableListType with ListTypeProxy {
  protected def underlying: MutableListType

  override def elementTypeId_=(x: String): Unit = { underlying.elementTypeId_=(x) }
  override def elementTypeIdUnset(): Unit = { underlying.elementTypeIdUnset() }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): ListType.Mutable = underlying.copy(
    elementTypeId = elementTypeId
  )

  override def merge(that: ListType): Unit = underlying.merge(that)
}



final class RawListType extends MutableListType {
  override def meta: ListType.type = ListType

  // Field #1 - elementTypeId
  private var _elementTypeId: String = null  // Underlying type: String
  override def elementTypeId: String = elementTypeIdOrThrow
  override def elementTypeId_=(x: String): Unit = { _elementTypeId = x }
  override def elementTypeIdOption: Option[String] = if (elementTypeIdIsSet) Some(_elementTypeId) else None
  override def elementTypeIdOrNull: String = _elementTypeId
  override def elementTypeIdOrThrow: String = if (elementTypeIdIsSet) _elementTypeId else throw new java.lang.NullPointerException
  override def elementTypeIdIsSet: Boolean = _elementTypeId != null
  override def elementTypeIdUnset(): Unit = { _elementTypeId = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(ListType.LISTTYPE_DESC)
    if (elementTypeIdIsSet) {
      oprot.writeFieldBegin(ListType.ELEMENTTYPEID_DESC)
      oprot.writeString(_elementTypeId)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        ListType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // elementTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _elementTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure ListType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: ListType): Unit = {
    if (that.elementTypeIdIsSet && !this.elementTypeIdIsSet) {
      this.elementTypeId_=(that.elementTypeIdOrNull)
    }
  }

  override def mergeCopy(that: ListType): ListType = {
    val ret = ListType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: ListType => this.equals(o)
    case _ => false
  }

  def equals(that: ListType): Boolean = {
    that != null &&
    (if (this.elementTypeIdIsSet) (that.elementTypeIdIsSet && this.elementTypeIdOrNull == that.elementTypeIdOrNull) else !that.elementTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (elementTypeIdIsSet) hasher.append(_elementTypeId.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (elementTypeIdIsSet) ret = elementTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    elementTypeIdUnset()
  }

  def fieldForId(id: Int): ListType._Fields = id match {
    case 1 => ListType._Fields.elementTypeId
    case _ => null
  }

  def isSet(field: ListType._Fields): Boolean = field match {
    case ListType._Fields.elementTypeId => elementTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: ListType._Fields): AnyRef = field match {
    case ListType._Fields.elementTypeId => elementTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: ListType._Fields, value: AnyRef) {
    field match {
      case ListType._Fields.elementTypeId => elementTypeId_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): ListType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = ListType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): ListType.Raw = {
    val ret = new ListType.Raw
    if (elementTypeId != null) ret.elementTypeId_=(elementTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object SetType
    extends com.foursquare.recordv2.runtime.MetaRecord[SetType]
    with com.foursquare.recordv2.runtime.RecordProvider[SetType] {
  override def recordName: String = "SetType"


  // Thrift descriptors.
  val SETTYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("SetType")

  val ELEMENTTYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "elementTypeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "elementTypeId" -> ELEMENTTYPEID_DESC
  )

  object _Fields {
    case object elementTypeId extends _Fields(1, "elementTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.elementTypeId
  )

  // Record v2
  override type Self = SetType.type
  override type Trait = SetType
  override type Mutable = MutableSetType
  override type Raw = RawSetType

  override def createRecord: SetType = createRawRecord
  override def createRawRecord: SetType.Raw = new SetType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[SetType] = {
    if (x.isInstanceOf[SetType]) Some(x.asInstanceOf[SetType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val elementTypeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, SetType, SetType.type](
      name = "elementTypeId",
      longName = "elementTypeId",
      id = 1,
      annotations = Map(),
      owner = SetType,
      getter = _.elementTypeIdOption,
      setterRaw = (r: SetType.Raw, v: String) => { r.elementTypeId_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, SetType, SetType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, SetType, SetType.type]](
      elementTypeId
    )


  def apply(
      elementTypeId: String
  ): SetType = {
    val ret = SetType.createRawRecord
    ret.elementTypeId_=(elementTypeId)
    ret
  }



  object Builder {
    sealed trait HasElementTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasElementTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[SetType] (private var obj: SetType.Raw) {
    def elementTypeId(v: String): SetType.Builder[State with Builder.HasElementTypeId] = {
      obj.elementTypeId_=(v)
      this.asInstanceOf[SetType.Builder[State with Builder.HasElementTypeId]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasElementTypeId): SetType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("SetType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasElementTypeId): SetType = resultMutable()(ev0)
  }

  def newBuilder: SetType.Builder.AllUnspecified = new Builder(SetType.createRawRecord)

  implicit val companionProvider: SetTypeCompanionProvider = new SetTypeCompanionProvider
}

class SetTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[SetType] {
  type CompanionT = SetType.type
  override def provide: SetType.type = SetType
}



trait SetType

    extends com.foursquare.recordv2.runtime.Record[SetType]
    with scala.Ordered[SetType]
    with org.apache.thrift.TBase[SetType, SetType._Fields] {

  override type MetaT = SetType.type


  def elementTypeId: String
  def elementTypeIdOption: Option[String]
  def elementTypeIdOrNull: String
  def elementTypeIdOrThrow: String
  def elementTypeIdIsSet: Boolean
  override def compare(that: SetType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.elementTypeIdIsSet.compareTo(that.elementTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.elementTypeIdIsSet && {
      cmp = this.elementTypeIdOrNull.compareTo(that.elementTypeIdOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): SetType

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): SetType

  def mutableCopy(): SetType.Mutable = {
    val ret = SetType.createRawRecord

    if (elementTypeIdIsSet) ret.elementTypeId_=(elementTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: SetType.Mutable

  def toBuilder() = {
    val ret = new SetType.Builder(SetType.createRawRecord)

    if (elementTypeIdIsSet) ret.elementTypeId(elementTypeIdOrNull)
    ret
  }

  def mergeCopy(that: SetType): SetType

}


trait SetTypeProxy extends SetType {
  protected def underlying: SetType

  override def meta: SetType.type = underlying.meta

// field/proxy_ref.ssp

  override def elementTypeId: String = underlying.elementTypeId
  override def elementTypeIdOption: Option[String] = underlying.elementTypeIdOption
  override def elementTypeIdOrNull: String = underlying.elementTypeIdOrNull
  override def elementTypeIdOrThrow: String = underlying.elementTypeIdOrThrow
  override def elementTypeIdIsSet: Boolean = underlying.elementTypeIdIsSet

  override def compare(that: SetType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): SetType = underlying.copy(
    elementTypeId = elementTypeId
  )

  override def mutableCopy(): SetType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: SetType): SetType = underlying.mergeCopy(that)

  override def mutable: SetType.Mutable = underlying.mutable

  override def deepCopy(): SetType = underlying.deepCopy()

  override def fieldForId(id: Int): SetType._Fields = underlying.fieldForId(id)
  override def isSet(field: SetType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: SetType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: SetType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableSetType extends SetType {
  def elementTypeId_=(x: String): Unit
  def elementTypeIdUnset(): Unit

  def merge(that: SetType): Unit

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): SetType.Mutable

  override def mutable: SetType.Mutable = this
}

trait MutableSetTypeProxy extends MutableSetType with SetTypeProxy {
  protected def underlying: MutableSetType

  override def elementTypeId_=(x: String): Unit = { underlying.elementTypeId_=(x) }
  override def elementTypeIdUnset(): Unit = { underlying.elementTypeIdUnset() }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): SetType.Mutable = underlying.copy(
    elementTypeId = elementTypeId
  )

  override def merge(that: SetType): Unit = underlying.merge(that)
}



final class RawSetType extends MutableSetType {
  override def meta: SetType.type = SetType

  // Field #1 - elementTypeId
  private var _elementTypeId: String = null  // Underlying type: String
  override def elementTypeId: String = elementTypeIdOrThrow
  override def elementTypeId_=(x: String): Unit = { _elementTypeId = x }
  override def elementTypeIdOption: Option[String] = if (elementTypeIdIsSet) Some(_elementTypeId) else None
  override def elementTypeIdOrNull: String = _elementTypeId
  override def elementTypeIdOrThrow: String = if (elementTypeIdIsSet) _elementTypeId else throw new java.lang.NullPointerException
  override def elementTypeIdIsSet: Boolean = _elementTypeId != null
  override def elementTypeIdUnset(): Unit = { _elementTypeId = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(SetType.SETTYPE_DESC)
    if (elementTypeIdIsSet) {
      oprot.writeFieldBegin(SetType.ELEMENTTYPEID_DESC)
      oprot.writeString(_elementTypeId)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        SetType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // elementTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _elementTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure SetType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: SetType): Unit = {
    if (that.elementTypeIdIsSet && !this.elementTypeIdIsSet) {
      this.elementTypeId_=(that.elementTypeIdOrNull)
    }
  }

  override def mergeCopy(that: SetType): SetType = {
    val ret = SetType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: SetType => this.equals(o)
    case _ => false
  }

  def equals(that: SetType): Boolean = {
    that != null &&
    (if (this.elementTypeIdIsSet) (that.elementTypeIdIsSet && this.elementTypeIdOrNull == that.elementTypeIdOrNull) else !that.elementTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (elementTypeIdIsSet) hasher.append(_elementTypeId.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (elementTypeIdIsSet) ret = elementTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    elementTypeIdUnset()
  }

  def fieldForId(id: Int): SetType._Fields = id match {
    case 1 => SetType._Fields.elementTypeId
    case _ => null
  }

  def isSet(field: SetType._Fields): Boolean = field match {
    case SetType._Fields.elementTypeId => elementTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: SetType._Fields): AnyRef = field match {
    case SetType._Fields.elementTypeId => elementTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: SetType._Fields, value: AnyRef) {
    field match {
      case SetType._Fields.elementTypeId => elementTypeId_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): SetType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = SetType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): SetType.Raw = {
    val ret = new SetType.Raw
    if (elementTypeId != null) ret.elementTypeId_=(elementTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object MapType
    extends com.foursquare.recordv2.runtime.MetaRecord[MapType]
    with com.foursquare.recordv2.runtime.RecordProvider[MapType] {
  override def recordName: String = "MapType"


  // Thrift descriptors.
  val MAPTYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("MapType")

  val KEYTYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "keyTypeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val VALUETYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "valueTypeId",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "keyTypeId" -> KEYTYPEID_DESC,
    "valueTypeId" -> VALUETYPEID_DESC
  )

  object _Fields {
    case object keyTypeId extends _Fields(1, "keyTypeId")
    case object valueTypeId extends _Fields(2, "valueTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.keyTypeId,
    2.toShort -> _Fields.valueTypeId
  )

  // Record v2
  override type Self = MapType.type
  override type Trait = MapType
  override type Mutable = MutableMapType
  override type Raw = RawMapType

  override def createRecord: MapType = createRawRecord
  override def createRawRecord: MapType.Raw = new MapType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[MapType] = {
    if (x.isInstanceOf[MapType]) Some(x.asInstanceOf[MapType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val keyTypeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, MapType, MapType.type](
      name = "keyTypeId",
      longName = "keyTypeId",
      id = 1,
      annotations = Map(),
      owner = MapType,
      getter = _.keyTypeIdOption,
      setterRaw = (r: MapType.Raw, v: String) => { r.keyTypeId_=(v) },
      manifest = manifest[String]
    )

  val valueTypeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, MapType, MapType.type](
      name = "valueTypeId",
      longName = "valueTypeId",
      id = 2,
      annotations = Map(),
      owner = MapType,
      getter = _.valueTypeIdOption,
      setterRaw = (r: MapType.Raw, v: String) => { r.valueTypeId_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, MapType, MapType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, MapType, MapType.type]](
      keyTypeId,
      valueTypeId
    )


  def apply(
      keyTypeId: String,
      valueTypeId: String
  ): MapType = {
    val ret = MapType.createRawRecord
    ret.keyTypeId_=(keyTypeId)
    ret.valueTypeId_=(valueTypeId)
    ret
  }



  object Builder {
    sealed trait HasKeyTypeId
    sealed trait HasValueTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasKeyTypeId with HasValueTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[MapType] (private var obj: MapType.Raw) {
    def keyTypeId(v: String): MapType.Builder[State with Builder.HasKeyTypeId] = {
      obj.keyTypeId_=(v)
      this.asInstanceOf[MapType.Builder[State with Builder.HasKeyTypeId]]
    }
    def valueTypeId(v: String): MapType.Builder[State with Builder.HasValueTypeId] = {
      obj.valueTypeId_=(v)
      this.asInstanceOf[MapType.Builder[State with Builder.HasValueTypeId]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasKeyTypeId, ev1: State <:< Builder.HasValueTypeId): MapType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("MapType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasKeyTypeId, ev1: State <:< Builder.HasValueTypeId): MapType = resultMutable()(ev0, ev1)
  }

  def newBuilder: MapType.Builder.AllUnspecified = new Builder(MapType.createRawRecord)

  implicit val companionProvider: MapTypeCompanionProvider = new MapTypeCompanionProvider
}

class MapTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[MapType] {
  type CompanionT = MapType.type
  override def provide: MapType.type = MapType
}



trait MapType

    extends com.foursquare.recordv2.runtime.Record[MapType]
    with scala.Ordered[MapType]
    with org.apache.thrift.TBase[MapType, MapType._Fields] {

  override type MetaT = MapType.type


  def keyTypeId: String
  def keyTypeIdOption: Option[String]
  def keyTypeIdOrNull: String
  def keyTypeIdOrThrow: String
  def keyTypeIdIsSet: Boolean

  def valueTypeId: String
  def valueTypeIdOption: Option[String]
  def valueTypeIdOrNull: String
  def valueTypeIdOrThrow: String
  def valueTypeIdIsSet: Boolean
  override def compare(that: MapType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.keyTypeIdIsSet.compareTo(that.keyTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.keyTypeIdIsSet && {
      cmp = this.keyTypeIdOrNull.compareTo(that.keyTypeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueTypeIdIsSet.compareTo(that.valueTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.valueTypeIdIsSet && {
      cmp = this.valueTypeIdOrNull.compareTo(that.valueTypeIdOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): MapType

  def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MapType

  def mutableCopy(): MapType.Mutable = {
    val ret = MapType.createRawRecord

    if (keyTypeIdIsSet) ret.keyTypeId_=(keyTypeIdOrNull)

    if (valueTypeIdIsSet) ret.valueTypeId_=(valueTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MapType.Mutable

  def toBuilder() = {
    val ret = new MapType.Builder(MapType.createRawRecord)

    if (keyTypeIdIsSet) ret.keyTypeId(keyTypeIdOrNull)

    if (valueTypeIdIsSet) ret.valueTypeId(valueTypeIdOrNull)
    ret
  }

  def mergeCopy(that: MapType): MapType

}


trait MapTypeProxy extends MapType {
  protected def underlying: MapType

  override def meta: MapType.type = underlying.meta

// field/proxy_ref.ssp

  override def keyTypeId: String = underlying.keyTypeId
  override def keyTypeIdOption: Option[String] = underlying.keyTypeIdOption
  override def keyTypeIdOrNull: String = underlying.keyTypeIdOrNull
  override def keyTypeIdOrThrow: String = underlying.keyTypeIdOrThrow
  override def keyTypeIdIsSet: Boolean = underlying.keyTypeIdIsSet
// field/proxy_ref.ssp

  override def valueTypeId: String = underlying.valueTypeId
  override def valueTypeIdOption: Option[String] = underlying.valueTypeIdOption
  override def valueTypeIdOrNull: String = underlying.valueTypeIdOrNull
  override def valueTypeIdOrThrow: String = underlying.valueTypeIdOrThrow
  override def valueTypeIdIsSet: Boolean = underlying.valueTypeIdIsSet

  override def compare(that: MapType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MapType = underlying.copy(
    keyTypeId = keyTypeId,
    valueTypeId = valueTypeId
  )

  override def mutableCopy(): MapType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: MapType): MapType = underlying.mergeCopy(that)

  override def mutable: MapType.Mutable = underlying.mutable

  override def deepCopy(): MapType = underlying.deepCopy()

  override def fieldForId(id: Int): MapType._Fields = underlying.fieldForId(id)
  override def isSet(field: MapType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: MapType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: MapType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableMapType extends MapType {
  def keyTypeId_=(x: String): Unit
  def keyTypeIdUnset(): Unit
  def valueTypeId_=(x: String): Unit
  def valueTypeIdUnset(): Unit

  def merge(that: MapType): Unit

  def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MapType.Mutable

  override def mutable: MapType.Mutable = this
}

trait MutableMapTypeProxy extends MutableMapType with MapTypeProxy {
  protected def underlying: MutableMapType

  override def keyTypeId_=(x: String): Unit = { underlying.keyTypeId_=(x) }
  override def keyTypeIdUnset(): Unit = { underlying.keyTypeIdUnset() }
  override def valueTypeId_=(x: String): Unit = { underlying.valueTypeId_=(x) }
  override def valueTypeIdUnset(): Unit = { underlying.valueTypeIdUnset() }

  override def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MapType.Mutable = underlying.copy(
    keyTypeId = keyTypeId,
    valueTypeId = valueTypeId
  )

  override def merge(that: MapType): Unit = underlying.merge(that)
}



final class RawMapType extends MutableMapType {
  override def meta: MapType.type = MapType

  // Field #1 - keyTypeId
  private var _keyTypeId: String = null  // Underlying type: String
  override def keyTypeId: String = keyTypeIdOrThrow
  override def keyTypeId_=(x: String): Unit = { _keyTypeId = x }
  override def keyTypeIdOption: Option[String] = if (keyTypeIdIsSet) Some(_keyTypeId) else None
  override def keyTypeIdOrNull: String = _keyTypeId
  override def keyTypeIdOrThrow: String = if (keyTypeIdIsSet) _keyTypeId else throw new java.lang.NullPointerException
  override def keyTypeIdIsSet: Boolean = _keyTypeId != null
  override def keyTypeIdUnset(): Unit = { _keyTypeId = null }
  // Field #2 - valueTypeId
  private var _valueTypeId: String = null  // Underlying type: String
  override def valueTypeId: String = valueTypeIdOrThrow
  override def valueTypeId_=(x: String): Unit = { _valueTypeId = x }
  override def valueTypeIdOption: Option[String] = if (valueTypeIdIsSet) Some(_valueTypeId) else None
  override def valueTypeIdOrNull: String = _valueTypeId
  override def valueTypeIdOrThrow: String = if (valueTypeIdIsSet) _valueTypeId else throw new java.lang.NullPointerException
  override def valueTypeIdIsSet: Boolean = _valueTypeId != null
  override def valueTypeIdUnset(): Unit = { _valueTypeId = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(MapType.MAPTYPE_DESC)
    if (keyTypeIdIsSet) {
      oprot.writeFieldBegin(MapType.KEYTYPEID_DESC)
      oprot.writeString(_keyTypeId)
      oprot.writeFieldEnd()
    }
    if (valueTypeIdIsSet) {
      oprot.writeFieldBegin(MapType.VALUETYPEID_DESC)
      oprot.writeString(_valueTypeId)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        MapType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // keyTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _keyTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // valueTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _valueTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure MapType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: MapType): Unit = {
    if (that.keyTypeIdIsSet && !this.keyTypeIdIsSet) {
      this.keyTypeId_=(that.keyTypeIdOrNull)
    }
    if (that.valueTypeIdIsSet && !this.valueTypeIdIsSet) {
      this.valueTypeId_=(that.valueTypeIdOrNull)
    }
  }

  override def mergeCopy(that: MapType): MapType = {
    val ret = MapType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: MapType => this.equals(o)
    case _ => false
  }

  def equals(that: MapType): Boolean = {
    that != null &&
    (if (this.keyTypeIdIsSet) (that.keyTypeIdIsSet && this.keyTypeIdOrNull == that.keyTypeIdOrNull) else !that.keyTypeIdIsSet) &&
    (if (this.valueTypeIdIsSet) (that.valueTypeIdIsSet && this.valueTypeIdOrNull == that.valueTypeIdOrNull) else !that.valueTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (keyTypeIdIsSet) hasher.append(_keyTypeId.##)
    if (valueTypeIdIsSet) hasher.append(_valueTypeId.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (keyTypeIdIsSet) ret = keyTypeIdOrNull :: ret
    if (valueTypeIdIsSet) ret = valueTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    keyTypeIdUnset()
    valueTypeIdUnset()
  }

  def fieldForId(id: Int): MapType._Fields = id match {
    case 1 => MapType._Fields.keyTypeId
    case 2 => MapType._Fields.valueTypeId
    case _ => null
  }

  def isSet(field: MapType._Fields): Boolean = field match {
    case MapType._Fields.keyTypeId => keyTypeIdIsSet
    case MapType._Fields.valueTypeId => valueTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: MapType._Fields): AnyRef = field match {
    case MapType._Fields.keyTypeId => keyTypeIdOrNull.asInstanceOf[AnyRef]
    case MapType._Fields.valueTypeId => valueTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: MapType._Fields, value: AnyRef) {
    field match {
      case MapType._Fields.keyTypeId => keyTypeId_=(value.asInstanceOf[String])
      case MapType._Fields.valueTypeId => valueTypeId_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): MapType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = MapType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MapType.Raw = {
    val ret = new MapType.Raw
    if (keyTypeId != null) ret.keyTypeId_=(keyTypeId)
    if (valueTypeId != null) ret.valueTypeId_=(valueTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object ContainerType
    extends com.foursquare.recordv2.runtime.MetaRecord[ContainerType]
    with com.foursquare.recordv2.runtime.RecordProvider[ContainerType] {
  override def recordName: String = "ContainerType"


  // Thrift descriptors.
  val CONTAINERTYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("ContainerType")

  val SIMPLECONTAINERTYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "simpleContainerType",
      org.apache.thrift.protocol.TType.STRUCT,
      1,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "simpleContainerType" -> SIMPLECONTAINERTYPE_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object simpleContainerType extends _Fields(1, "simpleContainerType")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.simpleContainerType,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = ContainerType.type
  override type Trait = ContainerType
  override type Mutable = MutableContainerType
  override type Raw = RawContainerType

  override def createRecord: ContainerType = createRawRecord
  override def createRawRecord: ContainerType.Raw = new ContainerType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[ContainerType] = {
    if (x.isInstanceOf[ContainerType]) Some(x.asInstanceOf[ContainerType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val simpleContainerType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.SimpleContainerType, ContainerType, ContainerType.type](
      name = "simpleContainerType",
      longName = "simpleContainerType",
      id = 1,
      annotations = Map(),
      owner = ContainerType,
      getter = _.simpleContainerTypeOption,
      setterRaw = (r: ContainerType.Raw, v: com.twitter.thrift.descriptors.SimpleContainerType) => { r.simpleContainerType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.SimpleContainerType]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], ContainerType, ContainerType.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = ContainerType,
      getter = _.annotationsOption,
      setterRaw = (r: ContainerType.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, ContainerType, ContainerType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, ContainerType, ContainerType.type]](
      simpleContainerType,
      __annotations
    )


  def apply(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): ContainerType = {
    val ret = ContainerType.createRawRecord
    ret.simpleContainerType_=(simpleContainerType)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasSimpleContainerType

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasSimpleContainerType
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[ContainerType] (private var obj: ContainerType.Raw) {
    def simpleContainerType(v: com.twitter.thrift.descriptors.SimpleContainerType): ContainerType.Builder[State with Builder.HasSimpleContainerType] = {
      obj.simpleContainerType_=(v)
      this.asInstanceOf[ContainerType.Builder[State with Builder.HasSimpleContainerType]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): ContainerType.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): ContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasSimpleContainerType): ContainerType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("ContainerType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasSimpleContainerType): ContainerType = resultMutable()(ev0)
  }

  def newBuilder: ContainerType.Builder.AllUnspecified = new Builder(ContainerType.createRawRecord)

  implicit val companionProvider: ContainerTypeCompanionProvider = new ContainerTypeCompanionProvider
}

class ContainerTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[ContainerType] {
  type CompanionT = ContainerType.type
  override def provide: ContainerType.type = ContainerType
}



trait ContainerType

    extends com.foursquare.recordv2.runtime.Record[ContainerType]
    with scala.Ordered[ContainerType]
    with org.apache.thrift.TBase[ContainerType, ContainerType._Fields] {

  override type MetaT = ContainerType.type


  def simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType
  def simpleContainerTypeOption: Option[com.twitter.thrift.descriptors.SimpleContainerType]
  def simpleContainerTypeOrNull: com.twitter.thrift.descriptors.SimpleContainerType
  def simpleContainerTypeOrThrow: com.twitter.thrift.descriptors.SimpleContainerType
  def simpleContainerTypeIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: ContainerType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.simpleContainerTypeIsSet.compareTo(that.simpleContainerTypeIsSet)
      cmp != 0 }) cmp
    else if (this.simpleContainerTypeIsSet && {
      cmp = this.simpleContainerTypeOrNull.compareTo(that.simpleContainerTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): ContainerType

  def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): ContainerType

  def mutableCopy(): ContainerType.Mutable = {
    val ret = ContainerType.createRawRecord

    if (simpleContainerTypeIsSet) ret.simpleContainerType_=(simpleContainerTypeOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: ContainerType.Mutable

  def toBuilder() = {
    val ret = new ContainerType.Builder(ContainerType.createRawRecord)

    if (simpleContainerTypeIsSet) ret.simpleContainerType(simpleContainerTypeOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: ContainerType): ContainerType

}


trait ContainerTypeProxy extends ContainerType {
  protected def underlying: ContainerType

  override def meta: ContainerType.type = underlying.meta

// field/proxy_ref.ssp

  override def simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = underlying.simpleContainerType
  override def simpleContainerTypeOption: Option[com.twitter.thrift.descriptors.SimpleContainerType] = underlying.simpleContainerTypeOption
  override def simpleContainerTypeOrNull: com.twitter.thrift.descriptors.SimpleContainerType = underlying.simpleContainerTypeOrNull
  override def simpleContainerTypeOrThrow: com.twitter.thrift.descriptors.SimpleContainerType = underlying.simpleContainerTypeOrThrow
  override def simpleContainerTypeIsSet: Boolean = underlying.simpleContainerTypeIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: ContainerType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): ContainerType = underlying.copy(
    simpleContainerType = simpleContainerType,
    __annotations = __annotations
  )

  override def mutableCopy(): ContainerType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: ContainerType): ContainerType = underlying.mergeCopy(that)

  override def mutable: ContainerType.Mutable = underlying.mutable

  override def deepCopy(): ContainerType = underlying.deepCopy()

  override def fieldForId(id: Int): ContainerType._Fields = underlying.fieldForId(id)
  override def isSet(field: ContainerType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: ContainerType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: ContainerType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableContainerType extends ContainerType {
  def simpleContainerType_=(x: com.twitter.thrift.descriptors.SimpleContainerType): Unit
  def simpleContainerTypeUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: ContainerType): Unit

  def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): ContainerType.Mutable

  override def mutable: ContainerType.Mutable = this
}

trait MutableContainerTypeProxy extends MutableContainerType with ContainerTypeProxy {
  protected def underlying: MutableContainerType

  override def simpleContainerType_=(x: com.twitter.thrift.descriptors.SimpleContainerType): Unit = { underlying.simpleContainerType_=(x) }
  override def simpleContainerTypeUnset(): Unit = { underlying.simpleContainerTypeUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): ContainerType.Mutable = underlying.copy(
    simpleContainerType = simpleContainerType,
    __annotations = __annotations
  )

  override def merge(that: ContainerType): Unit = underlying.merge(that)
}



final class RawContainerType extends MutableContainerType {
  override def meta: ContainerType.type = ContainerType

  // Field #1 - simpleContainerType
  private var _simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = null  // Underlying type: com.twitter.thrift.descriptors.SimpleContainerType
  override def simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrThrow
  override def simpleContainerType_=(x: com.twitter.thrift.descriptors.SimpleContainerType): Unit = { _simpleContainerType = x }
  override def simpleContainerTypeOption: Option[com.twitter.thrift.descriptors.SimpleContainerType] = if (simpleContainerTypeIsSet) Some(_simpleContainerType) else None
  override def simpleContainerTypeOrNull: com.twitter.thrift.descriptors.SimpleContainerType = _simpleContainerType
  override def simpleContainerTypeOrThrow: com.twitter.thrift.descriptors.SimpleContainerType = if (simpleContainerTypeIsSet) _simpleContainerType else throw new java.lang.NullPointerException
  override def simpleContainerTypeIsSet: Boolean = _simpleContainerType != null
  override def simpleContainerTypeUnset(): Unit = { _simpleContainerType = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(ContainerType.CONTAINERTYPE_DESC)
    if (simpleContainerTypeIsSet) {
      oprot.writeFieldBegin(ContainerType.SIMPLECONTAINERTYPE_DESC)
      _simpleContainerType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(ContainerType.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        ContainerType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // simpleContainerType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _simpleContainerType = ({
                val s = com.twitter.thrift.descriptors.SimpleContainerType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure ContainerType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: ContainerType): Unit = {
    if (that.simpleContainerTypeIsSet && !this.simpleContainerTypeIsSet) {
      this.simpleContainerType_=(that.simpleContainerTypeOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: ContainerType): ContainerType = {
    val ret = ContainerType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: ContainerType => this.equals(o)
    case _ => false
  }

  def equals(that: ContainerType): Boolean = {
    that != null &&
    (if (this.simpleContainerTypeIsSet) (that.simpleContainerTypeIsSet && this.simpleContainerTypeOrNull == that.simpleContainerTypeOrNull) else !that.simpleContainerTypeIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (simpleContainerTypeIsSet) hasher.append(_simpleContainerType.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (simpleContainerTypeIsSet) ret = simpleContainerTypeOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    simpleContainerTypeUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): ContainerType._Fields = id match {
    case 1 => ContainerType._Fields.simpleContainerType
    case 99 => ContainerType._Fields.__annotations
    case _ => null
  }

  def isSet(field: ContainerType._Fields): Boolean = field match {
    case ContainerType._Fields.simpleContainerType => simpleContainerTypeIsSet
    case ContainerType._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: ContainerType._Fields): AnyRef = field match {
    case ContainerType._Fields.simpleContainerType => simpleContainerTypeOrNull.asInstanceOf[AnyRef]
    case ContainerType._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: ContainerType._Fields, value: AnyRef) {
    field match {
      case ContainerType._Fields.simpleContainerType => simpleContainerType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SimpleContainerType])
      case ContainerType._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): ContainerType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = ContainerType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): ContainerType.Raw = {
    val ret = new ContainerType.Raw
    if (simpleContainerType != null) ret.simpleContainerType_=(simpleContainerType)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Typeref
    extends com.foursquare.recordv2.runtime.MetaRecord[Typeref]
    with com.foursquare.recordv2.runtime.RecordProvider[Typeref] {
  override def recordName: String = "Typeref"


  // Thrift descriptors.
  val TYPEREF_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Typeref")

  val TYPEALIAS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeAlias",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "typeAlias" -> TYPEALIAS_DESC
  )

  object _Fields {
    case object typeAlias extends _Fields(1, "typeAlias")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.typeAlias
  )

  // Record v2
  override type Self = Typeref.type
  override type Trait = Typeref
  override type Mutable = MutableTyperef
  override type Raw = RawTyperef

  override def createRecord: Typeref = createRawRecord
  override def createRawRecord: Typeref.Raw = new Typeref.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Typeref] = {
    if (x.isInstanceOf[Typeref]) Some(x.asInstanceOf[Typeref]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val typeAlias =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Typeref, Typeref.type](
      name = "typeAlias",
      longName = "typeAlias",
      id = 1,
      annotations = Map(),
      owner = Typeref,
      getter = _.typeAliasOption,
      setterRaw = (r: Typeref.Raw, v: String) => { r.typeAlias_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Typeref, Typeref.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Typeref, Typeref.type]](
      typeAlias
    )


  def apply(
      typeAlias: String
  ): Typeref = {
    val ret = Typeref.createRawRecord
    ret.typeAlias_=(typeAlias)
    ret
  }



  object Builder {
    sealed trait HasTypeAlias

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeAlias
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Typeref] (private var obj: Typeref.Raw) {
    def typeAlias(v: String): Typeref.Builder[State with Builder.HasTypeAlias] = {
      obj.typeAlias_=(v)
      this.asInstanceOf[Typeref.Builder[State with Builder.HasTypeAlias]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeAlias): Typeref.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Typeref.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeAlias): Typeref = resultMutable()(ev0)
  }

  def newBuilder: Typeref.Builder.AllUnspecified = new Builder(Typeref.createRawRecord)

  implicit val companionProvider: TyperefCompanionProvider = new TyperefCompanionProvider
}

class TyperefCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Typeref] {
  type CompanionT = Typeref.type
  override def provide: Typeref.type = Typeref
}



trait Typeref

    extends com.foursquare.recordv2.runtime.Record[Typeref]
    with scala.Ordered[Typeref]
    with org.apache.thrift.TBase[Typeref, Typeref._Fields] {

  override type MetaT = Typeref.type


  def typeAlias: String
  def typeAliasOption: Option[String]
  def typeAliasOrNull: String
  def typeAliasOrThrow: String
  def typeAliasIsSet: Boolean
  override def compare(that: Typeref): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.typeAliasIsSet.compareTo(that.typeAliasIsSet)
      cmp != 0 }) cmp
    else if (this.typeAliasIsSet && {
      cmp = this.typeAliasOrNull.compareTo(that.typeAliasOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Typeref

  def copy(
      typeAlias: String = typeAliasOrNull
  ): Typeref

  def mutableCopy(): Typeref.Mutable = {
    val ret = Typeref.createRawRecord

    if (typeAliasIsSet) ret.typeAlias_=(typeAliasOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Typeref.Mutable

  def toBuilder() = {
    val ret = new Typeref.Builder(Typeref.createRawRecord)

    if (typeAliasIsSet) ret.typeAlias(typeAliasOrNull)
    ret
  }

  def mergeCopy(that: Typeref): Typeref

}


trait TyperefProxy extends Typeref {
  protected def underlying: Typeref

  override def meta: Typeref.type = underlying.meta

// field/proxy_ref.ssp

  override def typeAlias: String = underlying.typeAlias
  override def typeAliasOption: Option[String] = underlying.typeAliasOption
  override def typeAliasOrNull: String = underlying.typeAliasOrNull
  override def typeAliasOrThrow: String = underlying.typeAliasOrThrow
  override def typeAliasIsSet: Boolean = underlying.typeAliasIsSet

  override def compare(that: Typeref): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      typeAlias: String = typeAliasOrNull
  ): Typeref = underlying.copy(
    typeAlias = typeAlias
  )

  override def mutableCopy(): Typeref.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Typeref): Typeref = underlying.mergeCopy(that)

  override def mutable: Typeref.Mutable = underlying.mutable

  override def deepCopy(): Typeref = underlying.deepCopy()

  override def fieldForId(id: Int): Typeref._Fields = underlying.fieldForId(id)
  override def isSet(field: Typeref._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Typeref._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Typeref._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableTyperef extends Typeref {
  def typeAlias_=(x: String): Unit
  def typeAliasUnset(): Unit

  def merge(that: Typeref): Unit

  def copy(
      typeAlias: String = typeAliasOrNull
  ): Typeref.Mutable

  override def mutable: Typeref.Mutable = this
}

trait MutableTyperefProxy extends MutableTyperef with TyperefProxy {
  protected def underlying: MutableTyperef

  override def typeAlias_=(x: String): Unit = { underlying.typeAlias_=(x) }
  override def typeAliasUnset(): Unit = { underlying.typeAliasUnset() }

  override def copy(
      typeAlias: String = typeAliasOrNull
  ): Typeref.Mutable = underlying.copy(
    typeAlias = typeAlias
  )

  override def merge(that: Typeref): Unit = underlying.merge(that)
}



final class RawTyperef extends MutableTyperef {
  override def meta: Typeref.type = Typeref

  // Field #1 - typeAlias
  private var _typeAlias: String = null  // Underlying type: String
  override def typeAlias: String = typeAliasOrThrow
  override def typeAlias_=(x: String): Unit = { _typeAlias = x }
  override def typeAliasOption: Option[String] = if (typeAliasIsSet) Some(_typeAlias) else None
  override def typeAliasOrNull: String = _typeAlias
  override def typeAliasOrThrow: String = if (typeAliasIsSet) _typeAlias else throw new java.lang.NullPointerException
  override def typeAliasIsSet: Boolean = _typeAlias != null
  override def typeAliasUnset(): Unit = { _typeAlias = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Typeref.TYPEREF_DESC)
    if (typeAliasIsSet) {
      oprot.writeFieldBegin(Typeref.TYPEALIAS_DESC)
      oprot.writeString(_typeAlias)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Typeref.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // typeAlias

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeAlias = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Typeref".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Typeref): Unit = {
    if (that.typeAliasIsSet && !this.typeAliasIsSet) {
      this.typeAlias_=(that.typeAliasOrNull)
    }
  }

  override def mergeCopy(that: Typeref): Typeref = {
    val ret = Typeref.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Typeref => this.equals(o)
    case _ => false
  }

  def equals(that: Typeref): Boolean = {
    that != null &&
    (if (this.typeAliasIsSet) (that.typeAliasIsSet && this.typeAliasOrNull == that.typeAliasOrNull) else !that.typeAliasIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (typeAliasIsSet) hasher.append(_typeAlias.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (typeAliasIsSet) ret = typeAliasOrNull :: ret
    ret.reverse
  }

  override def clear() {
    typeAliasUnset()
  }

  def fieldForId(id: Int): Typeref._Fields = id match {
    case 1 => Typeref._Fields.typeAlias
    case _ => null
  }

  def isSet(field: Typeref._Fields): Boolean = field match {
    case Typeref._Fields.typeAlias => typeAliasIsSet
    case _ => false
  }

  def getFieldValue(field: Typeref._Fields): AnyRef = field match {
    case Typeref._Fields.typeAlias => typeAliasOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Typeref._Fields, value: AnyRef) {
    field match {
      case Typeref._Fields.typeAlias => typeAlias_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): Typeref.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Typeref.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      typeAlias: String = typeAliasOrNull
  ): Typeref.Raw = {
    val ret = new Typeref.Raw
    if (typeAlias != null) ret.typeAlias_=(typeAlias)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Type
    extends com.foursquare.recordv2.runtime.MetaRecord[Type]
    with com.foursquare.recordv2.runtime.RecordProvider[Type] {
  override def recordName: String = "Type"


  // Thrift descriptors.
  val TYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Type")

  val ID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "id",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val SIMPLETYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "simpleType",
      org.apache.thrift.protocol.TType.STRUCT,
      2,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "id" -> ID_DESC,
    "simpleType" -> SIMPLETYPE_DESC
  )

  object _Fields {
    case object id extends _Fields(1, "id")
    case object simpleType extends _Fields(2, "simpleType")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.id,
    2.toShort -> _Fields.simpleType
  )

  // Record v2
  override type Self = Type.type
  override type Trait = Type
  override type Mutable = MutableType
  override type Raw = RawType

  override def createRecord: Type = createRawRecord
  override def createRawRecord: Type.Raw = new Type.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Type] = {
    if (x.isInstanceOf[Type]) Some(x.asInstanceOf[Type]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val id =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Type, Type.type](
      name = "id",
      longName = "id",
      id = 1,
      annotations = Map(),
      owner = Type,
      getter = _.idOption,
      setterRaw = (r: Type.Raw, v: String) => { r.id_=(v) },
      manifest = manifest[String]
    )

  val simpleType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.SimpleType, Type, Type.type](
      name = "simpleType",
      longName = "simpleType",
      id = 2,
      annotations = Map(),
      owner = Type,
      getter = _.simpleTypeOption,
      setterRaw = (r: Type.Raw, v: com.twitter.thrift.descriptors.SimpleType) => { r.simpleType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.SimpleType]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Type, Type.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Type, Type.type]](
      id,
      simpleType
    )


  def apply(
      id: String,
      simpleType: com.twitter.thrift.descriptors.SimpleType
  ): Type = {
    val ret = Type.createRawRecord
    ret.id_=(id)
    ret.simpleType_=(simpleType)
    ret
  }



  object Builder {
    sealed trait HasId
    sealed trait HasSimpleType

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasId with HasSimpleType
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Type] (private var obj: Type.Raw) {
    def id(v: String): Type.Builder[State with Builder.HasId] = {
      obj.id_=(v)
      this.asInstanceOf[Type.Builder[State with Builder.HasId]]
    }
    def simpleType(v: com.twitter.thrift.descriptors.SimpleType): Type.Builder[State with Builder.HasSimpleType] = {
      obj.simpleType_=(v)
      this.asInstanceOf[Type.Builder[State with Builder.HasSimpleType]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasId, ev1: State <:< Builder.HasSimpleType): Type.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Type.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasId, ev1: State <:< Builder.HasSimpleType): Type = resultMutable()(ev0, ev1)
  }

  def newBuilder: Type.Builder.AllUnspecified = new Builder(Type.createRawRecord)

  implicit val companionProvider: TypeCompanionProvider = new TypeCompanionProvider
}

class TypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Type] {
  type CompanionT = Type.type
  override def provide: Type.type = Type
}



trait Type

    extends com.foursquare.recordv2.runtime.Record[Type]
    with scala.Ordered[Type]
    with org.apache.thrift.TBase[Type, Type._Fields] {

  override type MetaT = Type.type


  def id: String
  def idOption: Option[String]
  def idOrNull: String
  def idOrThrow: String
  def idIsSet: Boolean

  def simpleType: com.twitter.thrift.descriptors.SimpleType
  def simpleTypeOption: Option[com.twitter.thrift.descriptors.SimpleType]
  def simpleTypeOrNull: com.twitter.thrift.descriptors.SimpleType
  def simpleTypeOrThrow: com.twitter.thrift.descriptors.SimpleType
  def simpleTypeIsSet: Boolean
  override def compare(that: Type): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.idIsSet.compareTo(that.idIsSet)
      cmp != 0 }) cmp
    else if (this.idIsSet && {
      cmp = this.idOrNull.compareTo(that.idOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.simpleTypeIsSet.compareTo(that.simpleTypeIsSet)
      cmp != 0 }) cmp
    else if (this.simpleTypeIsSet && {
      cmp = this.simpleTypeOrNull.compareTo(that.simpleTypeOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Type

  def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): Type

  def mutableCopy(): Type.Mutable = {
    val ret = Type.createRawRecord

    if (idIsSet) ret.id_=(idOrNull)

    if (simpleTypeIsSet) ret.simpleType_=(simpleTypeOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Type.Mutable

  def toBuilder() = {
    val ret = new Type.Builder(Type.createRawRecord)

    if (idIsSet) ret.id(idOrNull)

    if (simpleTypeIsSet) ret.simpleType(simpleTypeOrNull)
    ret
  }

  def mergeCopy(that: Type): Type

}


trait TypeProxy extends Type {
  protected def underlying: Type

  override def meta: Type.type = underlying.meta

// field/proxy_ref.ssp

  override def id: String = underlying.id
  override def idOption: Option[String] = underlying.idOption
  override def idOrNull: String = underlying.idOrNull
  override def idOrThrow: String = underlying.idOrThrow
  override def idIsSet: Boolean = underlying.idIsSet
// field/proxy_ref.ssp

  override def simpleType: com.twitter.thrift.descriptors.SimpleType = underlying.simpleType
  override def simpleTypeOption: Option[com.twitter.thrift.descriptors.SimpleType] = underlying.simpleTypeOption
  override def simpleTypeOrNull: com.twitter.thrift.descriptors.SimpleType = underlying.simpleTypeOrNull
  override def simpleTypeOrThrow: com.twitter.thrift.descriptors.SimpleType = underlying.simpleTypeOrThrow
  override def simpleTypeIsSet: Boolean = underlying.simpleTypeIsSet

  override def compare(that: Type): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): Type = underlying.copy(
    id = id,
    simpleType = simpleType
  )

  override def mutableCopy(): Type.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Type): Type = underlying.mergeCopy(that)

  override def mutable: Type.Mutable = underlying.mutable

  override def deepCopy(): Type = underlying.deepCopy()

  override def fieldForId(id: Int): Type._Fields = underlying.fieldForId(id)
  override def isSet(field: Type._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Type._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Type._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableType extends Type {
  def id_=(x: String): Unit
  def idUnset(): Unit
  def simpleType_=(x: com.twitter.thrift.descriptors.SimpleType): Unit
  def simpleTypeUnset(): Unit

  def merge(that: Type): Unit

  def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): Type.Mutable

  override def mutable: Type.Mutable = this
}

trait MutableTypeProxy extends MutableType with TypeProxy {
  protected def underlying: MutableType

  override def id_=(x: String): Unit = { underlying.id_=(x) }
  override def idUnset(): Unit = { underlying.idUnset() }
  override def simpleType_=(x: com.twitter.thrift.descriptors.SimpleType): Unit = { underlying.simpleType_=(x) }
  override def simpleTypeUnset(): Unit = { underlying.simpleTypeUnset() }

  override def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): Type.Mutable = underlying.copy(
    id = id,
    simpleType = simpleType
  )

  override def merge(that: Type): Unit = underlying.merge(that)
}



final class RawType extends MutableType {
  override def meta: Type.type = Type

  // Field #1 - id
  private var _id: String = null  // Underlying type: String
  override def id: String = idOrThrow
  override def id_=(x: String): Unit = { _id = x }
  override def idOption: Option[String] = if (idIsSet) Some(_id) else None
  override def idOrNull: String = _id
  override def idOrThrow: String = if (idIsSet) _id else throw new java.lang.NullPointerException
  override def idIsSet: Boolean = _id != null
  override def idUnset(): Unit = { _id = null }
  // Field #2 - simpleType
  private var _simpleType: com.twitter.thrift.descriptors.SimpleType = null  // Underlying type: com.twitter.thrift.descriptors.SimpleType
  override def simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrThrow
  override def simpleType_=(x: com.twitter.thrift.descriptors.SimpleType): Unit = { _simpleType = x }
  override def simpleTypeOption: Option[com.twitter.thrift.descriptors.SimpleType] = if (simpleTypeIsSet) Some(_simpleType) else None
  override def simpleTypeOrNull: com.twitter.thrift.descriptors.SimpleType = _simpleType
  override def simpleTypeOrThrow: com.twitter.thrift.descriptors.SimpleType = if (simpleTypeIsSet) _simpleType else throw new java.lang.NullPointerException
  override def simpleTypeIsSet: Boolean = _simpleType != null
  override def simpleTypeUnset(): Unit = { _simpleType = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Type.TYPE_DESC)
    if (idIsSet) {
      oprot.writeFieldBegin(Type.ID_DESC)
      oprot.writeString(_id)
      oprot.writeFieldEnd()
    }
    if (simpleTypeIsSet) {
      oprot.writeFieldBegin(Type.SIMPLETYPE_DESC)
      _simpleType.write(oprot)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Type.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // id

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _id = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // simpleType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _simpleType = ({
                val s = com.twitter.thrift.descriptors.SimpleType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Type".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Type): Unit = {
    if (that.idIsSet && !this.idIsSet) {
      this.id_=(that.idOrNull)
    }
    if (that.simpleTypeIsSet && !this.simpleTypeIsSet) {
      this.simpleType_=(that.simpleTypeOrNull)
    }
  }

  override def mergeCopy(that: Type): Type = {
    val ret = Type.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Type => this.equals(o)
    case _ => false
  }

  def equals(that: Type): Boolean = {
    that != null &&
    (if (this.idIsSet) (that.idIsSet && this.idOrNull == that.idOrNull) else !that.idIsSet) &&
    (if (this.simpleTypeIsSet) (that.simpleTypeIsSet && this.simpleTypeOrNull == that.simpleTypeOrNull) else !that.simpleTypeIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (idIsSet) hasher.append(_id.##)
    if (simpleTypeIsSet) hasher.append(_simpleType.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (idIsSet) ret = idOrNull :: ret
    if (simpleTypeIsSet) ret = simpleTypeOrNull :: ret
    ret.reverse
  }

  override def clear() {
    idUnset()
    simpleTypeUnset()
  }

  def fieldForId(id: Int): Type._Fields = id match {
    case 1 => Type._Fields.id
    case 2 => Type._Fields.simpleType
    case _ => null
  }

  def isSet(field: Type._Fields): Boolean = field match {
    case Type._Fields.id => idIsSet
    case Type._Fields.simpleType => simpleTypeIsSet
    case _ => false
  }

  def getFieldValue(field: Type._Fields): AnyRef = field match {
    case Type._Fields.id => idOrNull.asInstanceOf[AnyRef]
    case Type._Fields.simpleType => simpleTypeOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Type._Fields, value: AnyRef) {
    field match {
      case Type._Fields.id => id_=(value.asInstanceOf[String])
      case Type._Fields.simpleType => simpleType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SimpleType])
      case _ =>
    }
  }

  override def deepCopy(): Type.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Type.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): Type.Raw = {
    val ret = new Type.Raw
    if (id != null) ret.id_=(id)
    if (simpleType != null) ret.simpleType_=(simpleType)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Typedef
    extends com.foursquare.recordv2.runtime.MetaRecord[Typedef]
    with com.foursquare.recordv2.runtime.RecordProvider[Typedef] {
  override def recordName: String = "Typedef"


  // Thrift descriptors.
  val TYPEDEF_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Typedef")

  val TYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val TYPEALIAS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeAlias",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "typeId" -> TYPEID_DESC,
    "typeAlias" -> TYPEALIAS_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object typeId extends _Fields(1, "typeId")
    case object typeAlias extends _Fields(2, "typeAlias")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.typeId,
    2.toShort -> _Fields.typeAlias,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Typedef.type
  override type Trait = Typedef
  override type Mutable = MutableTypedef
  override type Raw = RawTypedef

  override def createRecord: Typedef = createRawRecord
  override def createRawRecord: Typedef.Raw = new Typedef.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Typedef] = {
    if (x.isInstanceOf[Typedef]) Some(x.asInstanceOf[Typedef]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val typeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Typedef, Typedef.type](
      name = "typeId",
      longName = "typeId",
      id = 1,
      annotations = Map(),
      owner = Typedef,
      getter = _.typeIdOption,
      setterRaw = (r: Typedef.Raw, v: String) => { r.typeId_=(v) },
      manifest = manifest[String]
    )

  val typeAlias =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Typedef, Typedef.type](
      name = "typeAlias",
      longName = "typeAlias",
      id = 2,
      annotations = Map(),
      owner = Typedef,
      getter = _.typeAliasOption,
      setterRaw = (r: Typedef.Raw, v: String) => { r.typeAlias_=(v) },
      manifest = manifest[String]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Typedef, Typedef.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Typedef,
      getter = _.annotationsOption,
      setterRaw = (r: Typedef.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Typedef, Typedef.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Typedef, Typedef.type]](
      typeId,
      typeAlias,
      __annotations
    )


  def apply(
      typeId: String,
      typeAlias: String,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Typedef = {
    val ret = Typedef.createRawRecord
    ret.typeId_=(typeId)
    ret.typeAlias_=(typeAlias)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasTypeId
    sealed trait HasTypeAlias

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeId with HasTypeAlias
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Typedef] (private var obj: Typedef.Raw) {
    def typeId(v: String): Typedef.Builder[State with Builder.HasTypeId] = {
      obj.typeId_=(v)
      this.asInstanceOf[Typedef.Builder[State with Builder.HasTypeId]]
    }
    def typeAlias(v: String): Typedef.Builder[State with Builder.HasTypeAlias] = {
      obj.typeAlias_=(v)
      this.asInstanceOf[Typedef.Builder[State with Builder.HasTypeAlias]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Typedef.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Typedef.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasTypeAlias): Typedef.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Typedef.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasTypeAlias): Typedef = resultMutable()(ev0, ev1)
  }

  def newBuilder: Typedef.Builder.AllUnspecified = new Builder(Typedef.createRawRecord)

  implicit val companionProvider: TypedefCompanionProvider = new TypedefCompanionProvider
}

class TypedefCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Typedef] {
  type CompanionT = Typedef.type
  override def provide: Typedef.type = Typedef
}



trait Typedef

    extends com.foursquare.recordv2.runtime.Record[Typedef]
    with scala.Ordered[Typedef]
    with org.apache.thrift.TBase[Typedef, Typedef._Fields] {

  override type MetaT = Typedef.type


  def typeId: String
  def typeIdOption: Option[String]
  def typeIdOrNull: String
  def typeIdOrThrow: String
  def typeIdIsSet: Boolean

  def typeAlias: String
  def typeAliasOption: Option[String]
  def typeAliasOrNull: String
  def typeAliasOrThrow: String
  def typeAliasIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Typedef): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.typeIdIsSet.compareTo(that.typeIdIsSet)
      cmp != 0 }) cmp
    else if (this.typeIdIsSet && {
      cmp = this.typeIdOrNull.compareTo(that.typeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typeAliasIsSet.compareTo(that.typeAliasIsSet)
      cmp != 0 }) cmp
    else if (this.typeAliasIsSet && {
      cmp = this.typeAliasOrNull.compareTo(that.typeAliasOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Typedef

  def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef

  def mutableCopy(): Typedef.Mutable = {
    val ret = Typedef.createRawRecord

    if (typeIdIsSet) ret.typeId_=(typeIdOrNull)

    if (typeAliasIsSet) ret.typeAlias_=(typeAliasOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Typedef.Mutable

  def toBuilder() = {
    val ret = new Typedef.Builder(Typedef.createRawRecord)

    if (typeIdIsSet) ret.typeId(typeIdOrNull)

    if (typeAliasIsSet) ret.typeAlias(typeAliasOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Typedef): Typedef

}


trait TypedefProxy extends Typedef {
  protected def underlying: Typedef

  override def meta: Typedef.type = underlying.meta

// field/proxy_ref.ssp

  override def typeId: String = underlying.typeId
  override def typeIdOption: Option[String] = underlying.typeIdOption
  override def typeIdOrNull: String = underlying.typeIdOrNull
  override def typeIdOrThrow: String = underlying.typeIdOrThrow
  override def typeIdIsSet: Boolean = underlying.typeIdIsSet
// field/proxy_ref.ssp

  override def typeAlias: String = underlying.typeAlias
  override def typeAliasOption: Option[String] = underlying.typeAliasOption
  override def typeAliasOrNull: String = underlying.typeAliasOrNull
  override def typeAliasOrThrow: String = underlying.typeAliasOrThrow
  override def typeAliasIsSet: Boolean = underlying.typeAliasIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Typedef): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef = underlying.copy(
    typeId = typeId,
    typeAlias = typeAlias,
    __annotations = __annotations
  )

  override def mutableCopy(): Typedef.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Typedef): Typedef = underlying.mergeCopy(that)

  override def mutable: Typedef.Mutable = underlying.mutable

  override def deepCopy(): Typedef = underlying.deepCopy()

  override def fieldForId(id: Int): Typedef._Fields = underlying.fieldForId(id)
  override def isSet(field: Typedef._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Typedef._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Typedef._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableTypedef extends Typedef {
  def typeId_=(x: String): Unit
  def typeIdUnset(): Unit
  def typeAlias_=(x: String): Unit
  def typeAliasUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Typedef): Unit

  def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef.Mutable

  override def mutable: Typedef.Mutable = this
}

trait MutableTypedefProxy extends MutableTypedef with TypedefProxy {
  protected def underlying: MutableTypedef

  override def typeId_=(x: String): Unit = { underlying.typeId_=(x) }
  override def typeIdUnset(): Unit = { underlying.typeIdUnset() }
  override def typeAlias_=(x: String): Unit = { underlying.typeAlias_=(x) }
  override def typeAliasUnset(): Unit = { underlying.typeAliasUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef.Mutable = underlying.copy(
    typeId = typeId,
    typeAlias = typeAlias,
    __annotations = __annotations
  )

  override def merge(that: Typedef): Unit = underlying.merge(that)
}



final class RawTypedef extends MutableTypedef {
  override def meta: Typedef.type = Typedef

  // Field #1 - typeId
  private var _typeId: String = null  // Underlying type: String
  override def typeId: String = typeIdOrThrow
  override def typeId_=(x: String): Unit = { _typeId = x }
  override def typeIdOption: Option[String] = if (typeIdIsSet) Some(_typeId) else None
  override def typeIdOrNull: String = _typeId
  override def typeIdOrThrow: String = if (typeIdIsSet) _typeId else throw new java.lang.NullPointerException
  override def typeIdIsSet: Boolean = _typeId != null
  override def typeIdUnset(): Unit = { _typeId = null }
  // Field #2 - typeAlias
  private var _typeAlias: String = null  // Underlying type: String
  override def typeAlias: String = typeAliasOrThrow
  override def typeAlias_=(x: String): Unit = { _typeAlias = x }
  override def typeAliasOption: Option[String] = if (typeAliasIsSet) Some(_typeAlias) else None
  override def typeAliasOrNull: String = _typeAlias
  override def typeAliasOrThrow: String = if (typeAliasIsSet) _typeAlias else throw new java.lang.NullPointerException
  override def typeAliasIsSet: Boolean = _typeAlias != null
  override def typeAliasUnset(): Unit = { _typeAlias = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Typedef.TYPEDEF_DESC)
    if (typeIdIsSet) {
      oprot.writeFieldBegin(Typedef.TYPEID_DESC)
      oprot.writeString(_typeId)
      oprot.writeFieldEnd()
    }
    if (typeAliasIsSet) {
      oprot.writeFieldBegin(Typedef.TYPEALIAS_DESC)
      oprot.writeString(_typeAlias)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Typedef.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Typedef.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // typeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // typeAlias

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeAlias = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Typedef".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Typedef): Unit = {
    if (that.typeIdIsSet && !this.typeIdIsSet) {
      this.typeId_=(that.typeIdOrNull)
    }
    if (that.typeAliasIsSet && !this.typeAliasIsSet) {
      this.typeAlias_=(that.typeAliasOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Typedef): Typedef = {
    val ret = Typedef.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Typedef => this.equals(o)
    case _ => false
  }

  def equals(that: Typedef): Boolean = {
    that != null &&
    (if (this.typeIdIsSet) (that.typeIdIsSet && this.typeIdOrNull == that.typeIdOrNull) else !that.typeIdIsSet) &&
    (if (this.typeAliasIsSet) (that.typeAliasIsSet && this.typeAliasOrNull == that.typeAliasOrNull) else !that.typeAliasIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (typeIdIsSet) hasher.append(_typeId.##)
    if (typeAliasIsSet) hasher.append(_typeAlias.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (typeIdIsSet) ret = typeIdOrNull :: ret
    if (typeAliasIsSet) ret = typeAliasOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    typeIdUnset()
    typeAliasUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Typedef._Fields = id match {
    case 1 => Typedef._Fields.typeId
    case 2 => Typedef._Fields.typeAlias
    case 99 => Typedef._Fields.__annotations
    case _ => null
  }

  def isSet(field: Typedef._Fields): Boolean = field match {
    case Typedef._Fields.typeId => typeIdIsSet
    case Typedef._Fields.typeAlias => typeAliasIsSet
    case Typedef._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Typedef._Fields): AnyRef = field match {
    case Typedef._Fields.typeId => typeIdOrNull.asInstanceOf[AnyRef]
    case Typedef._Fields.typeAlias => typeAliasOrNull.asInstanceOf[AnyRef]
    case Typedef._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Typedef._Fields, value: AnyRef) {
    field match {
      case Typedef._Fields.typeId => typeId_=(value.asInstanceOf[String])
      case Typedef._Fields.typeAlias => typeAlias_=(value.asInstanceOf[String])
      case Typedef._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Typedef.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Typedef.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef.Raw = {
    val ret = new Typedef.Raw
    if (typeId != null) ret.typeId_=(typeId)
    if (typeAlias != null) ret.typeAlias_=(typeAlias)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object TypeRegistry
    extends com.foursquare.recordv2.runtime.MetaRecord[TypeRegistry]
    with com.foursquare.recordv2.runtime.RecordProvider[TypeRegistry] {
  override def recordName: String = "TypeRegistry"


  // Thrift descriptors.
  val TYPEREGISTRY_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("TypeRegistry")

  val IDTOTYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "idToType",
      org.apache.thrift.protocol.TType.MAP,
      1,
      Map[String, String]().asJava
    )
  val ALIASTOTYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "aliasToTypeId",
      org.apache.thrift.protocol.TType.MAP,
      2,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "idToType" -> IDTOTYPE_DESC,
    "aliasToTypeId" -> ALIASTOTYPEID_DESC
  )

  object _Fields {
    case object idToType extends _Fields(1, "idToType")
    case object aliasToTypeId extends _Fields(2, "aliasToTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.idToType,
    2.toShort -> _Fields.aliasToTypeId
  )

  // Record v2
  override type Self = TypeRegistry.type
  override type Trait = TypeRegistry
  override type Mutable = MutableTypeRegistry
  override type Raw = RawTypeRegistry

  override def createRecord: TypeRegistry = createRawRecord
  override def createRawRecord: TypeRegistry.Raw = new TypeRegistry.Raw

  override def ifInstanceFrom(x: AnyRef): Option[TypeRegistry] = {
    if (x.isInstanceOf[TypeRegistry]) Some(x.asInstanceOf[TypeRegistry]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val idToType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type], TypeRegistry, TypeRegistry.type](
      name = "idToType",
      longName = "idToType",
      id = 1,
      annotations = Map(),
      owner = TypeRegistry,
      getter = _.idToTypeOption,
      setterRaw = (r: TypeRegistry.Raw, v: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]) => { r.idToType_=(v) },
      manifest = manifest[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]]
    )

  val aliasToTypeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.immutable.Map[String, String], TypeRegistry, TypeRegistry.type](
      name = "aliasToTypeId",
      longName = "aliasToTypeId",
      id = 2,
      annotations = Map(),
      owner = TypeRegistry,
      getter = _.aliasToTypeIdOption,
      setterRaw = (r: TypeRegistry.Raw, v: scala.collection.immutable.Map[String, String]) => { r.aliasToTypeId_=(v) },
      manifest = manifest[scala.collection.immutable.Map[String, String]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, TypeRegistry, TypeRegistry.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, TypeRegistry, TypeRegistry.type]](
      idToType,
      aliasToTypeId
    )


  def apply(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type],
      aliasToTypeId: scala.collection.immutable.Map[String, String]
  ): TypeRegistry = {
    val ret = TypeRegistry.createRawRecord
    ret.idToType_=(idToType)
    ret.aliasToTypeId_=(aliasToTypeId)
    ret
  }



  object Builder {
    sealed trait HasIdToType
    sealed trait HasAliasToTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasIdToType with HasAliasToTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[TypeRegistry] (private var obj: TypeRegistry.Raw) {
    def idToType(v: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): TypeRegistry.Builder[State with Builder.HasIdToType] = {
      obj.idToType_=(v)
      this.asInstanceOf[TypeRegistry.Builder[State with Builder.HasIdToType]]
    }
    def aliasToTypeId(v: scala.collection.immutable.Map[String, String]): TypeRegistry.Builder[State with Builder.HasAliasToTypeId] = {
      obj.aliasToTypeId_=(v)
      this.asInstanceOf[TypeRegistry.Builder[State with Builder.HasAliasToTypeId]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasIdToType, ev1: State <:< Builder.HasAliasToTypeId): TypeRegistry.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("TypeRegistry.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasIdToType, ev1: State <:< Builder.HasAliasToTypeId): TypeRegistry = resultMutable()(ev0, ev1)
  }

  def newBuilder: TypeRegistry.Builder.AllUnspecified = new Builder(TypeRegistry.createRawRecord)

  implicit val companionProvider: TypeRegistryCompanionProvider = new TypeRegistryCompanionProvider
}

class TypeRegistryCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[TypeRegistry] {
  type CompanionT = TypeRegistry.type
  override def provide: TypeRegistry.type = TypeRegistry
}



trait TypeRegistry

    extends com.foursquare.recordv2.runtime.Record[TypeRegistry]
    with scala.Ordered[TypeRegistry]
    with org.apache.thrift.TBase[TypeRegistry, TypeRegistry._Fields] {

  override type MetaT = TypeRegistry.type

  def idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]
  def idToTypeOption: Option[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]]
  def idToTypeOrDefault: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]
  def idToTypeOrNull: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]
  def idToTypeOrThrow: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]
  def idToTypeIsSet: Boolean
  def aliasToTypeId: scala.collection.immutable.Map[String, String]
  def aliasToTypeIdOption: Option[scala.collection.immutable.Map[String, String]]
  def aliasToTypeIdOrDefault: scala.collection.immutable.Map[String, String]
  def aliasToTypeIdOrNull: scala.collection.immutable.Map[String, String]
  def aliasToTypeIdOrThrow: scala.collection.immutable.Map[String, String]
  def aliasToTypeIdIsSet: Boolean
  override def compare(that: TypeRegistry): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.idToTypeIsSet.compareTo(that.idToTypeIsSet)
      cmp != 0 }) cmp
    else if (this.idToTypeIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.idToType.asJava, that.idToType.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.aliasToTypeIdIsSet.compareTo(that.aliasToTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.aliasToTypeIdIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.aliasToTypeId.asJava, that.aliasToTypeId.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): TypeRegistry

  def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): TypeRegistry

  def mutableCopy(): TypeRegistry.Mutable = {
    val ret = TypeRegistry.createRawRecord

    if (idToTypeIsSet) ret.idToType_=(idToTypeOrNull)

    if (aliasToTypeIdIsSet) ret.aliasToTypeId_=(aliasToTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: TypeRegistry.Mutable

  def toBuilder() = {
    val ret = new TypeRegistry.Builder(TypeRegistry.createRawRecord)

    if (idToTypeIsSet) ret.idToType(idToTypeOrNull)

    if (aliasToTypeIdIsSet) ret.aliasToTypeId(aliasToTypeIdOrNull)
    ret
  }

  def mergeCopy(that: TypeRegistry): TypeRegistry

}


trait TypeRegistryProxy extends TypeRegistry {
  protected def underlying: TypeRegistry

  override def meta: TypeRegistry.type = underlying.meta

// field/proxy_container.ssp
  override def idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = underlying.idToType
  override def idToTypeOption: Option[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]] = underlying.idToTypeOption
  override def idToTypeOrDefault: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = underlying.idToTypeOrDefault
  override def idToTypeOrNull: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = underlying.idToTypeOrNull
  override def idToTypeOrThrow: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = underlying.idToTypeOrThrow
  override def idToTypeIsSet: Boolean = underlying.idToTypeIsSet
// field/proxy_container.ssp
  override def aliasToTypeId: scala.collection.immutable.Map[String, String] = underlying.aliasToTypeId
  override def aliasToTypeIdOption: Option[scala.collection.immutable.Map[String, String]] = underlying.aliasToTypeIdOption
  override def aliasToTypeIdOrDefault: scala.collection.immutable.Map[String, String] = underlying.aliasToTypeIdOrDefault
  override def aliasToTypeIdOrNull: scala.collection.immutable.Map[String, String] = underlying.aliasToTypeIdOrNull
  override def aliasToTypeIdOrThrow: scala.collection.immutable.Map[String, String] = underlying.aliasToTypeIdOrThrow
  override def aliasToTypeIdIsSet: Boolean = underlying.aliasToTypeIdIsSet

  override def compare(that: TypeRegistry): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): TypeRegistry = underlying.copy(
    idToType = idToType,
    aliasToTypeId = aliasToTypeId
  )

  override def mutableCopy(): TypeRegistry.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: TypeRegistry): TypeRegistry = underlying.mergeCopy(that)

  override def mutable: TypeRegistry.Mutable = underlying.mutable

  override def deepCopy(): TypeRegistry = underlying.deepCopy()

  override def fieldForId(id: Int): TypeRegistry._Fields = underlying.fieldForId(id)
  override def isSet(field: TypeRegistry._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: TypeRegistry._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: TypeRegistry._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableTypeRegistry extends TypeRegistry {
  def idToType_=(x: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): Unit
  def idToTypeUnset(): Unit
  def aliasToTypeId_=(x: scala.collection.immutable.Map[String, String]): Unit
  def aliasToTypeIdUnset(): Unit

  def merge(that: TypeRegistry): Unit

  def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): TypeRegistry.Mutable

  override def mutable: TypeRegistry.Mutable = this
}

trait MutableTypeRegistryProxy extends MutableTypeRegistry with TypeRegistryProxy {
  protected def underlying: MutableTypeRegistry

  override def idToType_=(x: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): Unit = { underlying.idToType_=(x) }
  override def idToTypeUnset(): Unit = { underlying.idToTypeUnset() }
  override def aliasToTypeId_=(x: scala.collection.immutable.Map[String, String]): Unit = { underlying.aliasToTypeId_=(x) }
  override def aliasToTypeIdUnset(): Unit = { underlying.aliasToTypeIdUnset() }

  override def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): TypeRegistry.Mutable = underlying.copy(
    idToType = idToType,
    aliasToTypeId = aliasToTypeId
  )

  override def merge(that: TypeRegistry): Unit = underlying.merge(that)
}



final class RawTypeRegistry extends MutableTypeRegistry {
  override def meta: TypeRegistry.type = TypeRegistry

  // Field #1 - idToType
  private var _idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = null  // Underlying type: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]
  override def idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrDefault
  override def idToType_=(x: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): Unit = { _idToType = x }
  override def idToTypeOption: Option[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]] = if (idToTypeIsSet) Some(_idToType) else None
  override def idToTypeOrDefault: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = if (idToTypeIsSet) _idToType else scala.collection.immutable.Map.empty
  override def idToTypeOrNull: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = _idToType
  override def idToTypeOrThrow: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = if (idToTypeIsSet) _idToType else throw new java.lang.NullPointerException
  override def idToTypeIsSet: Boolean = _idToType != null
  override def idToTypeUnset(): Unit = { _idToType = null }
  // Field #2 - aliasToTypeId
  private var _aliasToTypeId: scala.collection.immutable.Map[String, String] = null  // Underlying type: scala.collection.immutable.Map[String, String]
  override def aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrDefault
  override def aliasToTypeId_=(x: scala.collection.immutable.Map[String, String]): Unit = { _aliasToTypeId = x }
  override def aliasToTypeIdOption: Option[scala.collection.immutable.Map[String, String]] = if (aliasToTypeIdIsSet) Some(_aliasToTypeId) else None
  override def aliasToTypeIdOrDefault: scala.collection.immutable.Map[String, String] = if (aliasToTypeIdIsSet) _aliasToTypeId else scala.collection.immutable.Map.empty
  override def aliasToTypeIdOrNull: scala.collection.immutable.Map[String, String] = _aliasToTypeId
  override def aliasToTypeIdOrThrow: scala.collection.immutable.Map[String, String] = if (aliasToTypeIdIsSet) _aliasToTypeId else throw new java.lang.NullPointerException
  override def aliasToTypeIdIsSet: Boolean = _aliasToTypeId != null
  override def aliasToTypeIdUnset(): Unit = { _aliasToTypeId = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(TypeRegistry.TYPEREGISTRY_DESC)
    if (idToTypeIsSet) {
      oprot.writeFieldBegin(TypeRegistry.IDTOTYPE_DESC)
      oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRUCT, _idToType.size))
      _idToType.foreach(item => {
        oprot.writeString(item._1)
        item._2.write(oprot)
      })
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    }
    if (aliasToTypeIdIsSet) {
      oprot.writeFieldBegin(TypeRegistry.ALIASTOTYPEID_DESC)
      oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, _aliasToTypeId.size))
      _aliasToTypeId.foreach(item => {
        oprot.writeString(item._1)
        oprot.writeString(item._2)
      })
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        TypeRegistry.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // idToType

            if (field_header.`type` == org.apache.thrift.protocol.TType.MAP) {
              _idToType = {
                val tmap: org.apache.thrift.protocol.TMap = iprot.readMapBegin()
                val builder = scala.collection.immutable.Map.newBuilder[String, com.twitter.thrift.descriptors.Type]
                builder.sizeHint(tmap.size)
                var i: Int = tmap.size
                while (i > 0) {
                  val k = iprot.readString()
                  val v = ({
                    val s = com.twitter.thrift.descriptors.Type.createRawRecord
                    s.read(iprot)
                    s
                  })
                  builder += ((k, v))
                  i -= 1
                }
                builder.result()
              }
              iprot.readMapEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // aliasToTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.MAP) {
              _aliasToTypeId = {
                val tmap: org.apache.thrift.protocol.TMap = iprot.readMapBegin()
                val builder = scala.collection.immutable.Map.newBuilder[String, String]
                builder.sizeHint(tmap.size)
                var i: Int = tmap.size
                while (i > 0) {
                  val k = iprot.readString()
                  val v = iprot.readString()
                  builder += ((k, v))
                  i -= 1
                }
                builder.result()
              }
              iprot.readMapEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure TypeRegistry".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: TypeRegistry): Unit = {
    if (that.idToTypeIsSet && !this.idToTypeIsSet) {
      this.idToType_=(that.idToTypeOrNull)

    } else if (that.idToTypeIsSet && this.idToTypeIsSet) {
      this.idToType ++= that.idToType
    }
    if (that.aliasToTypeIdIsSet && !this.aliasToTypeIdIsSet) {
      this.aliasToTypeId_=(that.aliasToTypeIdOrNull)

    } else if (that.aliasToTypeIdIsSet && this.aliasToTypeIdIsSet) {
      this.aliasToTypeId ++= that.aliasToTypeId
    }
  }

  override def mergeCopy(that: TypeRegistry): TypeRegistry = {
    val ret = TypeRegistry.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: TypeRegistry => this.equals(o)
    case _ => false
  }

  def equals(that: TypeRegistry): Boolean = {
    that != null &&
    (if (this.idToTypeIsSet) (that.idToTypeIsSet && this.idToTypeOrNull == that.idToTypeOrNull) else !that.idToTypeIsSet) &&
    (if (this.aliasToTypeIdIsSet) (that.aliasToTypeIdIsSet && this.aliasToTypeIdOrNull == that.aliasToTypeIdOrNull) else !that.aliasToTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (idToTypeIsSet) hasher.append(_idToType.##)
    if (aliasToTypeIdIsSet) hasher.append(_aliasToTypeId.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (idToTypeIsSet) ret = idToTypeOrNull :: ret
    if (aliasToTypeIdIsSet) ret = aliasToTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    idToTypeUnset()
    aliasToTypeIdUnset()
  }

  def fieldForId(id: Int): TypeRegistry._Fields = id match {
    case 1 => TypeRegistry._Fields.idToType
    case 2 => TypeRegistry._Fields.aliasToTypeId
    case _ => null
  }

  def isSet(field: TypeRegistry._Fields): Boolean = field match {
    case TypeRegistry._Fields.idToType => idToTypeIsSet
    case TypeRegistry._Fields.aliasToTypeId => aliasToTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: TypeRegistry._Fields): AnyRef = field match {
    case TypeRegistry._Fields.idToType => idToTypeOrNull.asInstanceOf[AnyRef]
    case TypeRegistry._Fields.aliasToTypeId => aliasToTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: TypeRegistry._Fields, value: AnyRef) {
    field match {
      case TypeRegistry._Fields.idToType => idToType_=(value.asInstanceOf[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]])
      case TypeRegistry._Fields.aliasToTypeId => aliasToTypeId_=(value.asInstanceOf[scala.collection.immutable.Map[String, String]])
      case _ =>
    }
  }

  override def deepCopy(): TypeRegistry.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = TypeRegistry.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): TypeRegistry.Raw = {
    val ret = new TypeRegistry.Raw
    if (idToType != null) ret.idToType_=(idToType)
    if (aliasToTypeId != null) ret.aliasToTypeId_=(aliasToTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Const
    extends com.foursquare.recordv2.runtime.MetaRecord[Const]
    with com.foursquare.recordv2.runtime.RecordProvider[Const] {
  override def recordName: String = "Const"


  // Thrift descriptors.
  val CONST_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Const")

  val TYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )
  val VALUE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "value",
      org.apache.thrift.protocol.TType.STRING,
      3,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "typeId" -> TYPEID_DESC,
    "name" -> NAME_DESC,
    "value" -> VALUE_DESC
  )

  object _Fields {
    case object typeId extends _Fields(1, "typeId")
    case object name extends _Fields(2, "name")
    case object value extends _Fields(3, "value")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.typeId,
    2.toShort -> _Fields.name,
    3.toShort -> _Fields.value
  )

  // Record v2
  override type Self = Const.type
  override type Trait = Const
  override type Mutable = MutableConst
  override type Raw = RawConst

  override def createRecord: Const = createRawRecord
  override def createRawRecord: Const.Raw = new Const.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Const] = {
    if (x.isInstanceOf[Const]) Some(x.asInstanceOf[Const]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val typeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Const, Const.type](
      name = "typeId",
      longName = "typeId",
      id = 1,
      annotations = Map(),
      owner = Const,
      getter = _.typeIdOption,
      setterRaw = (r: Const.Raw, v: String) => { r.typeId_=(v) },
      manifest = manifest[String]
    )

  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Const, Const.type](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = Const,
      getter = _.nameOption,
      setterRaw = (r: Const.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val value =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Const, Const.type](
      name = "value",
      longName = "value",
      id = 3,
      annotations = Map(),
      owner = Const,
      getter = _.valueOption,
      setterRaw = (r: Const.Raw, v: String) => { r.value_=(v) },
      manifest = manifest[String]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Const, Const.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Const, Const.type]](
      typeId,
      name,
      value
    )


  def apply(
      typeId: String,
      name: String,
      value: String
  ): Const = {
    val ret = Const.createRawRecord
    ret.typeId_=(typeId)
    ret.name_=(name)
    ret.value_=(value)
    ret
  }



  object Builder {
    sealed trait HasTypeId
    sealed trait HasName
    sealed trait HasValue

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeId with HasName with HasValue
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Const] (private var obj: Const.Raw) {
    def typeId(v: String): Const.Builder[State with Builder.HasTypeId] = {
      obj.typeId_=(v)
      this.asInstanceOf[Const.Builder[State with Builder.HasTypeId]]
    }
    def name(v: String): Const.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Const.Builder[State with Builder.HasName]]
    }
    def value(v: String): Const.Builder[State with Builder.HasValue] = {
      obj.value_=(v)
      this.asInstanceOf[Const.Builder[State with Builder.HasValue]]
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasValue): Const.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Const.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasValue): Const = resultMutable()(ev0, ev1, ev2)
  }

  def newBuilder: Const.Builder.AllUnspecified = new Builder(Const.createRawRecord)

  implicit val companionProvider: ConstCompanionProvider = new ConstCompanionProvider
}

class ConstCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Const] {
  type CompanionT = Const.type
  override def provide: Const.type = Const
}



trait Const

    extends com.foursquare.recordv2.runtime.Record[Const]
    with scala.Ordered[Const]
    with org.apache.thrift.TBase[Const, Const._Fields] {

  override type MetaT = Const.type


  def typeId: String
  def typeIdOption: Option[String]
  def typeIdOrNull: String
  def typeIdOrThrow: String
  def typeIdIsSet: Boolean

  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean

  def value: String
  def valueOption: Option[String]
  def valueOrNull: String
  def valueOrThrow: String
  def valueIsSet: Boolean
  override def compare(that: Const): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.typeIdIsSet.compareTo(that.typeIdIsSet)
      cmp != 0 }) cmp
    else if (this.typeIdIsSet && {
      cmp = this.typeIdOrNull.compareTo(that.typeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueIsSet.compareTo(that.valueIsSet)
      cmp != 0 }) cmp
    else if (this.valueIsSet && {
      cmp = this.valueOrNull.compareTo(that.valueOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Const

  def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const

  def mutableCopy(): Const.Mutable = {
    val ret = Const.createRawRecord

    if (typeIdIsSet) ret.typeId_=(typeIdOrNull)

    if (nameIsSet) ret.name_=(nameOrNull)

    if (valueIsSet) ret.value_=(valueOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Const.Mutable

  def toBuilder() = {
    val ret = new Const.Builder(Const.createRawRecord)

    if (typeIdIsSet) ret.typeId(typeIdOrNull)

    if (nameIsSet) ret.name(nameOrNull)

    if (valueIsSet) ret.value(valueOrNull)
    ret
  }

  def mergeCopy(that: Const): Const

}


trait ConstProxy extends Const {
  protected def underlying: Const

  override def meta: Const.type = underlying.meta

// field/proxy_ref.ssp

  override def typeId: String = underlying.typeId
  override def typeIdOption: Option[String] = underlying.typeIdOption
  override def typeIdOrNull: String = underlying.typeIdOrNull
  override def typeIdOrThrow: String = underlying.typeIdOrThrow
  override def typeIdIsSet: Boolean = underlying.typeIdIsSet
// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp

  override def value: String = underlying.value
  override def valueOption: Option[String] = underlying.valueOption
  override def valueOrNull: String = underlying.valueOrNull
  override def valueOrThrow: String = underlying.valueOrThrow
  override def valueIsSet: Boolean = underlying.valueIsSet

  override def compare(that: Const): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const = underlying.copy(
    typeId = typeId,
    name = name,
    value = value
  )

  override def mutableCopy(): Const.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Const): Const = underlying.mergeCopy(that)

  override def mutable: Const.Mutable = underlying.mutable

  override def deepCopy(): Const = underlying.deepCopy()

  override def fieldForId(id: Int): Const._Fields = underlying.fieldForId(id)
  override def isSet(field: Const._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Const._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Const._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableConst extends Const {
  def typeId_=(x: String): Unit
  def typeIdUnset(): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def value_=(x: String): Unit
  def valueUnset(): Unit

  def merge(that: Const): Unit

  def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const.Mutable

  override def mutable: Const.Mutable = this
}

trait MutableConstProxy extends MutableConst with ConstProxy {
  protected def underlying: MutableConst

  override def typeId_=(x: String): Unit = { underlying.typeId_=(x) }
  override def typeIdUnset(): Unit = { underlying.typeIdUnset() }
  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def value_=(x: String): Unit = { underlying.value_=(x) }
  override def valueUnset(): Unit = { underlying.valueUnset() }

  override def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const.Mutable = underlying.copy(
    typeId = typeId,
    name = name,
    value = value
  )

  override def merge(that: Const): Unit = underlying.merge(that)
}



final class RawConst extends MutableConst {
  override def meta: Const.type = Const

  // Field #1 - typeId
  private var _typeId: String = null  // Underlying type: String
  override def typeId: String = typeIdOrThrow
  override def typeId_=(x: String): Unit = { _typeId = x }
  override def typeIdOption: Option[String] = if (typeIdIsSet) Some(_typeId) else None
  override def typeIdOrNull: String = _typeId
  override def typeIdOrThrow: String = if (typeIdIsSet) _typeId else throw new java.lang.NullPointerException
  override def typeIdIsSet: Boolean = _typeId != null
  override def typeIdUnset(): Unit = { _typeId = null }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #3 - value
  private var _value: String = null  // Underlying type: String
  override def value: String = valueOrThrow
  override def value_=(x: String): Unit = { _value = x }
  override def valueOption: Option[String] = if (valueIsSet) Some(_value) else None
  override def valueOrNull: String = _value
  override def valueOrThrow: String = if (valueIsSet) _value else throw new java.lang.NullPointerException
  override def valueIsSet: Boolean = _value != null
  override def valueUnset(): Unit = { _value = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Const.CONST_DESC)
    if (typeIdIsSet) {
      oprot.writeFieldBegin(Const.TYPEID_DESC)
      oprot.writeString(_typeId)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(Const.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (valueIsSet) {
      oprot.writeFieldBegin(Const.VALUE_DESC)
      oprot.writeString(_value)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Const.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // typeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // value

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _value = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Const".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Const): Unit = {
    if (that.typeIdIsSet && !this.typeIdIsSet) {
      this.typeId_=(that.typeIdOrNull)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.valueIsSet && !this.valueIsSet) {
      this.value_=(that.valueOrNull)
    }
  }

  override def mergeCopy(that: Const): Const = {
    val ret = Const.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Const => this.equals(o)
    case _ => false
  }

  def equals(that: Const): Boolean = {
    that != null &&
    (if (this.typeIdIsSet) (that.typeIdIsSet && this.typeIdOrNull == that.typeIdOrNull) else !that.typeIdIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.valueIsSet) (that.valueIsSet && this.valueOrNull == that.valueOrNull) else !that.valueIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (typeIdIsSet) hasher.append(_typeId.##)
    if (nameIsSet) hasher.append(_name.##)
    if (valueIsSet) hasher.append(_value.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (typeIdIsSet) ret = typeIdOrNull :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    if (valueIsSet) ret = valueOrNull :: ret
    ret.reverse
  }

  override def clear() {
    typeIdUnset()
    nameUnset()
    valueUnset()
  }

  def fieldForId(id: Int): Const._Fields = id match {
    case 1 => Const._Fields.typeId
    case 2 => Const._Fields.name
    case 3 => Const._Fields.value
    case _ => null
  }

  def isSet(field: Const._Fields): Boolean = field match {
    case Const._Fields.typeId => typeIdIsSet
    case Const._Fields.name => nameIsSet
    case Const._Fields.value => valueIsSet
    case _ => false
  }

  def getFieldValue(field: Const._Fields): AnyRef = field match {
    case Const._Fields.typeId => typeIdOrNull.asInstanceOf[AnyRef]
    case Const._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Const._Fields.value => valueOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Const._Fields, value: AnyRef) {
    field match {
      case Const._Fields.typeId => typeId_=(value.asInstanceOf[String])
      case Const._Fields.name => name_=(value.asInstanceOf[String])
      case Const._Fields.value => value_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): Const.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Const.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const.Raw = {
    val ret = new Const.Raw
    if (typeId != null) ret.typeId_=(typeId)
    if (name != null) ret.name_=(name)
    if (value != null) ret.value_=(value)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object EnumElement
    extends com.foursquare.recordv2.runtime.MetaRecord[EnumElement]
    with com.foursquare.recordv2.runtime.RecordProvider[EnumElement] {
  override def recordName: String = "EnumElement"


  // Thrift descriptors.
  val ENUMELEMENT_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("EnumElement")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val VALUE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "value",
      org.apache.thrift.protocol.TType.I32,
      2,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "value" -> VALUE_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object value extends _Fields(2, "value")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.value,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = EnumElement.type
  override type Trait = EnumElement
  override type Mutable = MutableEnumElement
  override type Raw = RawEnumElement

  override def createRecord: EnumElement = createRawRecord
  override def createRawRecord: EnumElement.Raw = new EnumElement.Raw

  override def ifInstanceFrom(x: AnyRef): Option[EnumElement] = {
    if (x.isInstanceOf[EnumElement]) Some(x.asInstanceOf[EnumElement]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, EnumElement, EnumElement.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = EnumElement,
      getter = _.nameOption,
      setterRaw = (r: EnumElement.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val value =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[Int, EnumElement, EnumElement.type](
      name = "value",
      longName = "value",
      id = 2,
      annotations = Map(),
      owner = EnumElement,
      getter = _.valueOption,
      setterRaw = (r: EnumElement.Raw, v: Int) => { r.value_=(v) },
      manifest = manifest[Int]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], EnumElement, EnumElement.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = EnumElement,
      getter = _.annotationsOption,
      setterRaw = (r: EnumElement.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, EnumElement, EnumElement.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, EnumElement, EnumElement.type]](
      name,
      value,
      __annotations
    )


  def apply(
      name: String,
      value: Int,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): EnumElement = {
    val ret = EnumElement.createRawRecord
    ret.name_=(name)
    ret.value_=(value)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasValue

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasValue
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[EnumElement] (private var obj: EnumElement.Raw) {
    def name(v: String): EnumElement.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[EnumElement.Builder[State with Builder.HasName]]
    }
    def value(v: Int): EnumElement.Builder[State with Builder.HasValue] = {
      obj.value_=(v)
      this.asInstanceOf[EnumElement.Builder[State with Builder.HasValue]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): EnumElement.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): EnumElement.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasValue): EnumElement.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("EnumElement.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasValue): EnumElement = resultMutable()(ev0, ev1)
  }

  def newBuilder: EnumElement.Builder.AllUnspecified = new Builder(EnumElement.createRawRecord)

  implicit val companionProvider: EnumElementCompanionProvider = new EnumElementCompanionProvider
}

class EnumElementCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[EnumElement] {
  type CompanionT = EnumElement.type
  override def provide: EnumElement.type = EnumElement
}



trait EnumElement

    extends com.foursquare.recordv2.runtime.Record[EnumElement]
    with scala.Ordered[EnumElement]
    with org.apache.thrift.TBase[EnumElement, EnumElement._Fields] {

  override type MetaT = EnumElement.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def value: Int
  def valueOption: Option[Int]
  def valueOrDefault: Int
  def valueOrNull: java.lang.Integer
  def valueOrThrow: Int
  def valueIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: EnumElement): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueIsSet.compareTo(that.valueIsSet)
      cmp != 0 }) cmp
    else if (this.valueIsSet && {
      cmp = this.value.compareTo(that.value)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): EnumElement

  def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement

  def mutableCopy(): EnumElement.Mutable = {
    val ret = EnumElement.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (valueIsSet) ret.value_=(valueOrDefault)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: EnumElement.Mutable

  def toBuilder() = {
    val ret = new EnumElement.Builder(EnumElement.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (valueIsSet) ret.value(valueOrDefault)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: EnumElement): EnumElement

}


trait EnumElementProxy extends EnumElement {
  protected def underlying: EnumElement

  override def meta: EnumElement.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_primitive.ssp
  override def value: Int = underlying.value
  override def valueOption: Option[Int] = underlying.valueOption
  override def valueOrDefault: Int = underlying.valueOrDefault
  override def valueOrNull: java.lang.Integer = underlying.valueOrNull
  override def valueOrThrow: Int = underlying.valueOrThrow
  override def valueIsSet: Boolean = underlying.valueIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: EnumElement): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement = underlying.copy(
    name = name,
    value = value,
    __annotations = __annotations
  )

  override def mutableCopy(): EnumElement.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: EnumElement): EnumElement = underlying.mergeCopy(that)

  override def mutable: EnumElement.Mutable = underlying.mutable

  override def deepCopy(): EnumElement = underlying.deepCopy()

  override def fieldForId(id: Int): EnumElement._Fields = underlying.fieldForId(id)
  override def isSet(field: EnumElement._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: EnumElement._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: EnumElement._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableEnumElement extends EnumElement {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def value_=(x: Int): Unit
  def valueUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: EnumElement): Unit

  def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement.Mutable

  override def mutable: EnumElement.Mutable = this
}

trait MutableEnumElementProxy extends MutableEnumElement with EnumElementProxy {
  protected def underlying: MutableEnumElement

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def value_=(x: Int): Unit = { underlying.value_=(x) }
  override def valueUnset(): Unit = { underlying.valueUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement.Mutable = underlying.copy(
    name = name,
    value = value,
    __annotations = __annotations
  )

  override def merge(that: EnumElement): Unit = underlying.merge(that)
}



final class RawEnumElement extends MutableEnumElement {
  override def meta: EnumElement.type = EnumElement

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - value
  private var _value: Int = 0  // Underlying type: Int
  private var _valueIsSet: Boolean = false
  override def value: Int = valueOrDefault
  override def value_=(x: Int): Unit = { _value = x ; _valueIsSet = true }
  override def valueOption: Option[Int] = if (valueIsSet) Some(_value) else None
  override def valueOrDefault: Int = _value
  override def valueOrNull: java.lang.Integer = if (valueIsSet) _value else null
  override def valueOrThrow: Int = if (valueIsSet) _value else throw new java.lang.NullPointerException
  override def valueIsSet: Boolean = _valueIsSet
  override def valueUnset(): Unit = { _valueIsSet = false; _value = 0 }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(EnumElement.ENUMELEMENT_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(EnumElement.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (valueIsSet) {
      oprot.writeFieldBegin(EnumElement.VALUE_DESC)
      oprot.writeI32(_value)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(EnumElement.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        EnumElement.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // value

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32) {
              _value = iprot.readI32()

              _valueIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure EnumElement".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: EnumElement): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.valueIsSet && !this.valueIsSet) {
      this.value_=(that.valueOrDefault)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: EnumElement): EnumElement = {
    val ret = EnumElement.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: EnumElement => this.equals(o)
    case _ => false
  }

  def equals(that: EnumElement): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.valueIsSet) (that.valueIsSet && this.valueOrDefault == that.valueOrDefault) else !that.valueIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (valueIsSet) hasher.append(_value.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (valueIsSet) ret = valueOrDefault :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    valueUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): EnumElement._Fields = id match {
    case 1 => EnumElement._Fields.name
    case 2 => EnumElement._Fields.value
    case 99 => EnumElement._Fields.__annotations
    case _ => null
  }

  def isSet(field: EnumElement._Fields): Boolean = field match {
    case EnumElement._Fields.name => nameIsSet
    case EnumElement._Fields.value => valueIsSet
    case EnumElement._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: EnumElement._Fields): AnyRef = field match {
    case EnumElement._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case EnumElement._Fields.value => valueOrDefault.asInstanceOf[AnyRef]
    case EnumElement._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: EnumElement._Fields, value: AnyRef) {
    field match {
      case EnumElement._Fields.name => name_=(value.asInstanceOf[String])
      case EnumElement._Fields.value => value_=(value.asInstanceOf[Int])
      case EnumElement._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): EnumElement.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = EnumElement.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement.Raw = {
    val ret = new EnumElement.Raw
    if (name != null) ret.name_=(name)
    if (value != null) ret.value_=(value)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Enum
    extends com.foursquare.recordv2.runtime.MetaRecord[Enum]
    with com.foursquare.recordv2.runtime.RecordProvider[Enum] {
  override def recordName: String = "Enum"


  // Thrift descriptors.
  val ENUM_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Enum")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val ELEMENTS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "elements",
      org.apache.thrift.protocol.TType.LIST,
      2,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "elements" -> ELEMENTS_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object elements extends _Fields(2, "elements")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.elements,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Enum.type
  override type Trait = Enum
  override type Mutable = MutableEnum
  override type Raw = RawEnum

  override def createRecord: Enum = createRawRecord
  override def createRawRecord: Enum.Raw = new Enum.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Enum] = {
    if (x.isInstanceOf[Enum]) Some(x.asInstanceOf[Enum]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Enum, Enum.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = Enum,
      getter = _.nameOption,
      setterRaw = (r: Enum.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val elements =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement], Enum, Enum.type](
      name = "elements",
      longName = "elements",
      id = 2,
      annotations = Map(),
      owner = Enum,
      getter = _.elementsOption,
      setterRaw = (r: Enum.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]) => { r.elements_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Enum, Enum.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Enum,
      getter = _.annotationsOption,
      setterRaw = (r: Enum.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Enum, Enum.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Enum, Enum.type]](
      name,
      elements,
      __annotations
    )


  def apply(
      name: String,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Enum = {
    val ret = Enum.createRawRecord
    ret.name_=(name)
    ret.elements_=(elements)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasElements

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasElements
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Enum] (private var obj: Enum.Raw) {
    def name(v: String): Enum.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Enum.Builder[State with Builder.HasName]]
    }
    def elements(v: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Enum.Builder[State with Builder.HasElements] = {
      obj.elements_=(v)
      this.asInstanceOf[Enum.Builder[State with Builder.HasElements]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Enum.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Enum.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasElements): Enum.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Enum.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasElements): Enum = resultMutable()(ev0, ev1)
  }

  def newBuilder: Enum.Builder.AllUnspecified = new Builder(Enum.createRawRecord)

  implicit val companionProvider: EnumCompanionProvider = new EnumCompanionProvider
}

class EnumCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Enum] {
  type CompanionT = Enum.type
  override def provide: Enum.type = Enum
}



trait Enum

    extends com.foursquare.recordv2.runtime.Record[Enum]
    with scala.Ordered[Enum]
    with org.apache.thrift.TBase[Enum, Enum._Fields] {

  override type MetaT = Enum.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]
  def elementsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]]
  def elementsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]
  def elementsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]
  def elementsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]
  def elementsIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Enum): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.elementsIsSet.compareTo(that.elementsIsSet)
      cmp != 0 }) cmp
    else if (this.elementsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.elements.asJava, that.elements.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Enum

  def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum

  def mutableCopy(): Enum.Mutable = {
    val ret = Enum.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (elementsIsSet) ret.elements_=(elementsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Enum.Mutable

  def toBuilder() = {
    val ret = new Enum.Builder(Enum.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (elementsIsSet) ret.elements(elementsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Enum): Enum

}


trait EnumProxy extends Enum {
  protected def underlying: Enum

  override def meta: Enum.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elements
  override def elementsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]] = underlying.elementsOption
  override def elementsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elementsOrDefault
  override def elementsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elementsOrNull
  override def elementsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elementsOrThrow
  override def elementsIsSet: Boolean = underlying.elementsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Enum): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum = underlying.copy(
    name = name,
    elements = elements,
    __annotations = __annotations
  )

  override def mutableCopy(): Enum.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Enum): Enum = underlying.mergeCopy(that)

  override def mutable: Enum.Mutable = underlying.mutable

  override def deepCopy(): Enum = underlying.deepCopy()

  override def fieldForId(id: Int): Enum._Fields = underlying.fieldForId(id)
  override def isSet(field: Enum._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Enum._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Enum._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableEnum extends Enum {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def elements_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Unit
  def elementsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Enum): Unit

  def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum.Mutable

  override def mutable: Enum.Mutable = this
}

trait MutableEnumProxy extends MutableEnum with EnumProxy {
  protected def underlying: MutableEnum

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def elements_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Unit = { underlying.elements_=(x) }
  override def elementsUnset(): Unit = { underlying.elementsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum.Mutable = underlying.copy(
    name = name,
    elements = elements,
    __annotations = __annotations
  )

  override def merge(that: Enum): Unit = underlying.merge(that)
}



final class RawEnum extends MutableEnum {
  override def meta: Enum.type = Enum

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - elements
  private var _elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]
  override def elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrDefault
  override def elements_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Unit = { _elements = x }
  override def elementsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]] = if (elementsIsSet) Some(_elements) else None
  override def elementsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = if (elementsIsSet) _elements else scala.collection.Seq.empty
  override def elementsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = _elements
  override def elementsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = if (elementsIsSet) _elements else throw new java.lang.NullPointerException
  override def elementsIsSet: Boolean = _elements != null
  override def elementsUnset(): Unit = { _elements = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Enum.ENUM_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Enum.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (elementsIsSet) {
      oprot.writeFieldBegin(Enum.ELEMENTS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _elements.size))
      _elements.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Enum.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Enum.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // elements

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _elements = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.EnumElement]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.EnumElement.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Enum".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Enum): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.elementsIsSet && !this.elementsIsSet) {
      this.elements_=(that.elementsOrNull)

    } else if (that.elementsIsSet && this.elementsIsSet) {
      this.elements ++= that.elements
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Enum): Enum = {
    val ret = Enum.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Enum => this.equals(o)
    case _ => false
  }

  def equals(that: Enum): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.elementsIsSet) (that.elementsIsSet && this.elementsOrNull == that.elementsOrNull) else !that.elementsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (elementsIsSet) hasher.append(_elements.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (elementsIsSet) ret = elementsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    elementsUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Enum._Fields = id match {
    case 1 => Enum._Fields.name
    case 2 => Enum._Fields.elements
    case 99 => Enum._Fields.__annotations
    case _ => null
  }

  def isSet(field: Enum._Fields): Boolean = field match {
    case Enum._Fields.name => nameIsSet
    case Enum._Fields.elements => elementsIsSet
    case Enum._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Enum._Fields): AnyRef = field match {
    case Enum._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Enum._Fields.elements => elementsOrNull.asInstanceOf[AnyRef]
    case Enum._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Enum._Fields, value: AnyRef) {
    field match {
      case Enum._Fields.name => name_=(value.asInstanceOf[String])
      case Enum._Fields.elements => elements_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]])
      case Enum._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Enum.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Enum.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum.Raw = {
    val ret = new Enum.Raw
    if (name != null) ret.name_=(name)
    if (elements != null) ret.elements_=(elements)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Field
    extends com.foursquare.recordv2.runtime.MetaRecord[Field]
    with com.foursquare.recordv2.runtime.RecordProvider[Field] {
  override def recordName: String = "Field"


  // Thrift descriptors.
  val FIELD_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Field")

  val IDENTIFIER_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "identifier",
      org.apache.thrift.protocol.TType.I16,
      1,
      Map[String, String]().asJava
    )
  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )
  val TYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeId",
      org.apache.thrift.protocol.TType.STRING,
      3,
      Map[String, String]().asJava
    )
  val REQUIREDNESS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "requiredness",
      org.apache.thrift.protocol.TType.I32,
      4,
      Map[String, String]().asJava
    )
  val DEFAULTVALUE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "defaultValue",
      org.apache.thrift.protocol.TType.STRING,
      5,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "identifier" -> IDENTIFIER_DESC,
    "name" -> NAME_DESC,
    "typeId" -> TYPEID_DESC,
    "requiredness" -> REQUIREDNESS_DESC,
    "defaultValue" -> DEFAULTVALUE_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object identifier extends _Fields(1, "identifier")
    case object name extends _Fields(2, "name")
    case object typeId extends _Fields(3, "typeId")
    case object requiredness extends _Fields(4, "requiredness")
    case object defaultValue extends _Fields(5, "defaultValue")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.identifier,
    2.toShort -> _Fields.name,
    3.toShort -> _Fields.typeId,
    4.toShort -> _Fields.requiredness,
    5.toShort -> _Fields.defaultValue,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Field.type
  override type Trait = Field
  override type Mutable = MutableField
  override type Raw = RawField

  override def createRecord: Field = createRawRecord
  override def createRawRecord: Field.Raw = new Field.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Field] = {
    if (x.isInstanceOf[Field]) Some(x.asInstanceOf[Field]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val identifier =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[Short, Field, Field.type](
      name = "identifier",
      longName = "identifier",
      id = 1,
      annotations = Map(),
      owner = Field,
      getter = _.identifierOption,
      setterRaw = (r: Field.Raw, v: Short) => { r.identifier_=(v) },
      manifest = manifest[Short]
    )

  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Field, Field.type](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = Field,
      getter = _.nameOption,
      setterRaw = (r: Field.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val typeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Field, Field.type](
      name = "typeId",
      longName = "typeId",
      id = 3,
      annotations = Map(),
      owner = Field,
      getter = _.typeIdOption,
      setterRaw = (r: Field.Raw, v: String) => { r.typeId_=(v) },
      manifest = manifest[String]
    )

  val requiredness =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.Requiredness, Field, Field.type](
      name = "requiredness",
      longName = "requiredness",
      id = 4,
      annotations = Map(),
      owner = Field,
      getter = _.requirednessOption,
      setterRaw = (r: Field.Raw, v: com.twitter.thrift.descriptors.Requiredness) => { r.requiredness_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.Requiredness]
    )

  val defaultValue =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Field, Field.type](
      name = "defaultValue",
      longName = "defaultValue",
      id = 5,
      annotations = Map(),
      owner = Field,
      getter = _.defaultValueOption,
      setterRaw = (r: Field.Raw, v: String) => { r.defaultValue_=(v) },
      manifest = manifest[String]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Field, Field.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Field,
      getter = _.annotationsOption,
      setterRaw = (r: Field.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Field, Field.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Field, Field.type]](
      identifier,
      name,
      typeId,
      requiredness,
      defaultValue,
      __annotations
    )


  def apply(
      identifier: Short,
      name: String,
      typeId: String,
      requiredness: com.twitter.thrift.descriptors.Requiredness,
      defaultValue: String,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Field = {
    val ret = Field.createRawRecord
    ret.identifier_=(identifier)
    ret.name_=(name)
    ret.typeId_=(typeId)
    ret.requiredness_=(requiredness)
    ret.defaultValue_=(defaultValue)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasIdentifier
    sealed trait HasName
    sealed trait HasTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasIdentifier with HasName with HasTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Field] (private var obj: Field.Raw) {
    def identifier(v: Short): Field.Builder[State with Builder.HasIdentifier] = {
      obj.identifier_=(v)
      this.asInstanceOf[Field.Builder[State with Builder.HasIdentifier]]
    }
    def name(v: String): Field.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Field.Builder[State with Builder.HasName]]
    }
    def typeId(v: String): Field.Builder[State with Builder.HasTypeId] = {
      obj.typeId_=(v)
      this.asInstanceOf[Field.Builder[State with Builder.HasTypeId]]
    }

    def requiredness(v: com.twitter.thrift.descriptors.Requiredness): Field.Builder[State] = {
      obj.requiredness_=(v)
      this
    }

    def requiredness(vOpt: Option[com.twitter.thrift.descriptors.Requiredness]): Field.Builder[State] = {
      vOpt match {
        case Some(v) => obj.requiredness_=(v)
        case None => obj.requirednessUnset()
      }
      this
    }

    def defaultValue(v: String): Field.Builder[State] = {
      obj.defaultValue_=(v)
      this
    }

    def defaultValue(vOpt: Option[String]): Field.Builder[State] = {
      vOpt match {
        case Some(v) => obj.defaultValue_=(v)
        case None => obj.defaultValueUnset()
      }
      this
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Field.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Field.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasIdentifier, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasTypeId): Field.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Field.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasIdentifier, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasTypeId): Field = resultMutable()(ev0, ev1, ev2)
  }

  def newBuilder: Field.Builder.AllUnspecified = new Builder(Field.createRawRecord)

  implicit val companionProvider: FieldCompanionProvider = new FieldCompanionProvider
}

class FieldCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Field] {
  type CompanionT = Field.type
  override def provide: Field.type = Field
}



trait Field

    extends com.foursquare.recordv2.runtime.Record[Field]
    with scala.Ordered[Field]
    with org.apache.thrift.TBase[Field, Field._Fields] {

  override type MetaT = Field.type

  def identifier: Short
  def identifierOption: Option[Short]
  def identifierOrDefault: Short
  def identifierOrNull: java.lang.Short
  def identifierOrThrow: Short
  def identifierIsSet: Boolean

  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean

  def typeId: String
  def typeIdOption: Option[String]
  def typeIdOrNull: String
  def typeIdOrThrow: String
  def typeIdIsSet: Boolean
  def requirednessOption: Option[com.twitter.thrift.descriptors.Requiredness]
  def requirednessOrNull: com.twitter.thrift.descriptors.Requiredness
  def requirednessOrThrow: com.twitter.thrift.descriptors.Requiredness
  def requirednessIsSet: Boolean
  def defaultValueOption: Option[String]
  def defaultValueOrNull: String
  def defaultValueOrThrow: String
  def defaultValueIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Field): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.identifierIsSet.compareTo(that.identifierIsSet)
      cmp != 0 }) cmp
    else if (this.identifierIsSet && {
      cmp = this.identifier.compareTo(that.identifier)
      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typeIdIsSet.compareTo(that.typeIdIsSet)
      cmp != 0 }) cmp
    else if (this.typeIdIsSet && {
      cmp = this.typeIdOrNull.compareTo(that.typeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.requirednessIsSet.compareTo(that.requirednessIsSet)
      cmp != 0 }) cmp
    else if (this.requirednessIsSet && {
      cmp = this.requirednessOrNull.compareTo(that.requirednessOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.defaultValueIsSet.compareTo(that.defaultValueIsSet)
      cmp != 0 }) cmp
    else if (this.defaultValueIsSet && {
      cmp = this.defaultValueOrNull.compareTo(that.defaultValueOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Field

  def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field

  def mutableCopy(): Field.Mutable = {
    val ret = Field.createRawRecord

    if (identifierIsSet) ret.identifier_=(identifierOrDefault)

    if (nameIsSet) ret.name_=(nameOrNull)

    if (typeIdIsSet) ret.typeId_=(typeIdOrNull)

    if (requirednessIsSet) ret.requiredness_=(requirednessOrNull)

    if (defaultValueIsSet) ret.defaultValue_=(defaultValueOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Field.Mutable

  def toBuilder() = {
    val ret = new Field.Builder(Field.createRawRecord)

    if (identifierIsSet) ret.identifier(identifierOrDefault)

    if (nameIsSet) ret.name(nameOrNull)

    if (typeIdIsSet) ret.typeId(typeIdOrNull)

    if (requirednessIsSet) ret.requiredness(requirednessOrNull)

    if (defaultValueIsSet) ret.defaultValue(defaultValueOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Field): Field

}


trait FieldProxy extends Field {
  protected def underlying: Field

  override def meta: Field.type = underlying.meta

// field/proxy_primitive.ssp
  override def identifier: Short = underlying.identifier
  override def identifierOption: Option[Short] = underlying.identifierOption
  override def identifierOrDefault: Short = underlying.identifierOrDefault
  override def identifierOrNull: java.lang.Short = underlying.identifierOrNull
  override def identifierOrThrow: Short = underlying.identifierOrThrow
  override def identifierIsSet: Boolean = underlying.identifierIsSet
// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp

  override def typeId: String = underlying.typeId
  override def typeIdOption: Option[String] = underlying.typeIdOption
  override def typeIdOrNull: String = underlying.typeIdOrNull
  override def typeIdOrThrow: String = underlying.typeIdOrThrow
  override def typeIdIsSet: Boolean = underlying.typeIdIsSet
// field/proxy_ref.ssp
  override def requirednessOption: Option[com.twitter.thrift.descriptors.Requiredness] = underlying.requirednessOption
  override def requirednessOrNull: com.twitter.thrift.descriptors.Requiredness = underlying.requirednessOrNull
  override def requirednessOrThrow: com.twitter.thrift.descriptors.Requiredness = underlying.requirednessOrThrow
  override def requirednessIsSet: Boolean = underlying.requirednessIsSet
// field/proxy_ref.ssp
  override def defaultValueOption: Option[String] = underlying.defaultValueOption
  override def defaultValueOrNull: String = underlying.defaultValueOrNull
  override def defaultValueOrThrow: String = underlying.defaultValueOrThrow
  override def defaultValueIsSet: Boolean = underlying.defaultValueIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Field): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field = underlying.copy(
    identifier = identifier,
    name = name,
    typeId = typeId,
    requiredness = requiredness,
    defaultValue = defaultValue,
    __annotations = __annotations
  )

  override def mutableCopy(): Field.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Field): Field = underlying.mergeCopy(that)

  override def mutable: Field.Mutable = underlying.mutable

  override def deepCopy(): Field = underlying.deepCopy()

  override def fieldForId(id: Int): Field._Fields = underlying.fieldForId(id)
  override def isSet(field: Field._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Field._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Field._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableField extends Field {
  def identifier_=(x: Short): Unit
  def identifierUnset(): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def typeId_=(x: String): Unit
  def typeIdUnset(): Unit
  def requiredness_=(x: com.twitter.thrift.descriptors.Requiredness): Unit
  def requirednessUnset(): Unit
  def defaultValue_=(x: String): Unit
  def defaultValueUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Field): Unit

  def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field.Mutable

  override def mutable: Field.Mutable = this
}

trait MutableFieldProxy extends MutableField with FieldProxy {
  protected def underlying: MutableField

  override def identifier_=(x: Short): Unit = { underlying.identifier_=(x) }
  override def identifierUnset(): Unit = { underlying.identifierUnset() }
  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def typeId_=(x: String): Unit = { underlying.typeId_=(x) }
  override def typeIdUnset(): Unit = { underlying.typeIdUnset() }
  override def requiredness_=(x: com.twitter.thrift.descriptors.Requiredness): Unit = { underlying.requiredness_=(x) }
  override def requirednessUnset(): Unit = { underlying.requirednessUnset() }
  override def defaultValue_=(x: String): Unit = { underlying.defaultValue_=(x) }
  override def defaultValueUnset(): Unit = { underlying.defaultValueUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field.Mutable = underlying.copy(
    identifier = identifier,
    name = name,
    typeId = typeId,
    requiredness = requiredness,
    defaultValue = defaultValue,
    __annotations = __annotations
  )

  override def merge(that: Field): Unit = underlying.merge(that)
}



final class RawField extends MutableField {
  override def meta: Field.type = Field

  // Field #1 - identifier
  private var _identifier: Short = 0  // Underlying type: Short
  private var _identifierIsSet: Boolean = false
  override def identifier: Short = identifierOrDefault
  override def identifier_=(x: Short): Unit = { _identifier = x ; _identifierIsSet = true }
  override def identifierOption: Option[Short] = if (identifierIsSet) Some(_identifier) else None
  override def identifierOrDefault: Short = _identifier
  override def identifierOrNull: java.lang.Short = if (identifierIsSet) _identifier else null
  override def identifierOrThrow: Short = if (identifierIsSet) _identifier else throw new java.lang.NullPointerException
  override def identifierIsSet: Boolean = _identifierIsSet
  override def identifierUnset(): Unit = { _identifierIsSet = false; _identifier = 0 }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #3 - typeId
  private var _typeId: String = null  // Underlying type: String
  override def typeId: String = typeIdOrThrow
  override def typeId_=(x: String): Unit = { _typeId = x }
  override def typeIdOption: Option[String] = if (typeIdIsSet) Some(_typeId) else None
  override def typeIdOrNull: String = _typeId
  override def typeIdOrThrow: String = if (typeIdIsSet) _typeId else throw new java.lang.NullPointerException
  override def typeIdIsSet: Boolean = _typeId != null
  override def typeIdUnset(): Unit = { _typeId = null }
  // Field #4 - requiredness
  private var _requiredness: com.twitter.thrift.descriptors.Requiredness = null  // Underlying type: com.twitter.thrift.descriptors.Requiredness
  override def requiredness_=(x: com.twitter.thrift.descriptors.Requiredness): Unit = { _requiredness = x }
  override def requirednessOption: Option[com.twitter.thrift.descriptors.Requiredness] = if (requirednessIsSet) Some(_requiredness) else None
  override def requirednessOrNull: com.twitter.thrift.descriptors.Requiredness = _requiredness
  override def requirednessOrThrow: com.twitter.thrift.descriptors.Requiredness = if (requirednessIsSet) _requiredness else throw new java.lang.NullPointerException
  override def requirednessIsSet: Boolean = _requiredness != null
  override def requirednessUnset(): Unit = { _requiredness = null }
  // Field #5 - defaultValue
  private var _defaultValue: String = null  // Underlying type: String
  override def defaultValue_=(x: String): Unit = { _defaultValue = x }
  override def defaultValueOption: Option[String] = if (defaultValueIsSet) Some(_defaultValue) else None
  override def defaultValueOrNull: String = _defaultValue
  override def defaultValueOrThrow: String = if (defaultValueIsSet) _defaultValue else throw new java.lang.NullPointerException
  override def defaultValueIsSet: Boolean = _defaultValue != null
  override def defaultValueUnset(): Unit = { _defaultValue = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Field.FIELD_DESC)
    if (identifierIsSet) {
      oprot.writeFieldBegin(Field.IDENTIFIER_DESC)
      oprot.writeI16(_identifier)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(Field.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (typeIdIsSet) {
      oprot.writeFieldBegin(Field.TYPEID_DESC)
      oprot.writeString(_typeId)
      oprot.writeFieldEnd()
    }
    if (requirednessIsSet) {
      oprot.writeFieldBegin(Field.REQUIREDNESS_DESC)
      oprot.writeI32(_requiredness.getValue())
      oprot.writeFieldEnd()
    }
    if (defaultValueIsSet) {
      oprot.writeFieldBegin(Field.DEFAULTVALUE_DESC)
      oprot.writeString(_defaultValue)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Field.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Field.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // identifier

            if (field_header.`type` == org.apache.thrift.protocol.TType.I16) {
              _identifier = iprot.readI16()

              _identifierIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // typeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // requiredness

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32 || field_header.`type` == org.apache.thrift.protocol.TType.ENUM) {
              _requiredness = com.twitter.thrift.descriptors.Requiredness.findByIdOrNull(iprot.readI32())
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // defaultValue

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _defaultValue = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Field".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Field): Unit = {
    if (that.identifierIsSet && !this.identifierIsSet) {
      this.identifier_=(that.identifierOrDefault)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.typeIdIsSet && !this.typeIdIsSet) {
      this.typeId_=(that.typeIdOrNull)
    }
    if (that.requirednessIsSet && !this.requirednessIsSet) {
      this.requiredness_=(that.requirednessOrNull)
    }
    if (that.defaultValueIsSet && !this.defaultValueIsSet) {
      this.defaultValue_=(that.defaultValueOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Field): Field = {
    val ret = Field.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Field => this.equals(o)
    case _ => false
  }

  def equals(that: Field): Boolean = {
    that != null &&
    (if (this.identifierIsSet) (that.identifierIsSet && this.identifierOrDefault == that.identifierOrDefault) else !that.identifierIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.typeIdIsSet) (that.typeIdIsSet && this.typeIdOrNull == that.typeIdOrNull) else !that.typeIdIsSet) &&
    (if (this.requirednessIsSet) (that.requirednessIsSet && this.requirednessOrNull == that.requirednessOrNull) else !that.requirednessIsSet) &&
    (if (this.defaultValueIsSet) (that.defaultValueIsSet && this.defaultValueOrNull == that.defaultValueOrNull) else !that.defaultValueIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (identifierIsSet) hasher.append(_identifier.##)
    if (nameIsSet) hasher.append(_name.##)
    if (typeIdIsSet) hasher.append(_typeId.##)
    if (requirednessIsSet) hasher.append(_requiredness.##)
    if (defaultValueIsSet) hasher.append(_defaultValue.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (identifierIsSet) ret = identifierOrDefault :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    if (typeIdIsSet) ret = typeIdOrNull :: ret
    if (requirednessIsSet) ret = requirednessOrNull :: ret
    if (defaultValueIsSet) ret = defaultValueOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    identifierUnset()
    nameUnset()
    typeIdUnset()
    requirednessUnset()
    defaultValueUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Field._Fields = id match {
    case 1 => Field._Fields.identifier
    case 2 => Field._Fields.name
    case 3 => Field._Fields.typeId
    case 4 => Field._Fields.requiredness
    case 5 => Field._Fields.defaultValue
    case 99 => Field._Fields.__annotations
    case _ => null
  }

  def isSet(field: Field._Fields): Boolean = field match {
    case Field._Fields.identifier => identifierIsSet
    case Field._Fields.name => nameIsSet
    case Field._Fields.typeId => typeIdIsSet
    case Field._Fields.requiredness => requirednessIsSet
    case Field._Fields.defaultValue => defaultValueIsSet
    case Field._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Field._Fields): AnyRef = field match {
    case Field._Fields.identifier => identifierOrDefault.asInstanceOf[AnyRef]
    case Field._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Field._Fields.typeId => typeIdOrNull.asInstanceOf[AnyRef]
    case Field._Fields.requiredness => requirednessOrNull.asInstanceOf[AnyRef]
    case Field._Fields.defaultValue => defaultValueOrNull.asInstanceOf[AnyRef]
    case Field._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Field._Fields, value: AnyRef) {
    field match {
      case Field._Fields.identifier => identifier_=(value.asInstanceOf[Short])
      case Field._Fields.name => name_=(value.asInstanceOf[String])
      case Field._Fields.typeId => typeId_=(value.asInstanceOf[String])
      case Field._Fields.requiredness => requiredness_=(value.asInstanceOf[com.twitter.thrift.descriptors.Requiredness])
      case Field._Fields.defaultValue => defaultValue_=(value.asInstanceOf[String])
      case Field._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Field.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Field.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field.Raw = {
    val ret = new Field.Raw
    if (identifier != null) ret.identifier_=(identifier)
    if (name != null) ret.name_=(name)
    if (typeId != null) ret.typeId_=(typeId)
    if (requiredness != null) ret.requiredness_=(requiredness)
    if (defaultValue != null) ret.defaultValue_=(defaultValue)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Struct
    extends com.foursquare.recordv2.runtime.MetaRecord[Struct]
    with com.foursquare.recordv2.runtime.RecordProvider[Struct] {
  override def recordName: String = "Struct"


  // Thrift descriptors.
  val STRUCT_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Struct")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val FIELDS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "fields",
      org.apache.thrift.protocol.TType.LIST,
      2,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "fields" -> FIELDS_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object __fields extends _Fields(2, "fields")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.__fields,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Struct.type
  override type Trait = Struct
  override type Mutable = MutableStruct
  override type Raw = RawStruct

  override def createRecord: Struct = createRawRecord
  override def createRawRecord: Struct.Raw = new Struct.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Struct] = {
    if (x.isInstanceOf[Struct]) Some(x.asInstanceOf[Struct]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Struct, Struct.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = Struct,
      getter = _.nameOption,
      setterRaw = (r: Struct.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val __fields =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Struct, Struct.type](
      name = "fields",
      longName = "fields",
      id = 2,
      annotations = Map(),
      owner = Struct,
      getter = _.fieldsOption,
      setterRaw = (r: Struct.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.__fields_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Struct, Struct.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Struct,
      getter = _.annotationsOption,
      setterRaw = (r: Struct.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Struct, Struct.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Struct, Struct.type]](
      name,
      __fields,
      __annotations
    )


  def apply(
      name: String,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Struct = {
    val ret = Struct.createRawRecord
    ret.name_=(name)
    ret.__fields_=(__fields)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasFields

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFields
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Struct] (private var obj: Struct.Raw) {
    def name(v: String): Struct.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Struct.Builder[State with Builder.HasName]]
    }
    def __fields(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Struct.Builder[State with Builder.HasFields] = {
      obj.__fields_=(v)
      this.asInstanceOf[Struct.Builder[State with Builder.HasFields]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Struct.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Struct.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Struct.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Struct.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Struct = resultMutable()(ev0, ev1)
  }

  def newBuilder: Struct.Builder.AllUnspecified = new Builder(Struct.createRawRecord)

  implicit val companionProvider: StructCompanionProvider = new StructCompanionProvider
}

class StructCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Struct] {
  type CompanionT = Struct.type
  override def provide: Struct.type = Struct
}



trait Struct

    extends com.foursquare.recordv2.runtime.Record[Struct]
    with scala.Ordered[Struct]
    with org.apache.thrift.TBase[Struct, Struct._Fields] {

  override type MetaT = Struct.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
  def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Struct): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.fieldsIsSet.compareTo(that.fieldsIsSet)
      cmp != 0 }) cmp
    else if (this.fieldsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__fields.asJava, that.__fields.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Struct

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct

  def mutableCopy(): Struct.Mutable = {
    val ret = Struct.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (fieldsIsSet) ret.__fields_=(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Struct.Mutable

  def toBuilder() = {
    val ret = new Struct.Builder(Struct.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (fieldsIsSet) ret.__fields(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Struct): Struct

}


trait StructProxy extends Struct {
  protected def underlying: Struct

  override def meta: Struct.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.__fields
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.fieldsOption
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrDefault
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrNull
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrThrow
  override def fieldsIsSet: Boolean = underlying.fieldsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Struct): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def mutableCopy(): Struct.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Struct): Struct = underlying.mergeCopy(that)

  override def mutable: Struct.Mutable = underlying.mutable

  override def deepCopy(): Struct = underlying.deepCopy()

  override def fieldForId(id: Int): Struct._Fields = underlying.fieldForId(id)
  override def isSet(field: Struct._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Struct._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Struct._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableStruct extends Struct {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def fieldsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Struct): Unit

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct.Mutable

  override def mutable: Struct.Mutable = this
}

trait MutableStructProxy extends MutableStruct with StructProxy {
  protected def underlying: MutableStruct

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.__fields_=(x) }
  override def fieldsUnset(): Unit = { underlying.fieldsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct.Mutable = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def merge(that: Struct): Unit = underlying.merge(that)
}



final class RawStruct extends MutableStruct {
  override def meta: Struct.type = Struct

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - fields
  private var _fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrDefault
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _fields = x }
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (fieldsIsSet) Some(_fields) else None
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else scala.collection.Seq.empty
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _fields
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else throw new java.lang.NullPointerException
  override def fieldsIsSet: Boolean = _fields != null
  override def fieldsUnset(): Unit = { _fields = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Struct.STRUCT_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Struct.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (fieldsIsSet) {
      oprot.writeFieldBegin(Struct.FIELDS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _fields.size))
      _fields.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Struct.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Struct.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // fields

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _fields = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Struct".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Struct): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.fieldsIsSet && !this.fieldsIsSet) {
      this.__fields_=(that.fieldsOrNull)

    } else if (that.fieldsIsSet && this.fieldsIsSet) {
      this.__fields ++= that.__fields
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Struct): Struct = {
    val ret = Struct.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Struct => this.equals(o)
    case _ => false
  }

  def equals(that: Struct): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.fieldsIsSet) (that.fieldsIsSet && this.fieldsOrNull == that.fieldsOrNull) else !that.fieldsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (fieldsIsSet) hasher.append(_fields.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (fieldsIsSet) ret = fieldsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    fieldsUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Struct._Fields = id match {
    case 1 => Struct._Fields.name
    case 2 => Struct._Fields.__fields
    case 99 => Struct._Fields.__annotations
    case _ => null
  }

  def isSet(field: Struct._Fields): Boolean = field match {
    case Struct._Fields.name => nameIsSet
    case Struct._Fields.__fields => fieldsIsSet
    case Struct._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Struct._Fields): AnyRef = field match {
    case Struct._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Struct._Fields.__fields => fieldsOrNull.asInstanceOf[AnyRef]
    case Struct._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Struct._Fields, value: AnyRef) {
    field match {
      case Struct._Fields.name => name_=(value.asInstanceOf[String])
      case Struct._Fields.__fields => __fields_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Struct._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Struct.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Struct.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct.Raw = {
    val ret = new Struct.Raw
    if (name != null) ret.name_=(name)
    if (__fields != null) ret.__fields_=(__fields)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Union
    extends com.foursquare.recordv2.runtime.MetaRecord[Union]
    with com.foursquare.recordv2.runtime.RecordProvider[Union] {
  override def recordName: String = "Union"


  // Thrift descriptors.
  val UNION_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Union")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val FIELDS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "fields",
      org.apache.thrift.protocol.TType.LIST,
      2,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "fields" -> FIELDS_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object __fields extends _Fields(2, "fields")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.__fields,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Union.type
  override type Trait = Union
  override type Mutable = MutableUnion
  override type Raw = RawUnion

  override def createRecord: Union = createRawRecord
  override def createRawRecord: Union.Raw = new Union.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Union] = {
    if (x.isInstanceOf[Union]) Some(x.asInstanceOf[Union]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Union, Union.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = Union,
      getter = _.nameOption,
      setterRaw = (r: Union.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val __fields =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Union, Union.type](
      name = "fields",
      longName = "fields",
      id = 2,
      annotations = Map(),
      owner = Union,
      getter = _.fieldsOption,
      setterRaw = (r: Union.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.__fields_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Union, Union.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Union,
      getter = _.annotationsOption,
      setterRaw = (r: Union.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Union, Union.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Union, Union.type]](
      name,
      __fields,
      __annotations
    )


  def apply(
      name: String,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Union = {
    val ret = Union.createRawRecord
    ret.name_=(name)
    ret.__fields_=(__fields)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasFields

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFields
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Union] (private var obj: Union.Raw) {
    def name(v: String): Union.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Union.Builder[State with Builder.HasName]]
    }
    def __fields(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Union.Builder[State with Builder.HasFields] = {
      obj.__fields_=(v)
      this.asInstanceOf[Union.Builder[State with Builder.HasFields]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Union.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Union.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Union.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Union.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Union = resultMutable()(ev0, ev1)
  }

  def newBuilder: Union.Builder.AllUnspecified = new Builder(Union.createRawRecord)

  implicit val companionProvider: UnionCompanionProvider = new UnionCompanionProvider
}

class UnionCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Union] {
  type CompanionT = Union.type
  override def provide: Union.type = Union
}



trait Union

    extends com.foursquare.recordv2.runtime.Record[Union]
    with scala.Ordered[Union]
    with org.apache.thrift.TBase[Union, Union._Fields] {

  override type MetaT = Union.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
  def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Union): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.fieldsIsSet.compareTo(that.fieldsIsSet)
      cmp != 0 }) cmp
    else if (this.fieldsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__fields.asJava, that.__fields.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Union

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union

  def mutableCopy(): Union.Mutable = {
    val ret = Union.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (fieldsIsSet) ret.__fields_=(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Union.Mutable

  def toBuilder() = {
    val ret = new Union.Builder(Union.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (fieldsIsSet) ret.__fields(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Union): Union

}


trait UnionProxy extends Union {
  protected def underlying: Union

  override def meta: Union.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.__fields
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.fieldsOption
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrDefault
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrNull
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrThrow
  override def fieldsIsSet: Boolean = underlying.fieldsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Union): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def mutableCopy(): Union.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Union): Union = underlying.mergeCopy(that)

  override def mutable: Union.Mutable = underlying.mutable

  override def deepCopy(): Union = underlying.deepCopy()

  override def fieldForId(id: Int): Union._Fields = underlying.fieldForId(id)
  override def isSet(field: Union._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Union._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Union._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableUnion extends Union {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def fieldsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Union): Unit

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union.Mutable

  override def mutable: Union.Mutable = this
}

trait MutableUnionProxy extends MutableUnion with UnionProxy {
  protected def underlying: MutableUnion

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.__fields_=(x) }
  override def fieldsUnset(): Unit = { underlying.fieldsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union.Mutable = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def merge(that: Union): Unit = underlying.merge(that)
}



final class RawUnion extends MutableUnion {
  override def meta: Union.type = Union

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - fields
  private var _fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrDefault
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _fields = x }
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (fieldsIsSet) Some(_fields) else None
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else scala.collection.Seq.empty
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _fields
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else throw new java.lang.NullPointerException
  override def fieldsIsSet: Boolean = _fields != null
  override def fieldsUnset(): Unit = { _fields = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Union.UNION_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Union.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (fieldsIsSet) {
      oprot.writeFieldBegin(Union.FIELDS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _fields.size))
      _fields.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Union.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Union.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // fields

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _fields = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Union".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Union): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.fieldsIsSet && !this.fieldsIsSet) {
      this.__fields_=(that.fieldsOrNull)

    } else if (that.fieldsIsSet && this.fieldsIsSet) {
      this.__fields ++= that.__fields
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Union): Union = {
    val ret = Union.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Union => this.equals(o)
    case _ => false
  }

  def equals(that: Union): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.fieldsIsSet) (that.fieldsIsSet && this.fieldsOrNull == that.fieldsOrNull) else !that.fieldsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (fieldsIsSet) hasher.append(_fields.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (fieldsIsSet) ret = fieldsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    fieldsUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Union._Fields = id match {
    case 1 => Union._Fields.name
    case 2 => Union._Fields.__fields
    case 99 => Union._Fields.__annotations
    case _ => null
  }

  def isSet(field: Union._Fields): Boolean = field match {
    case Union._Fields.name => nameIsSet
    case Union._Fields.__fields => fieldsIsSet
    case Union._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Union._Fields): AnyRef = field match {
    case Union._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Union._Fields.__fields => fieldsOrNull.asInstanceOf[AnyRef]
    case Union._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Union._Fields, value: AnyRef) {
    field match {
      case Union._Fields.name => name_=(value.asInstanceOf[String])
      case Union._Fields.__fields => __fields_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Union._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Union.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Union.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union.Raw = {
    val ret = new Union.Raw
    if (name != null) ret.name_=(name)
    if (__fields != null) ret.__fields_=(__fields)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Exception
    extends com.foursquare.recordv2.runtime.MetaRecord[Exception]
    with com.foursquare.recordv2.runtime.RecordProvider[Exception] {
  override def recordName: String = "Exception"


  // Thrift descriptors.
  val EXCEPTION_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Exception")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val FIELDS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "fields",
      org.apache.thrift.protocol.TType.LIST,
      2,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "fields" -> FIELDS_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object __fields extends _Fields(2, "fields")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.__fields,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Exception.type
  override type Trait = Exception
  override type Mutable = MutableException
  override type Raw = RawException

  override def createRecord: Exception = createRawRecord
  override def createRawRecord: Exception.Raw = new Exception.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Exception] = {
    if (x.isInstanceOf[Exception]) Some(x.asInstanceOf[Exception]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Exception, Exception.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = Exception,
      getter = _.nameOption,
      setterRaw = (r: Exception.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val __fields =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Exception, Exception.type](
      name = "fields",
      longName = "fields",
      id = 2,
      annotations = Map(),
      owner = Exception,
      getter = _.fieldsOption,
      setterRaw = (r: Exception.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.__fields_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Exception, Exception.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Exception,
      getter = _.annotationsOption,
      setterRaw = (r: Exception.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Exception, Exception.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Exception, Exception.type]](
      name,
      __fields,
      __annotations
    )


  def apply(
      name: String,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Exception = {
    val ret = Exception.createRawRecord
    ret.name_=(name)
    ret.__fields_=(__fields)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasFields

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFields
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Exception] (private var obj: Exception.Raw) {
    def name(v: String): Exception.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Exception.Builder[State with Builder.HasName]]
    }
    def __fields(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Exception.Builder[State with Builder.HasFields] = {
      obj.__fields_=(v)
      this.asInstanceOf[Exception.Builder[State with Builder.HasFields]]
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Exception.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Exception.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Exception.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Exception.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Exception = resultMutable()(ev0, ev1)
  }

  def newBuilder: Exception.Builder.AllUnspecified = new Builder(Exception.createRawRecord)

  implicit val companionProvider: ExceptionCompanionProvider = new ExceptionCompanionProvider
}

class ExceptionCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Exception] {
  type CompanionT = Exception.type
  override def provide: Exception.type = Exception
}



trait Exception

    extends com.foursquare.recordv2.runtime.Record[Exception]
    with scala.Ordered[Exception]
    with org.apache.thrift.TBase[Exception, Exception._Fields] {

  override type MetaT = Exception.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
  def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def fieldsIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Exception): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.fieldsIsSet.compareTo(that.fieldsIsSet)
      cmp != 0 }) cmp
    else if (this.fieldsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__fields.asJava, that.__fields.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Exception

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception

  def mutableCopy(): Exception.Mutable = {
    val ret = Exception.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (fieldsIsSet) ret.__fields_=(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Exception.Mutable

  def toBuilder() = {
    val ret = new Exception.Builder(Exception.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (fieldsIsSet) ret.__fields(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Exception): Exception

}


trait ExceptionProxy extends Exception {
  protected def underlying: Exception

  override def meta: Exception.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.__fields
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.fieldsOption
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrDefault
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrNull
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrThrow
  override def fieldsIsSet: Boolean = underlying.fieldsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Exception): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def mutableCopy(): Exception.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Exception): Exception = underlying.mergeCopy(that)

  override def mutable: Exception.Mutable = underlying.mutable

  override def deepCopy(): Exception = underlying.deepCopy()

  override def fieldForId(id: Int): Exception._Fields = underlying.fieldForId(id)
  override def isSet(field: Exception._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Exception._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Exception._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableException extends Exception {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def fieldsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Exception): Unit

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception.Mutable

  override def mutable: Exception.Mutable = this
}

trait MutableExceptionProxy extends MutableException with ExceptionProxy {
  protected def underlying: MutableException

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.__fields_=(x) }
  override def fieldsUnset(): Unit = { underlying.fieldsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception.Mutable = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def merge(that: Exception): Unit = underlying.merge(that)
}



final class RawException extends MutableException {
  override def meta: Exception.type = Exception

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - fields
  private var _fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrDefault
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _fields = x }
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (fieldsIsSet) Some(_fields) else None
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else scala.collection.Seq.empty
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _fields
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else throw new java.lang.NullPointerException
  override def fieldsIsSet: Boolean = _fields != null
  override def fieldsUnset(): Unit = { _fields = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Exception.EXCEPTION_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Exception.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (fieldsIsSet) {
      oprot.writeFieldBegin(Exception.FIELDS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _fields.size))
      _fields.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Exception.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Exception.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // fields

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _fields = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Exception".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Exception): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.fieldsIsSet && !this.fieldsIsSet) {
      this.__fields_=(that.fieldsOrNull)

    } else if (that.fieldsIsSet && this.fieldsIsSet) {
      this.__fields ++= that.__fields
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Exception): Exception = {
    val ret = Exception.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Exception => this.equals(o)
    case _ => false
  }

  def equals(that: Exception): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.fieldsIsSet) (that.fieldsIsSet && this.fieldsOrNull == that.fieldsOrNull) else !that.fieldsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (fieldsIsSet) hasher.append(_fields.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (fieldsIsSet) ret = fieldsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    fieldsUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Exception._Fields = id match {
    case 1 => Exception._Fields.name
    case 2 => Exception._Fields.__fields
    case 99 => Exception._Fields.__annotations
    case _ => null
  }

  def isSet(field: Exception._Fields): Boolean = field match {
    case Exception._Fields.name => nameIsSet
    case Exception._Fields.__fields => fieldsIsSet
    case Exception._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Exception._Fields): AnyRef = field match {
    case Exception._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Exception._Fields.__fields => fieldsOrNull.asInstanceOf[AnyRef]
    case Exception._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Exception._Fields, value: AnyRef) {
    field match {
      case Exception._Fields.name => name_=(value.asInstanceOf[String])
      case Exception._Fields.__fields => __fields_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Exception._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Exception.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Exception.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception.Raw = {
    val ret = new Exception.Raw
    if (name != null) ret.name_=(name)
    if (__fields != null) ret.__fields_=(__fields)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Function
    extends com.foursquare.recordv2.runtime.MetaRecord[Function]
    with com.foursquare.recordv2.runtime.RecordProvider[Function] {
  override def recordName: String = "Function"


  // Thrift descriptors.
  val FUNCTION_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Function")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val RETURNTYPEID_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "returnTypeId",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )
  val ONEWAY_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "oneWay",
      org.apache.thrift.protocol.TType.BOOL,
      3,
      Map[String, String]().asJava
    )
  val ARGZ_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "argz",
      org.apache.thrift.protocol.TType.LIST,
      4,
      Map[String, String]().asJava
    )
  val THROWZ_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "throwz",
      org.apache.thrift.protocol.TType.LIST,
      5,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "returnTypeId" -> RETURNTYPEID_DESC,
    "oneWay" -> ONEWAY_DESC,
    "argz" -> ARGZ_DESC,
    "throwz" -> THROWZ_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object returnTypeId extends _Fields(2, "returnTypeId")
    case object oneWay extends _Fields(3, "oneWay")
    case object argz extends _Fields(4, "argz")
    case object throwz extends _Fields(5, "throwz")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.returnTypeId,
    3.toShort -> _Fields.oneWay,
    4.toShort -> _Fields.argz,
    5.toShort -> _Fields.throwz,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Function.type
  override type Trait = Function
  override type Mutable = MutableFunction
  override type Raw = RawFunction

  override def createRecord: Function = createRawRecord
  override def createRawRecord: Function.Raw = new Function.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Function] = {
    if (x.isInstanceOf[Function]) Some(x.asInstanceOf[Function]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Function, Function.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = Function,
      getter = _.nameOption,
      setterRaw = (r: Function.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val returnTypeId =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Function, Function.type](
      name = "returnTypeId",
      longName = "returnTypeId",
      id = 2,
      annotations = Map(),
      owner = Function,
      getter = _.returnTypeIdOption,
      setterRaw = (r: Function.Raw, v: String) => { r.returnTypeId_=(v) },
      manifest = manifest[String]
    )

  val oneWay =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[Boolean, Function, Function.type](
      name = "oneWay",
      longName = "oneWay",
      id = 3,
      annotations = Map(),
      owner = Function,
      getter = _.oneWayOption,
      setterRaw = (r: Function.Raw, v: Boolean) => { r.oneWay_=(v) },
      manifest = manifest[Boolean]
    )

  val argz =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Function, Function.type](
      name = "argz",
      longName = "argz",
      id = 4,
      annotations = Map(),
      owner = Function,
      getter = _.argzOption,
      setterRaw = (r: Function.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.argz_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val throwz =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Function, Function.type](
      name = "throwz",
      longName = "throwz",
      id = 5,
      annotations = Map(),
      owner = Function,
      getter = _.throwzOption,
      setterRaw = (r: Function.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.throwz_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Function, Function.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Function,
      getter = _.annotationsOption,
      setterRaw = (r: Function.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Function, Function.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Function, Function.type]](
      name,
      returnTypeId,
      oneWay,
      argz,
      throwz,
      __annotations
    )


  def apply(
      name: String,
      returnTypeId: String,
      oneWay: Boolean,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Function = {
    val ret = Function.createRawRecord
    ret.name_=(name)
    ret.returnTypeId_=(returnTypeId)
    ret.oneWay_=(oneWay)
    ret.argz_=(argz)
    ret.throwz_=(throwz)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasArgz
    sealed trait HasThrowz

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasArgz with HasThrowz
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Function] (private var obj: Function.Raw) {
    def name(v: String): Function.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Function.Builder[State with Builder.HasName]]
    }
    def argz(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Function.Builder[State with Builder.HasArgz] = {
      obj.argz_=(v)
      this.asInstanceOf[Function.Builder[State with Builder.HasArgz]]
    }
    def throwz(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Function.Builder[State with Builder.HasThrowz] = {
      obj.throwz_=(v)
      this.asInstanceOf[Function.Builder[State with Builder.HasThrowz]]
    }

    def returnTypeId(v: String): Function.Builder[State] = {
      obj.returnTypeId_=(v)
      this
    }

    def returnTypeId(vOpt: Option[String]): Function.Builder[State] = {
      vOpt match {
        case Some(v) => obj.returnTypeId_=(v)
        case None => obj.returnTypeIdUnset()
      }
      this
    }

    def oneWay(v: Boolean): Function.Builder[State] = {
      obj.oneWay_=(v)
      this
    }

    def oneWay(vOpt: Option[Boolean]): Function.Builder[State] = {
      vOpt match {
        case Some(v) => obj.oneWay_=(v)
        case None => obj.oneWayUnset()
      }
      this
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Function.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Function.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasArgz, ev2: State <:< Builder.HasThrowz): Function.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Function.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasArgz, ev2: State <:< Builder.HasThrowz): Function = resultMutable()(ev0, ev1, ev2)
  }

  def newBuilder: Function.Builder.AllUnspecified = new Builder(Function.createRawRecord)

  implicit val companionProvider: FunctionCompanionProvider = new FunctionCompanionProvider
}

class FunctionCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Function] {
  type CompanionT = Function.type
  override def provide: Function.type = Function
}



trait Function

    extends com.foursquare.recordv2.runtime.Record[Function]
    with scala.Ordered[Function]
    with org.apache.thrift.TBase[Function, Function._Fields] {

  override type MetaT = Function.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def returnTypeIdOption: Option[String]
  def returnTypeIdOrNull: String
  def returnTypeIdOrThrow: String
  def returnTypeIdIsSet: Boolean
  def oneWay: Boolean
  def oneWayOption: Option[Boolean]
  def oneWayOrDefault: Boolean
  def oneWayOrNull: java.lang.Boolean
  def oneWayOrThrow: Boolean
  def oneWayIsSet: Boolean
  def argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def argzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
  def argzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def argzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def argzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def argzIsSet: Boolean
  def throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def throwzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
  def throwzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def throwzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def throwzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  def throwzIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Function): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.returnTypeIdIsSet.compareTo(that.returnTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.returnTypeIdIsSet && {
      cmp = this.returnTypeIdOrNull.compareTo(that.returnTypeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.oneWayIsSet.compareTo(that.oneWayIsSet)
      cmp != 0 }) cmp
    else if (this.oneWayIsSet && {
      cmp = this.oneWay.compareTo(that.oneWay)
      cmp != 0 }) cmp
    else if ({
      cmp = this.argzIsSet.compareTo(that.argzIsSet)
      cmp != 0 }) cmp
    else if (this.argzIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.argz.asJava, that.argz.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.throwzIsSet.compareTo(that.throwzIsSet)
      cmp != 0 }) cmp
    else if (this.throwzIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.throwz.asJava, that.throwz.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Function

  def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function

  def mutableCopy(): Function.Mutable = {
    val ret = Function.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (returnTypeIdIsSet) ret.returnTypeId_=(returnTypeIdOrNull)

    if (oneWayIsSet) ret.oneWay_=(oneWayOrDefault)

    if (argzIsSet) ret.argz_=(argzOrNull)

    if (throwzIsSet) ret.throwz_=(throwzOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Function.Mutable

  def toBuilder() = {
    val ret = new Function.Builder(Function.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (returnTypeIdIsSet) ret.returnTypeId(returnTypeIdOrNull)

    if (oneWayIsSet) ret.oneWay(oneWayOrDefault)

    if (argzIsSet) ret.argz(argzOrNull)

    if (throwzIsSet) ret.throwz(throwzOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Function): Function

}


trait FunctionProxy extends Function {
  protected def underlying: Function

  override def meta: Function.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp
  override def returnTypeIdOption: Option[String] = underlying.returnTypeIdOption
  override def returnTypeIdOrNull: String = underlying.returnTypeIdOrNull
  override def returnTypeIdOrThrow: String = underlying.returnTypeIdOrThrow
  override def returnTypeIdIsSet: Boolean = underlying.returnTypeIdIsSet
// field/proxy_primitive.ssp
  override def oneWay: Boolean = underlying.oneWay
  override def oneWayOption: Option[Boolean] = underlying.oneWayOption
  override def oneWayOrDefault: Boolean = underlying.oneWayOrDefault
  override def oneWayOrNull: java.lang.Boolean = underlying.oneWayOrNull
  override def oneWayOrThrow: Boolean = underlying.oneWayOrThrow
  override def oneWayIsSet: Boolean = underlying.oneWayIsSet
// field/proxy_container.ssp
  override def argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argz
  override def argzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.argzOption
  override def argzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argzOrDefault
  override def argzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argzOrNull
  override def argzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argzOrThrow
  override def argzIsSet: Boolean = underlying.argzIsSet
// field/proxy_container.ssp
  override def throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwz
  override def throwzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.throwzOption
  override def throwzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwzOrDefault
  override def throwzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwzOrNull
  override def throwzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwzOrThrow
  override def throwzIsSet: Boolean = underlying.throwzIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Function): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function = underlying.copy(
    name = name,
    returnTypeId = returnTypeId,
    oneWay = oneWay,
    argz = argz,
    throwz = throwz,
    __annotations = __annotations
  )

  override def mutableCopy(): Function.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Function): Function = underlying.mergeCopy(that)

  override def mutable: Function.Mutable = underlying.mutable

  override def deepCopy(): Function = underlying.deepCopy()

  override def fieldForId(id: Int): Function._Fields = underlying.fieldForId(id)
  override def isSet(field: Function._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Function._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Function._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableFunction extends Function {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def returnTypeId_=(x: String): Unit
  def returnTypeIdUnset(): Unit
  def oneWay_=(x: Boolean): Unit
  def oneWayUnset(): Unit
  def argz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def argzUnset(): Unit
  def throwz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def throwzUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Function): Unit

  def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function.Mutable

  override def mutable: Function.Mutable = this
}

trait MutableFunctionProxy extends MutableFunction with FunctionProxy {
  protected def underlying: MutableFunction

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def returnTypeId_=(x: String): Unit = { underlying.returnTypeId_=(x) }
  override def returnTypeIdUnset(): Unit = { underlying.returnTypeIdUnset() }
  override def oneWay_=(x: Boolean): Unit = { underlying.oneWay_=(x) }
  override def oneWayUnset(): Unit = { underlying.oneWayUnset() }
  override def argz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.argz_=(x) }
  override def argzUnset(): Unit = { underlying.argzUnset() }
  override def throwz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.throwz_=(x) }
  override def throwzUnset(): Unit = { underlying.throwzUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function.Mutable = underlying.copy(
    name = name,
    returnTypeId = returnTypeId,
    oneWay = oneWay,
    argz = argz,
    throwz = throwz,
    __annotations = __annotations
  )

  override def merge(that: Function): Unit = underlying.merge(that)
}



final class RawFunction extends MutableFunction {
  override def meta: Function.type = Function

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - returnTypeId
  private var _returnTypeId: String = null  // Underlying type: String
  override def returnTypeId_=(x: String): Unit = { _returnTypeId = x }
  override def returnTypeIdOption: Option[String] = if (returnTypeIdIsSet) Some(_returnTypeId) else None
  override def returnTypeIdOrNull: String = _returnTypeId
  override def returnTypeIdOrThrow: String = if (returnTypeIdIsSet) _returnTypeId else throw new java.lang.NullPointerException
  override def returnTypeIdIsSet: Boolean = _returnTypeId != null
  override def returnTypeIdUnset(): Unit = { _returnTypeId = null }
  // Field #3 - oneWay
  private var _oneWay: Boolean = false  // Underlying type: Boolean
  private var _oneWayIsSet: Boolean = false
  override def oneWay: Boolean = oneWayOrDefault
  override def oneWay_=(x: Boolean): Unit = { _oneWay = x ; _oneWayIsSet = true }
  override def oneWayOption: Option[Boolean] = if (oneWayIsSet) Some(_oneWay) else None
  override def oneWayOrDefault: Boolean = _oneWay
  override def oneWayOrNull: java.lang.Boolean = if (oneWayIsSet) _oneWay else null
  override def oneWayOrThrow: Boolean = if (oneWayIsSet) _oneWay else throw new java.lang.NullPointerException
  override def oneWayIsSet: Boolean = _oneWayIsSet
  override def oneWayUnset(): Unit = { _oneWayIsSet = false; _oneWay = false }
  // Field #4 - argz
  private var _argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrDefault
  override def argz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _argz = x }
  override def argzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (argzIsSet) Some(_argz) else None
  override def argzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (argzIsSet) _argz else scala.collection.Seq.empty
  override def argzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _argz
  override def argzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (argzIsSet) _argz else throw new java.lang.NullPointerException
  override def argzIsSet: Boolean = _argz != null
  override def argzUnset(): Unit = { _argz = null }
  // Field #5 - throwz
  private var _throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrDefault
  override def throwz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _throwz = x }
  override def throwzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (throwzIsSet) Some(_throwz) else None
  override def throwzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (throwzIsSet) _throwz else scala.collection.Seq.empty
  override def throwzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _throwz
  override def throwzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (throwzIsSet) _throwz else throw new java.lang.NullPointerException
  override def throwzIsSet: Boolean = _throwz != null
  override def throwzUnset(): Unit = { _throwz = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Function.FUNCTION_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Function.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (returnTypeIdIsSet) {
      oprot.writeFieldBegin(Function.RETURNTYPEID_DESC)
      oprot.writeString(_returnTypeId)
      oprot.writeFieldEnd()
    }
    if (oneWayIsSet) {
      oprot.writeFieldBegin(Function.ONEWAY_DESC)
      oprot.writeBool(_oneWay)
      oprot.writeFieldEnd()
    }
    if (argzIsSet) {
      oprot.writeFieldBegin(Function.ARGZ_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _argz.size))
      _argz.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (throwzIsSet) {
      oprot.writeFieldBegin(Function.THROWZ_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _throwz.size))
      _throwz.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Function.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Function.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // returnTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _returnTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // oneWay

            if (field_header.`type` == org.apache.thrift.protocol.TType.BOOL) {
              _oneWay = iprot.readBool()

              _oneWayIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // argz

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _argz = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // throwz

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _throwz = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Function".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Function): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.returnTypeIdIsSet && !this.returnTypeIdIsSet) {
      this.returnTypeId_=(that.returnTypeIdOrNull)
    }
    if (that.oneWayIsSet && !this.oneWayIsSet) {
      this.oneWay_=(that.oneWayOrDefault)
    }
    if (that.argzIsSet && !this.argzIsSet) {
      this.argz_=(that.argzOrNull)

    } else if (that.argzIsSet && this.argzIsSet) {
      this.argz ++= that.argz
    }
    if (that.throwzIsSet && !this.throwzIsSet) {
      this.throwz_=(that.throwzOrNull)

    } else if (that.throwzIsSet && this.throwzIsSet) {
      this.throwz ++= that.throwz
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Function): Function = {
    val ret = Function.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Function => this.equals(o)
    case _ => false
  }

  def equals(that: Function): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.returnTypeIdIsSet) (that.returnTypeIdIsSet && this.returnTypeIdOrNull == that.returnTypeIdOrNull) else !that.returnTypeIdIsSet) &&
    (if (this.oneWayIsSet) (that.oneWayIsSet && this.oneWayOrDefault == that.oneWayOrDefault) else !that.oneWayIsSet) &&
    (if (this.argzIsSet) (that.argzIsSet && this.argzOrNull == that.argzOrNull) else !that.argzIsSet) &&
    (if (this.throwzIsSet) (that.throwzIsSet && this.throwzOrNull == that.throwzOrNull) else !that.throwzIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (returnTypeIdIsSet) hasher.append(_returnTypeId.##)
    if (oneWayIsSet) hasher.append(_oneWay.##)
    if (argzIsSet) hasher.append(_argz.##)
    if (throwzIsSet) hasher.append(_throwz.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (returnTypeIdIsSet) ret = returnTypeIdOrNull :: ret
    if (oneWayIsSet) ret = oneWayOrDefault :: ret
    if (argzIsSet) ret = argzOrNull :: ret
    if (throwzIsSet) ret = throwzOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    returnTypeIdUnset()
    oneWayUnset()
    argzUnset()
    throwzUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Function._Fields = id match {
    case 1 => Function._Fields.name
    case 2 => Function._Fields.returnTypeId
    case 3 => Function._Fields.oneWay
    case 4 => Function._Fields.argz
    case 5 => Function._Fields.throwz
    case 99 => Function._Fields.__annotations
    case _ => null
  }

  def isSet(field: Function._Fields): Boolean = field match {
    case Function._Fields.name => nameIsSet
    case Function._Fields.returnTypeId => returnTypeIdIsSet
    case Function._Fields.oneWay => oneWayIsSet
    case Function._Fields.argz => argzIsSet
    case Function._Fields.throwz => throwzIsSet
    case Function._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Function._Fields): AnyRef = field match {
    case Function._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Function._Fields.returnTypeId => returnTypeIdOrNull.asInstanceOf[AnyRef]
    case Function._Fields.oneWay => oneWayOrDefault.asInstanceOf[AnyRef]
    case Function._Fields.argz => argzOrNull.asInstanceOf[AnyRef]
    case Function._Fields.throwz => throwzOrNull.asInstanceOf[AnyRef]
    case Function._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Function._Fields, value: AnyRef) {
    field match {
      case Function._Fields.name => name_=(value.asInstanceOf[String])
      case Function._Fields.returnTypeId => returnTypeId_=(value.asInstanceOf[String])
      case Function._Fields.oneWay => oneWay_=(value.asInstanceOf[Boolean])
      case Function._Fields.argz => argz_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Function._Fields.throwz => throwz_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Function._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Function.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Function.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function.Raw = {
    val ret = new Function.Raw
    if (name != null) ret.name_=(name)
    if (returnTypeId != null) ret.returnTypeId_=(returnTypeId)
    if (oneWay != null) ret.oneWay_=(oneWay)
    if (argz != null) ret.argz_=(argz)
    if (throwz != null) ret.throwz_=(throwz)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Service
    extends com.foursquare.recordv2.runtime.MetaRecord[Service]
    with com.foursquare.recordv2.runtime.RecordProvider[Service] {
  override def recordName: String = "Service"


  // Thrift descriptors.
  val SERVICE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Service")

  val NAME_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      Map[String, String]().asJava
    )
  val EXTENDZ_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "extendz",
      org.apache.thrift.protocol.TType.STRING,
      2,
      Map[String, String]().asJava
    )
  val FUNCTIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "functions",
      org.apache.thrift.protocol.TType.LIST,
      3,
      Map[String, String]().asJava
    )
  val ANNOTATIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_DESC,
    "extendz" -> EXTENDZ_DESC,
    "functions" -> FUNCTIONS_DESC,
    "annotations" -> ANNOTATIONS_DESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object extendz extends _Fields(2, "extendz")
    case object functions extends _Fields(3, "functions")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.extendz,
    3.toShort -> _Fields.functions,
    99.toShort -> _Fields.__annotations
  )

  // Record v2
  override type Self = Service.type
  override type Trait = Service
  override type Mutable = MutableService
  override type Raw = RawService

  override def createRecord: Service = createRawRecord
  override def createRawRecord: Service.Raw = new Service.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Service] = {
    if (x.isInstanceOf[Service]) Some(x.asInstanceOf[Service]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val name =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Service, Service.type](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = Service,
      getter = _.nameOption,
      setterRaw = (r: Service.Raw, v: String) => { r.name_=(v) },
      manifest = manifest[String]
    )

  val extendz =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[String, Service, Service.type](
      name = "extendz",
      longName = "extendz",
      id = 2,
      annotations = Map(),
      owner = Service,
      getter = _.extendzOption,
      setterRaw = (r: Service.Raw, v: String) => { r.extendz_=(v) },
      manifest = manifest[String]
    )

  val functions =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Function], Service, Service.type](
      name = "functions",
      longName = "functions",
      id = 3,
      annotations = Map(),
      owner = Service,
      getter = _.functionsOption,
      setterRaw = (r: Service.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Function]) => { r.functions_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Function]]
    )

  val __annotations =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Service, Service.type](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = Service,
      getter = _.annotationsOption,
      setterRaw = (r: Service.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.__annotations_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Service, Service.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Service, Service.type]](
      name,
      extendz,
      functions,
      __annotations
    )


  def apply(
      name: String,
      extendz: String,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Service = {
    val ret = Service.createRawRecord
    ret.name_=(name)
    ret.extendz_=(extendz)
    ret.functions_=(functions)
    ret.__annotations_=(__annotations)
    ret
  }



  object Builder {
    sealed trait HasName
    sealed trait HasFunctions

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFunctions
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Service] (private var obj: Service.Raw) {
    def name(v: String): Service.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Service.Builder[State with Builder.HasName]]
    }
    def functions(v: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Service.Builder[State with Builder.HasFunctions] = {
      obj.functions_=(v)
      this.asInstanceOf[Service.Builder[State with Builder.HasFunctions]]
    }

    def extendz(v: String): Service.Builder[State] = {
      obj.extendz_=(v)
      this
    }

    def extendz(vOpt: Option[String]): Service.Builder[State] = {
      vOpt match {
        case Some(v) => obj.extendz_=(v)
        case None => obj.extendzUnset()
      }
      this
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Service.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Service.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFunctions): Service.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Service.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFunctions): Service = resultMutable()(ev0, ev1)
  }

  def newBuilder: Service.Builder.AllUnspecified = new Builder(Service.createRawRecord)

  implicit val companionProvider: ServiceCompanionProvider = new ServiceCompanionProvider
}

class ServiceCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Service] {
  type CompanionT = Service.type
  override def provide: Service.type = Service
}



trait Service

    extends com.foursquare.recordv2.runtime.Record[Service]
    with scala.Ordered[Service]
    with org.apache.thrift.TBase[Service, Service._Fields] {

  override type MetaT = Service.type


  def name: String
  def nameOption: Option[String]
  def nameOrNull: String
  def nameOrThrow: String
  def nameIsSet: Boolean
  def extendzOption: Option[String]
  def extendzOrNull: String
  def extendzOrThrow: String
  def extendzIsSet: Boolean
  def functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function]
  def functionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Function]]
  def functionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Function]
  def functionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Function]
  def functionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Function]
  def functionsIsSet: Boolean
  def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
  def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  def annotationsIsSet: Boolean
  override def compare(that: Service): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.extendzIsSet.compareTo(that.extendzIsSet)
      cmp != 0 }) cmp
    else if (this.extendzIsSet && {
      cmp = this.extendzOrNull.compareTo(that.extendzOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.functionsIsSet.compareTo(that.functionsIsSet)
      cmp != 0 }) cmp
    else if (this.functionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.functions.asJava, that.functions.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.__annotations.asJava, that.__annotations.asJava)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Service

  def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service

  def mutableCopy(): Service.Mutable = {
    val ret = Service.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (extendzIsSet) ret.extendz_=(extendzOrNull)

    if (functionsIsSet) ret.functions_=(functionsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Service.Mutable

  def toBuilder() = {
    val ret = new Service.Builder(Service.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (extendzIsSet) ret.extendz(extendzOrNull)

    if (functionsIsSet) ret.functions(functionsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Service): Service

}


trait ServiceProxy extends Service {
  protected def underlying: Service

  override def meta: Service.type = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp
  override def extendzOption: Option[String] = underlying.extendzOption
  override def extendzOrNull: String = underlying.extendzOrNull
  override def extendzOrThrow: String = underlying.extendzOrThrow
  override def extendzIsSet: Boolean = underlying.extendzIsSet
// field/proxy_container.ssp
  override def functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functions
  override def functionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Function]] = underlying.functionsOption
  override def functionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functionsOrDefault
  override def functionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functionsOrNull
  override def functionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functionsOrThrow
  override def functionsIsSet: Boolean = underlying.functionsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Service): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service = underlying.copy(
    name = name,
    extendz = extendz,
    functions = functions,
    __annotations = __annotations
  )

  override def mutableCopy(): Service.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Service): Service = underlying.mergeCopy(that)

  override def mutable: Service.Mutable = underlying.mutable

  override def deepCopy(): Service = underlying.deepCopy()

  override def fieldForId(id: Int): Service._Fields = underlying.fieldForId(id)
  override def isSet(field: Service._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Service._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Service._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableService extends Service {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def extendz_=(x: String): Unit
  def extendzUnset(): Unit
  def functions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Unit
  def functionsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Service): Unit

  def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service.Mutable

  override def mutable: Service.Mutable = this
}

trait MutableServiceProxy extends MutableService with ServiceProxy {
  protected def underlying: MutableService

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def extendz_=(x: String): Unit = { underlying.extendz_=(x) }
  override def extendzUnset(): Unit = { underlying.extendzUnset() }
  override def functions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Unit = { underlying.functions_=(x) }
  override def functionsUnset(): Unit = { underlying.functionsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service.Mutable = underlying.copy(
    name = name,
    extendz = extendz,
    functions = functions,
    __annotations = __annotations
  )

  override def merge(that: Service): Unit = underlying.merge(that)
}



final class RawService extends MutableService {
  override def meta: Service.type = Service

  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - extendz
  private var _extendz: String = null  // Underlying type: String
  override def extendz_=(x: String): Unit = { _extendz = x }
  override def extendzOption: Option[String] = if (extendzIsSet) Some(_extendz) else None
  override def extendzOrNull: String = _extendz
  override def extendzOrThrow: String = if (extendzIsSet) _extendz else throw new java.lang.NullPointerException
  override def extendzIsSet: Boolean = _extendz != null
  override def extendzUnset(): Unit = { _extendz = null }
  // Field #3 - functions
  private var _functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Function]
  override def functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrDefault
  override def functions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Unit = { _functions = x }
  override def functionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Function]] = if (functionsIsSet) Some(_functions) else None
  override def functionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = if (functionsIsSet) _functions else scala.collection.Seq.empty
  override def functionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = _functions
  override def functionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = if (functionsIsSet) _functions else throw new java.lang.NullPointerException
  override def functionsIsSet: Boolean = _functions != null
  override def functionsUnset(): Unit = { _functions = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Service.SERVICE_DESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Service.NAME_DESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (extendzIsSet) {
      oprot.writeFieldBegin(Service.EXTENDZ_DESC)
      oprot.writeString(_extendz)
      oprot.writeFieldEnd()
    }
    if (functionsIsSet) {
      oprot.writeFieldBegin(Service.FUNCTIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _functions.size))
      _functions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Service.ANNOTATIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Service.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // extendz

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _extendz = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // functions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _functions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Function]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Function.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Service".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Service): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.extendzIsSet && !this.extendzIsSet) {
      this.extendz_=(that.extendzOrNull)
    }
    if (that.functionsIsSet && !this.functionsIsSet) {
      this.functions_=(that.functionsOrNull)

    } else if (that.functionsIsSet && this.functionsIsSet) {
      this.functions ++= that.functions
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations ++= that.__annotations
    }
  }

  override def mergeCopy(that: Service): Service = {
    val ret = Service.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Service => this.equals(o)
    case _ => false
  }

  def equals(that: Service): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.extendzIsSet) (that.extendzIsSet && this.extendzOrNull == that.extendzOrNull) else !that.extendzIsSet) &&
    (if (this.functionsIsSet) (that.functionsIsSet && this.functionsOrNull == that.functionsOrNull) else !that.functionsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (nameIsSet) hasher.append(_name.##)
    if (extendzIsSet) hasher.append(_extendz.##)
    if (functionsIsSet) hasher.append(_functions.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (extendzIsSet) ret = extendzOrNull :: ret
    if (functionsIsSet) ret = functionsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    extendzUnset()
    functionsUnset()
    annotationsUnset()
  }

  def fieldForId(id: Int): Service._Fields = id match {
    case 1 => Service._Fields.name
    case 2 => Service._Fields.extendz
    case 3 => Service._Fields.functions
    case 99 => Service._Fields.__annotations
    case _ => null
  }

  def isSet(field: Service._Fields): Boolean = field match {
    case Service._Fields.name => nameIsSet
    case Service._Fields.extendz => extendzIsSet
    case Service._Fields.functions => functionsIsSet
    case Service._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Service._Fields): AnyRef = field match {
    case Service._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Service._Fields.extendz => extendzOrNull.asInstanceOf[AnyRef]
    case Service._Fields.functions => functionsOrNull.asInstanceOf[AnyRef]
    case Service._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Service._Fields, value: AnyRef) {
    field match {
      case Service._Fields.name => name_=(value.asInstanceOf[String])
      case Service._Fields.extendz => extendz_=(value.asInstanceOf[String])
      case Service._Fields.functions => functions_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Function]])
      case Service._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): Service.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Service.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service.Raw = {
    val ret = new Service.Raw
    if (name != null) ret.name_=(name)
    if (extendz != null) ret.extendz_=(extendz)
    if (functions != null) ret.functions_=(functions)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Program
    extends com.foursquare.recordv2.runtime.MetaRecord[Program]
    with com.foursquare.recordv2.runtime.RecordProvider[Program] {
  override def recordName: String = "Program"


  // Thrift descriptors.
  val PROGRAM_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Program")

  val NAMESPACES_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "namespaces",
      org.apache.thrift.protocol.TType.LIST,
      1,
      Map[String, String]().asJava
    )
  val INCLUDES_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "includes",
      org.apache.thrift.protocol.TType.LIST,
      2,
      Map[String, String]().asJava
    )
  val CONSTANTS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "constants",
      org.apache.thrift.protocol.TType.LIST,
      3,
      Map[String, String]().asJava
    )
  val ENUMS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "enums",
      org.apache.thrift.protocol.TType.LIST,
      4,
      Map[String, String]().asJava
    )
  val TYPEDEFS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typedefs",
      org.apache.thrift.protocol.TType.LIST,
      5,
      Map[String, String]().asJava
    )
  val STRUCTS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "structs",
      org.apache.thrift.protocol.TType.LIST,
      6,
      Map[String, String]().asJava
    )
  val UNIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "unions",
      org.apache.thrift.protocol.TType.LIST,
      7,
      Map[String, String]().asJava
    )
  val EXCEPTIONS_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "exceptions",
      org.apache.thrift.protocol.TType.LIST,
      8,
      Map[String, String]().asJava
    )
  val SERVICES_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "services",
      org.apache.thrift.protocol.TType.LIST,
      9,
      Map[String, String]().asJava
    )
  val TYPEREGISTRY_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeRegistry",
      org.apache.thrift.protocol.TType.STRUCT,
      98,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "namespaces" -> NAMESPACES_DESC,
    "includes" -> INCLUDES_DESC,
    "constants" -> CONSTANTS_DESC,
    "enums" -> ENUMS_DESC,
    "typedefs" -> TYPEDEFS_DESC,
    "structs" -> STRUCTS_DESC,
    "unions" -> UNIONS_DESC,
    "exceptions" -> EXCEPTIONS_DESC,
    "services" -> SERVICES_DESC,
    "typeRegistry" -> TYPEREGISTRY_DESC
  )

  object _Fields {
    case object namespaces extends _Fields(1, "namespaces")
    case object includes extends _Fields(2, "includes")
    case object constants extends _Fields(3, "constants")
    case object enums extends _Fields(4, "enums")
    case object typedefs extends _Fields(5, "typedefs")
    case object structs extends _Fields(6, "structs")
    case object unions extends _Fields(7, "unions")
    case object exceptions extends _Fields(8, "exceptions")
    case object services extends _Fields(9, "services")
    case object typeRegistry extends _Fields(98, "typeRegistry")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.namespaces,
    2.toShort -> _Fields.includes,
    3.toShort -> _Fields.constants,
    4.toShort -> _Fields.enums,
    5.toShort -> _Fields.typedefs,
    6.toShort -> _Fields.structs,
    7.toShort -> _Fields.unions,
    8.toShort -> _Fields.exceptions,
    9.toShort -> _Fields.services,
    98.toShort -> _Fields.typeRegistry
  )

  // Record v2
  override type Self = Program.type
  override type Trait = Program
  override type Mutable = MutableProgram
  override type Raw = RawProgram

  override def createRecord: Program = createRawRecord
  override def createRawRecord: Program.Raw = new Program.Raw

  override def ifInstanceFrom(x: AnyRef): Option[Program] = {
    if (x.isInstanceOf[Program]) Some(x.asInstanceOf[Program]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val namespaces =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace], Program, Program.type](
      name = "namespaces",
      longName = "namespaces",
      id = 1,
      annotations = Map(),
      owner = Program,
      getter = _.namespacesOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]) => { r.namespaces_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]]
    )

  val includes =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Include], Program, Program.type](
      name = "includes",
      longName = "includes",
      id = 2,
      annotations = Map(),
      owner = Program,
      getter = _.includesOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Include]) => { r.includes_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Include]]
    )

  val constants =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Const], Program, Program.type](
      name = "constants",
      longName = "constants",
      id = 3,
      annotations = Map(),
      owner = Program,
      getter = _.constantsOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Const]) => { r.constants_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Const]]
    )

  val enums =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Enum], Program, Program.type](
      name = "enums",
      longName = "enums",
      id = 4,
      annotations = Map(),
      owner = Program,
      getter = _.enumsOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]) => { r.enums_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]]
    )

  val typedefs =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef], Program, Program.type](
      name = "typedefs",
      longName = "typedefs",
      id = 5,
      annotations = Map(),
      owner = Program,
      getter = _.typedefsOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]) => { r.typedefs_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]]
    )

  val structs =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Struct], Program, Program.type](
      name = "structs",
      longName = "structs",
      id = 6,
      annotations = Map(),
      owner = Program,
      getter = _.structsOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]) => { r.structs_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]]
    )

  val unions =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Union], Program, Program.type](
      name = "unions",
      longName = "unions",
      id = 7,
      annotations = Map(),
      owner = Program,
      getter = _.unionsOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Union]) => { r.unions_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Union]]
    )

  val exceptions =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Exception], Program, Program.type](
      name = "exceptions",
      longName = "exceptions",
      id = 8,
      annotations = Map(),
      owner = Program,
      getter = _.exceptionsOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]) => { r.exceptions_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]]
    )

  val services =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Service], Program, Program.type](
      name = "services",
      longName = "services",
      id = 9,
      annotations = Map(),
      owner = Program,
      getter = _.servicesOption,
      setterRaw = (r: Program.Raw, v: scala.collection.Seq[com.twitter.thrift.descriptors.Service]) => { r.services_=(v) },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Service]]
    )

  val typeRegistry =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.TypeRegistry, Program, Program.type](
      name = "typeRegistry",
      longName = "typeRegistry",
      id = 98,
      annotations = Map(),
      owner = Program,
      getter = _.typeRegistryOption,
      setterRaw = (r: Program.Raw, v: com.twitter.thrift.descriptors.TypeRegistry) => { r.typeRegistry_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.TypeRegistry]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, Program, Program.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, Program, Program.type]](
      namespaces,
      includes,
      constants,
      enums,
      typedefs,
      structs,
      unions,
      exceptions,
      services,
      typeRegistry
    )


  def apply(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace],
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include],
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const],
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum],
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef],
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct],
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union],
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception],
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service],
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry
  ): Program = {
    val ret = Program.createRawRecord
    ret.namespaces_=(namespaces)
    ret.includes_=(includes)
    ret.constants_=(constants)
    ret.enums_=(enums)
    ret.typedefs_=(typedefs)
    ret.structs_=(structs)
    ret.unions_=(unions)
    ret.exceptions_=(exceptions)
    ret.services_=(services)
    ret.typeRegistry_=(typeRegistry)
    ret
  }



  object Builder {
    sealed trait HasTypeRegistry

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeRegistry
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Program] (private var obj: Program.Raw) {
    def typeRegistry(v: com.twitter.thrift.descriptors.TypeRegistry): Program.Builder[State with Builder.HasTypeRegistry] = {
      obj.typeRegistry_=(v)
      this.asInstanceOf[Program.Builder[State with Builder.HasTypeRegistry]]
    }

    def namespaces(v: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Program.Builder[State] = {
      obj.namespaces_=(v)
      this
    }

    def namespaces(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.namespaces_=(v)
        case None => obj.namespacesUnset()
      }
      this
    }

    def includes(v: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Program.Builder[State] = {
      obj.includes_=(v)
      this
    }

    def includes(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.includes_=(v)
        case None => obj.includesUnset()
      }
      this
    }

    def constants(v: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Program.Builder[State] = {
      obj.constants_=(v)
      this
    }

    def constants(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.constants_=(v)
        case None => obj.constantsUnset()
      }
      this
    }

    def enums(v: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Program.Builder[State] = {
      obj.enums_=(v)
      this
    }

    def enums(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.enums_=(v)
        case None => obj.enumsUnset()
      }
      this
    }

    def typedefs(v: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Program.Builder[State] = {
      obj.typedefs_=(v)
      this
    }

    def typedefs(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.typedefs_=(v)
        case None => obj.typedefsUnset()
      }
      this
    }

    def structs(v: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Program.Builder[State] = {
      obj.structs_=(v)
      this
    }

    def structs(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.structs_=(v)
        case None => obj.structsUnset()
      }
      this
    }

    def unions(v: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Program.Builder[State] = {
      obj.unions_=(v)
      this
    }

    def unions(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.unions_=(v)
        case None => obj.unionsUnset()
      }
      this
    }

    def exceptions(v: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Program.Builder[State] = {
      obj.exceptions_=(v)
      this
    }

    def exceptions(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.exceptions_=(v)
        case None => obj.exceptionsUnset()
      }
      this
    }

    def services(v: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Program.Builder[State] = {
      obj.services_=(v)
      this
    }

    def services(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.services_=(v)
        case None => obj.servicesUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeRegistry): Program.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Program.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeRegistry): Program = resultMutable()(ev0)
  }

  def newBuilder: Program.Builder.AllUnspecified = new Builder(Program.createRawRecord)

  implicit val companionProvider: ProgramCompanionProvider = new ProgramCompanionProvider
}

class ProgramCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[Program] {
  type CompanionT = Program.type
  override def provide: Program.type = Program
}



trait Program

    extends com.foursquare.recordv2.runtime.Record[Program]
    with scala.Ordered[Program]
    with org.apache.thrift.TBase[Program, Program._Fields] {

  override type MetaT = Program.type

  def namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]
  def namespacesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]]
  def namespacesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]
  def namespacesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]
  def namespacesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]
  def namespacesIsSet: Boolean
  def includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include]
  def includesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]]
  def includesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Include]
  def includesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Include]
  def includesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Include]
  def includesIsSet: Boolean
  def constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const]
  def constantsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]]
  def constantsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Const]
  def constantsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Const]
  def constantsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Const]
  def constantsIsSet: Boolean
  def enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]
  def enumsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]]
  def enumsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]
  def enumsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]
  def enumsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]
  def enumsIsSet: Boolean
  def typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]
  def typedefsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]]
  def typedefsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]
  def typedefsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]
  def typedefsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]
  def typedefsIsSet: Boolean
  def structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]
  def structsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]]
  def structsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]
  def structsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]
  def structsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]
  def structsIsSet: Boolean
  def unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union]
  def unionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]]
  def unionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Union]
  def unionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Union]
  def unionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Union]
  def unionsIsSet: Boolean
  def exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]
  def exceptionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]]
  def exceptionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]
  def exceptionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]
  def exceptionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]
  def exceptionsIsSet: Boolean
  def services: scala.collection.Seq[com.twitter.thrift.descriptors.Service]
  def servicesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]]
  def servicesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Service]
  def servicesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Service]
  def servicesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Service]
  def servicesIsSet: Boolean

  def typeRegistry: com.twitter.thrift.descriptors.TypeRegistry
  def typeRegistryOption: Option[com.twitter.thrift.descriptors.TypeRegistry]
  def typeRegistryOrNull: com.twitter.thrift.descriptors.TypeRegistry
  def typeRegistryOrThrow: com.twitter.thrift.descriptors.TypeRegistry
  def typeRegistryIsSet: Boolean
  override def compare(that: Program): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.namespacesIsSet.compareTo(that.namespacesIsSet)
      cmp != 0 }) cmp
    else if (this.namespacesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.namespaces.asJava, that.namespaces.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.includesIsSet.compareTo(that.includesIsSet)
      cmp != 0 }) cmp
    else if (this.includesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.includes.asJava, that.includes.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.constantsIsSet.compareTo(that.constantsIsSet)
      cmp != 0 }) cmp
    else if (this.constantsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.constants.asJava, that.constants.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.enumsIsSet.compareTo(that.enumsIsSet)
      cmp != 0 }) cmp
    else if (this.enumsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.enums.asJava, that.enums.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typedefsIsSet.compareTo(that.typedefsIsSet)
      cmp != 0 }) cmp
    else if (this.typedefsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.typedefs.asJava, that.typedefs.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.structsIsSet.compareTo(that.structsIsSet)
      cmp != 0 }) cmp
    else if (this.structsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.structs.asJava, that.structs.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.unionsIsSet.compareTo(that.unionsIsSet)
      cmp != 0 }) cmp
    else if (this.unionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.unions.asJava, that.unions.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.exceptionsIsSet.compareTo(that.exceptionsIsSet)
      cmp != 0 }) cmp
    else if (this.exceptionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.exceptions.asJava, that.exceptions.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.servicesIsSet.compareTo(that.servicesIsSet)
      cmp != 0 }) cmp
    else if (this.servicesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(this.services.asJava, that.services.asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typeRegistryIsSet.compareTo(that.typeRegistryIsSet)
      cmp != 0 }) cmp
    else if (this.typeRegistryIsSet && {
      cmp = this.typeRegistryOrNull.compareTo(that.typeRegistryOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Program

  def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program

  def mutableCopy(): Program.Mutable = {
    val ret = Program.createRawRecord

    if (namespacesIsSet) ret.namespaces_=(namespacesOrNull)

    if (includesIsSet) ret.includes_=(includesOrNull)

    if (constantsIsSet) ret.constants_=(constantsOrNull)

    if (enumsIsSet) ret.enums_=(enumsOrNull)

    if (typedefsIsSet) ret.typedefs_=(typedefsOrNull)

    if (structsIsSet) ret.structs_=(structsOrNull)

    if (unionsIsSet) ret.unions_=(unionsOrNull)

    if (exceptionsIsSet) ret.exceptions_=(exceptionsOrNull)

    if (servicesIsSet) ret.services_=(servicesOrNull)

    if (typeRegistryIsSet) ret.typeRegistry_=(typeRegistryOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: Program.Mutable

  def toBuilder() = {
    val ret = new Program.Builder(Program.createRawRecord)

    if (namespacesIsSet) ret.namespaces(namespacesOrNull)

    if (includesIsSet) ret.includes(includesOrNull)

    if (constantsIsSet) ret.constants(constantsOrNull)

    if (enumsIsSet) ret.enums(enumsOrNull)

    if (typedefsIsSet) ret.typedefs(typedefsOrNull)

    if (structsIsSet) ret.structs(structsOrNull)

    if (unionsIsSet) ret.unions(unionsOrNull)

    if (exceptionsIsSet) ret.exceptions(exceptionsOrNull)

    if (servicesIsSet) ret.services(servicesOrNull)

    if (typeRegistryIsSet) ret.typeRegistry(typeRegistryOrNull)
    ret
  }

  def mergeCopy(that: Program): Program

}


trait ProgramProxy extends Program {
  protected def underlying: Program

  override def meta: Program.type = underlying.meta

// field/proxy_container.ssp
  override def namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespaces
  override def namespacesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]] = underlying.namespacesOption
  override def namespacesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespacesOrDefault
  override def namespacesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespacesOrNull
  override def namespacesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespacesOrThrow
  override def namespacesIsSet: Boolean = underlying.namespacesIsSet
// field/proxy_container.ssp
  override def includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includes
  override def includesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]] = underlying.includesOption
  override def includesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includesOrDefault
  override def includesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includesOrNull
  override def includesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includesOrThrow
  override def includesIsSet: Boolean = underlying.includesIsSet
// field/proxy_container.ssp
  override def constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constants
  override def constantsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]] = underlying.constantsOption
  override def constantsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constantsOrDefault
  override def constantsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constantsOrNull
  override def constantsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constantsOrThrow
  override def constantsIsSet: Boolean = underlying.constantsIsSet
// field/proxy_container.ssp
  override def enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enums
  override def enumsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]] = underlying.enumsOption
  override def enumsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enumsOrDefault
  override def enumsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enumsOrNull
  override def enumsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enumsOrThrow
  override def enumsIsSet: Boolean = underlying.enumsIsSet
// field/proxy_container.ssp
  override def typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefs
  override def typedefsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]] = underlying.typedefsOption
  override def typedefsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefsOrDefault
  override def typedefsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefsOrNull
  override def typedefsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefsOrThrow
  override def typedefsIsSet: Boolean = underlying.typedefsIsSet
// field/proxy_container.ssp
  override def structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structs
  override def structsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]] = underlying.structsOption
  override def structsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structsOrDefault
  override def structsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structsOrNull
  override def structsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structsOrThrow
  override def structsIsSet: Boolean = underlying.structsIsSet
// field/proxy_container.ssp
  override def unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unions
  override def unionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]] = underlying.unionsOption
  override def unionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unionsOrDefault
  override def unionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unionsOrNull
  override def unionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unionsOrThrow
  override def unionsIsSet: Boolean = underlying.unionsIsSet
// field/proxy_container.ssp
  override def exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptions
  override def exceptionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]] = underlying.exceptionsOption
  override def exceptionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptionsOrDefault
  override def exceptionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptionsOrNull
  override def exceptionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptionsOrThrow
  override def exceptionsIsSet: Boolean = underlying.exceptionsIsSet
// field/proxy_container.ssp
  override def services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.services
  override def servicesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]] = underlying.servicesOption
  override def servicesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.servicesOrDefault
  override def servicesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.servicesOrNull
  override def servicesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.servicesOrThrow
  override def servicesIsSet: Boolean = underlying.servicesIsSet
// field/proxy_ref.ssp

  override def typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = underlying.typeRegistry
  override def typeRegistryOption: Option[com.twitter.thrift.descriptors.TypeRegistry] = underlying.typeRegistryOption
  override def typeRegistryOrNull: com.twitter.thrift.descriptors.TypeRegistry = underlying.typeRegistryOrNull
  override def typeRegistryOrThrow: com.twitter.thrift.descriptors.TypeRegistry = underlying.typeRegistryOrThrow
  override def typeRegistryIsSet: Boolean = underlying.typeRegistryIsSet

  override def compare(that: Program): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program = underlying.copy(
    namespaces = namespaces,
    includes = includes,
    constants = constants,
    enums = enums,
    typedefs = typedefs,
    structs = structs,
    unions = unions,
    exceptions = exceptions,
    services = services,
    typeRegistry = typeRegistry
  )

  override def mutableCopy(): Program.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: Program): Program = underlying.mergeCopy(that)

  override def mutable: Program.Mutable = underlying.mutable

  override def deepCopy(): Program = underlying.deepCopy()

  override def fieldForId(id: Int): Program._Fields = underlying.fieldForId(id)
  override def isSet(field: Program._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Program._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Program._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableProgram extends Program {
  def namespaces_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Unit
  def namespacesUnset(): Unit
  def includes_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Unit
  def includesUnset(): Unit
  def constants_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Unit
  def constantsUnset(): Unit
  def enums_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Unit
  def enumsUnset(): Unit
  def typedefs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Unit
  def typedefsUnset(): Unit
  def structs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Unit
  def structsUnset(): Unit
  def unions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Unit
  def unionsUnset(): Unit
  def exceptions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Unit
  def exceptionsUnset(): Unit
  def services_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Unit
  def servicesUnset(): Unit
  def typeRegistry_=(x: com.twitter.thrift.descriptors.TypeRegistry): Unit
  def typeRegistryUnset(): Unit

  def merge(that: Program): Unit

  def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program.Mutable

  override def mutable: Program.Mutable = this
}

trait MutableProgramProxy extends MutableProgram with ProgramProxy {
  protected def underlying: MutableProgram

  override def namespaces_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Unit = { underlying.namespaces_=(x) }
  override def namespacesUnset(): Unit = { underlying.namespacesUnset() }
  override def includes_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Unit = { underlying.includes_=(x) }
  override def includesUnset(): Unit = { underlying.includesUnset() }
  override def constants_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Unit = { underlying.constants_=(x) }
  override def constantsUnset(): Unit = { underlying.constantsUnset() }
  override def enums_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Unit = { underlying.enums_=(x) }
  override def enumsUnset(): Unit = { underlying.enumsUnset() }
  override def typedefs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Unit = { underlying.typedefs_=(x) }
  override def typedefsUnset(): Unit = { underlying.typedefsUnset() }
  override def structs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Unit = { underlying.structs_=(x) }
  override def structsUnset(): Unit = { underlying.structsUnset() }
  override def unions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Unit = { underlying.unions_=(x) }
  override def unionsUnset(): Unit = { underlying.unionsUnset() }
  override def exceptions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Unit = { underlying.exceptions_=(x) }
  override def exceptionsUnset(): Unit = { underlying.exceptionsUnset() }
  override def services_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Unit = { underlying.services_=(x) }
  override def servicesUnset(): Unit = { underlying.servicesUnset() }
  override def typeRegistry_=(x: com.twitter.thrift.descriptors.TypeRegistry): Unit = { underlying.typeRegistry_=(x) }
  override def typeRegistryUnset(): Unit = { underlying.typeRegistryUnset() }

  override def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program.Mutable = underlying.copy(
    namespaces = namespaces,
    includes = includes,
    constants = constants,
    enums = enums,
    typedefs = typedefs,
    structs = structs,
    unions = unions,
    exceptions = exceptions,
    services = services,
    typeRegistry = typeRegistry
  )

  override def merge(that: Program): Unit = underlying.merge(that)
}



final class RawProgram extends MutableProgram {
  override def meta: Program.type = Program

  // Field #1 - namespaces
  private var _namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]
  override def namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrDefault
  override def namespaces_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Unit = { _namespaces = x }
  override def namespacesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]] = if (namespacesIsSet) Some(_namespaces) else None
  override def namespacesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = if (namespacesIsSet) _namespaces else scala.collection.Seq.empty
  override def namespacesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = _namespaces
  override def namespacesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = if (namespacesIsSet) _namespaces else throw new java.lang.NullPointerException
  override def namespacesIsSet: Boolean = _namespaces != null
  override def namespacesUnset(): Unit = { _namespaces = null }
  // Field #2 - includes
  private var _includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Include]
  override def includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrDefault
  override def includes_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Unit = { _includes = x }
  override def includesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]] = if (includesIsSet) Some(_includes) else None
  override def includesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = if (includesIsSet) _includes else scala.collection.Seq.empty
  override def includesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = _includes
  override def includesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = if (includesIsSet) _includes else throw new java.lang.NullPointerException
  override def includesIsSet: Boolean = _includes != null
  override def includesUnset(): Unit = { _includes = null }
  // Field #3 - constants
  private var _constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Const]
  override def constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrDefault
  override def constants_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Unit = { _constants = x }
  override def constantsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]] = if (constantsIsSet) Some(_constants) else None
  override def constantsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = if (constantsIsSet) _constants else scala.collection.Seq.empty
  override def constantsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = _constants
  override def constantsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = if (constantsIsSet) _constants else throw new java.lang.NullPointerException
  override def constantsIsSet: Boolean = _constants != null
  override def constantsUnset(): Unit = { _constants = null }
  // Field #4 - enums
  private var _enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]
  override def enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrDefault
  override def enums_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Unit = { _enums = x }
  override def enumsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]] = if (enumsIsSet) Some(_enums) else None
  override def enumsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = if (enumsIsSet) _enums else scala.collection.Seq.empty
  override def enumsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = _enums
  override def enumsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = if (enumsIsSet) _enums else throw new java.lang.NullPointerException
  override def enumsIsSet: Boolean = _enums != null
  override def enumsUnset(): Unit = { _enums = null }
  // Field #5 - typedefs
  private var _typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]
  override def typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrDefault
  override def typedefs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Unit = { _typedefs = x }
  override def typedefsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]] = if (typedefsIsSet) Some(_typedefs) else None
  override def typedefsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = if (typedefsIsSet) _typedefs else scala.collection.Seq.empty
  override def typedefsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = _typedefs
  override def typedefsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = if (typedefsIsSet) _typedefs else throw new java.lang.NullPointerException
  override def typedefsIsSet: Boolean = _typedefs != null
  override def typedefsUnset(): Unit = { _typedefs = null }
  // Field #6 - structs
  private var _structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]
  override def structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrDefault
  override def structs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Unit = { _structs = x }
  override def structsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]] = if (structsIsSet) Some(_structs) else None
  override def structsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = if (structsIsSet) _structs else scala.collection.Seq.empty
  override def structsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = _structs
  override def structsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = if (structsIsSet) _structs else throw new java.lang.NullPointerException
  override def structsIsSet: Boolean = _structs != null
  override def structsUnset(): Unit = { _structs = null }
  // Field #7 - unions
  private var _unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Union]
  override def unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrDefault
  override def unions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Unit = { _unions = x }
  override def unionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]] = if (unionsIsSet) Some(_unions) else None
  override def unionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = if (unionsIsSet) _unions else scala.collection.Seq.empty
  override def unionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = _unions
  override def unionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = if (unionsIsSet) _unions else throw new java.lang.NullPointerException
  override def unionsIsSet: Boolean = _unions != null
  override def unionsUnset(): Unit = { _unions = null }
  // Field #8 - exceptions
  private var _exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]
  override def exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrDefault
  override def exceptions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Unit = { _exceptions = x }
  override def exceptionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]] = if (exceptionsIsSet) Some(_exceptions) else None
  override def exceptionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = if (exceptionsIsSet) _exceptions else scala.collection.Seq.empty
  override def exceptionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = _exceptions
  override def exceptionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = if (exceptionsIsSet) _exceptions else throw new java.lang.NullPointerException
  override def exceptionsIsSet: Boolean = _exceptions != null
  override def exceptionsUnset(): Unit = { _exceptions = null }
  // Field #9 - services
  private var _services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Service]
  override def services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrDefault
  override def services_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Unit = { _services = x }
  override def servicesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]] = if (servicesIsSet) Some(_services) else None
  override def servicesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = if (servicesIsSet) _services else scala.collection.Seq.empty
  override def servicesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = _services
  override def servicesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = if (servicesIsSet) _services else throw new java.lang.NullPointerException
  override def servicesIsSet: Boolean = _services != null
  override def servicesUnset(): Unit = { _services = null }
  // Field #98 - typeRegistry
  private var _typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = null  // Underlying type: com.twitter.thrift.descriptors.TypeRegistry
  override def typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrThrow
  override def typeRegistry_=(x: com.twitter.thrift.descriptors.TypeRegistry): Unit = { _typeRegistry = x }
  override def typeRegistryOption: Option[com.twitter.thrift.descriptors.TypeRegistry] = if (typeRegistryIsSet) Some(_typeRegistry) else None
  override def typeRegistryOrNull: com.twitter.thrift.descriptors.TypeRegistry = _typeRegistry
  override def typeRegistryOrThrow: com.twitter.thrift.descriptors.TypeRegistry = if (typeRegistryIsSet) _typeRegistry else throw new java.lang.NullPointerException
  override def typeRegistryIsSet: Boolean = _typeRegistry != null
  override def typeRegistryUnset(): Unit = { _typeRegistry = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(Program.PROGRAM_DESC)
    if (namespacesIsSet) {
      oprot.writeFieldBegin(Program.NAMESPACES_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _namespaces.size))
      _namespaces.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (includesIsSet) {
      oprot.writeFieldBegin(Program.INCLUDES_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _includes.size))
      _includes.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (constantsIsSet) {
      oprot.writeFieldBegin(Program.CONSTANTS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _constants.size))
      _constants.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (enumsIsSet) {
      oprot.writeFieldBegin(Program.ENUMS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _enums.size))
      _enums.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (typedefsIsSet) {
      oprot.writeFieldBegin(Program.TYPEDEFS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _typedefs.size))
      _typedefs.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (structsIsSet) {
      oprot.writeFieldBegin(Program.STRUCTS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _structs.size))
      _structs.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (unionsIsSet) {
      oprot.writeFieldBegin(Program.UNIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _unions.size))
      _unions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (exceptionsIsSet) {
      oprot.writeFieldBegin(Program.EXCEPTIONS_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _exceptions.size))
      _exceptions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (servicesIsSet) {
      oprot.writeFieldBegin(Program.SERVICES_DESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _services.size))
      _services.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (typeRegistryIsSet) {
      oprot.writeFieldBegin(Program.TYPEREGISTRY_DESC)
      _typeRegistry.write(oprot)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Program.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // namespaces

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _namespaces = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Namespace]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Namespace.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // includes

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _includes = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Include]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Include.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // constants

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _constants = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Const]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Const.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // enums

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _enums = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Enum]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Enum.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // typedefs

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _typedefs = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Typedef]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Typedef.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 6 => {  // structs

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _structs = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Struct]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Struct.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 7 => {  // unions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _unions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Union]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Union.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 8 => {  // exceptions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _exceptions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Exception]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Exception.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 9 => {  // services

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _services = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Service]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Service.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 98 => {  // typeRegistry

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _typeRegistry = ({
                val s = com.twitter.thrift.descriptors.TypeRegistry.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Program".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: Program): Unit = {
    if (that.namespacesIsSet && !this.namespacesIsSet) {
      this.namespaces_=(that.namespacesOrDefault)

    } else if (that.namespacesIsSet && this.namespacesIsSet) {
      this.namespaces ++= that.namespaces
    }
    if (that.includesIsSet && !this.includesIsSet) {
      this.includes_=(that.includesOrDefault)

    } else if (that.includesIsSet && this.includesIsSet) {
      this.includes ++= that.includes
    }
    if (that.constantsIsSet && !this.constantsIsSet) {
      this.constants_=(that.constantsOrDefault)

    } else if (that.constantsIsSet && this.constantsIsSet) {
      this.constants ++= that.constants
    }
    if (that.enumsIsSet && !this.enumsIsSet) {
      this.enums_=(that.enumsOrDefault)

    } else if (that.enumsIsSet && this.enumsIsSet) {
      this.enums ++= that.enums
    }
    if (that.typedefsIsSet && !this.typedefsIsSet) {
      this.typedefs_=(that.typedefsOrDefault)

    } else if (that.typedefsIsSet && this.typedefsIsSet) {
      this.typedefs ++= that.typedefs
    }
    if (that.structsIsSet && !this.structsIsSet) {
      this.structs_=(that.structsOrDefault)

    } else if (that.structsIsSet && this.structsIsSet) {
      this.structs ++= that.structs
    }
    if (that.unionsIsSet && !this.unionsIsSet) {
      this.unions_=(that.unionsOrDefault)

    } else if (that.unionsIsSet && this.unionsIsSet) {
      this.unions ++= that.unions
    }
    if (that.exceptionsIsSet && !this.exceptionsIsSet) {
      this.exceptions_=(that.exceptionsOrDefault)

    } else if (that.exceptionsIsSet && this.exceptionsIsSet) {
      this.exceptions ++= that.exceptions
    }
    if (that.servicesIsSet && !this.servicesIsSet) {
      this.services_=(that.servicesOrDefault)

    } else if (that.servicesIsSet && this.servicesIsSet) {
      this.services ++= that.services
    }
    if (that.typeRegistryIsSet && !this.typeRegistryIsSet) {
      this.typeRegistry_=(that.typeRegistryOrNull)
    }
  }

  override def mergeCopy(that: Program): Program = {
    val ret = Program.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Program => this.equals(o)
    case _ => false
  }

  def equals(that: Program): Boolean = {
    that != null &&
    (if (this.namespacesIsSet) (that.namespacesIsSet && this.namespacesOrDefault == that.namespacesOrDefault) else !that.namespacesIsSet) &&
    (if (this.includesIsSet) (that.includesIsSet && this.includesOrDefault == that.includesOrDefault) else !that.includesIsSet) &&
    (if (this.constantsIsSet) (that.constantsIsSet && this.constantsOrDefault == that.constantsOrDefault) else !that.constantsIsSet) &&
    (if (this.enumsIsSet) (that.enumsIsSet && this.enumsOrDefault == that.enumsOrDefault) else !that.enumsIsSet) &&
    (if (this.typedefsIsSet) (that.typedefsIsSet && this.typedefsOrDefault == that.typedefsOrDefault) else !that.typedefsIsSet) &&
    (if (this.structsIsSet) (that.structsIsSet && this.structsOrDefault == that.structsOrDefault) else !that.structsIsSet) &&
    (if (this.unionsIsSet) (that.unionsIsSet && this.unionsOrDefault == that.unionsOrDefault) else !that.unionsIsSet) &&
    (if (this.exceptionsIsSet) (that.exceptionsIsSet && this.exceptionsOrDefault == that.exceptionsOrDefault) else !that.exceptionsIsSet) &&
    (if (this.servicesIsSet) (that.servicesIsSet && this.servicesOrDefault == that.servicesOrDefault) else !that.servicesIsSet) &&
    (if (this.typeRegistryIsSet) (that.typeRegistryIsSet && this.typeRegistryOrNull == that.typeRegistryOrNull) else !that.typeRegistryIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (namespacesIsSet) hasher.append(_namespaces.##)
    if (includesIsSet) hasher.append(_includes.##)
    if (constantsIsSet) hasher.append(_constants.##)
    if (enumsIsSet) hasher.append(_enums.##)
    if (typedefsIsSet) hasher.append(_typedefs.##)
    if (structsIsSet) hasher.append(_structs.##)
    if (unionsIsSet) hasher.append(_unions.##)
    if (exceptionsIsSet) hasher.append(_exceptions.##)
    if (servicesIsSet) hasher.append(_services.##)
    if (typeRegistryIsSet) hasher.append(_typeRegistry.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (namespacesIsSet) ret = namespacesOrDefault :: ret
    if (includesIsSet) ret = includesOrDefault :: ret
    if (constantsIsSet) ret = constantsOrDefault :: ret
    if (enumsIsSet) ret = enumsOrDefault :: ret
    if (typedefsIsSet) ret = typedefsOrDefault :: ret
    if (structsIsSet) ret = structsOrDefault :: ret
    if (unionsIsSet) ret = unionsOrDefault :: ret
    if (exceptionsIsSet) ret = exceptionsOrDefault :: ret
    if (servicesIsSet) ret = servicesOrDefault :: ret
    if (typeRegistryIsSet) ret = typeRegistryOrNull :: ret
    ret.reverse
  }

  override def clear() {
    namespacesUnset()
    includesUnset()
    constantsUnset()
    enumsUnset()
    typedefsUnset()
    structsUnset()
    unionsUnset()
    exceptionsUnset()
    servicesUnset()
    typeRegistryUnset()
  }

  def fieldForId(id: Int): Program._Fields = id match {
    case 1 => Program._Fields.namespaces
    case 2 => Program._Fields.includes
    case 3 => Program._Fields.constants
    case 4 => Program._Fields.enums
    case 5 => Program._Fields.typedefs
    case 6 => Program._Fields.structs
    case 7 => Program._Fields.unions
    case 8 => Program._Fields.exceptions
    case 9 => Program._Fields.services
    case 98 => Program._Fields.typeRegistry
    case _ => null
  }

  def isSet(field: Program._Fields): Boolean = field match {
    case Program._Fields.namespaces => namespacesIsSet
    case Program._Fields.includes => includesIsSet
    case Program._Fields.constants => constantsIsSet
    case Program._Fields.enums => enumsIsSet
    case Program._Fields.typedefs => typedefsIsSet
    case Program._Fields.structs => structsIsSet
    case Program._Fields.unions => unionsIsSet
    case Program._Fields.exceptions => exceptionsIsSet
    case Program._Fields.services => servicesIsSet
    case Program._Fields.typeRegistry => typeRegistryIsSet
    case _ => false
  }

  def getFieldValue(field: Program._Fields): AnyRef = field match {
    case Program._Fields.namespaces => namespacesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.includes => includesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.constants => constantsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.enums => enumsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.typedefs => typedefsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.structs => structsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.unions => unionsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.exceptions => exceptionsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.services => servicesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.typeRegistry => typeRegistryOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Program._Fields, value: AnyRef) {
    field match {
      case Program._Fields.namespaces => namespaces_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]])
      case Program._Fields.includes => includes_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Include]])
      case Program._Fields.constants => constants_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Const]])
      case Program._Fields.enums => enums_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]])
      case Program._Fields.typedefs => typedefs_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]])
      case Program._Fields.structs => structs_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]])
      case Program._Fields.unions => unions_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Union]])
      case Program._Fields.exceptions => exceptions_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]])
      case Program._Fields.services => services_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Service]])
      case Program._Fields.typeRegistry => typeRegistry_=(value.asInstanceOf[com.twitter.thrift.descriptors.TypeRegistry])
      case _ =>
    }
  }

  override def deepCopy(): Program.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Program.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program.Raw = {
    val ret = new Program.Raw
    if (namespaces != null) ret.namespaces_=(namespaces)
    if (includes != null) ret.includes_=(includes)
    if (constants != null) ret.constants_=(constants)
    if (enums != null) ret.enums_=(enums)
    if (typedefs != null) ret.typedefs_=(typedefs)
    if (structs != null) ret.structs_=(structs)
    if (unions != null) ret.unions_=(unions)
    if (exceptions != null) ret.exceptions_=(exceptions)
    if (services != null) ret.services_=(services)
    if (typeRegistry != null) ret.typeRegistry_=(typeRegistry)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}




object SimpleContainerType
    extends com.foursquare.recordv2.runtime.MetaRecord[SimpleContainerType]
    with com.foursquare.recordv2.runtime.RecordProvider[SimpleContainerType] {
  override def recordName: String = "SimpleContainerType"


  // Thrift descriptors.
  val SIMPLECONTAINERTYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("SimpleContainerType")

  val LISTTYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "listType",
      org.apache.thrift.protocol.TType.STRUCT,
      1,
      Map[String, String]().asJava
    )
  val SETTYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "setType",
      org.apache.thrift.protocol.TType.STRUCT,
      2,
      Map[String, String]().asJava
    )
  val MAPTYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "mapType",
      org.apache.thrift.protocol.TType.STRUCT,
      3,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "listType" -> LISTTYPE_DESC,
    "setType" -> SETTYPE_DESC,
    "mapType" -> MAPTYPE_DESC
  )

  object _Fields {
    case object listType extends _Fields(1, "listType")
    case object setType extends _Fields(2, "setType")
    case object mapType extends _Fields(3, "mapType")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.listType,
    2.toShort -> _Fields.setType,
    3.toShort -> _Fields.mapType
  )

  // Record v2
  override type Self = SimpleContainerType.type
  override type Trait = SimpleContainerType
  override type Mutable = MutableSimpleContainerType
  override type Raw = RawSimpleContainerType

  override def createRecord: SimpleContainerType = createRawRecord
  override def createRawRecord: SimpleContainerType.Raw = new SimpleContainerType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[SimpleContainerType] = {
    if (x.isInstanceOf[SimpleContainerType]) Some(x.asInstanceOf[SimpleContainerType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val listType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.ListType, SimpleContainerType, SimpleContainerType.type](
      name = "listType",
      longName = "listType",
      id = 1,
      annotations = Map(),
      owner = SimpleContainerType,
      getter = _.listTypeOption,
      setterRaw = (r: SimpleContainerType.Raw, v: com.twitter.thrift.descriptors.ListType) => { r.listType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.ListType]
    )

  val setType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.SetType, SimpleContainerType, SimpleContainerType.type](
      name = "setType",
      longName = "setType",
      id = 2,
      annotations = Map(),
      owner = SimpleContainerType,
      getter = _.setTypeOption,
      setterRaw = (r: SimpleContainerType.Raw, v: com.twitter.thrift.descriptors.SetType) => { r.setType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.SetType]
    )

  val mapType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.MapType, SimpleContainerType, SimpleContainerType.type](
      name = "mapType",
      longName = "mapType",
      id = 3,
      annotations = Map(),
      owner = SimpleContainerType,
      getter = _.mapTypeOption,
      setterRaw = (r: SimpleContainerType.Raw, v: com.twitter.thrift.descriptors.MapType) => { r.mapType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.MapType]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, SimpleContainerType, SimpleContainerType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, SimpleContainerType, SimpleContainerType.type]](
      listType,
      setType,
      mapType
    )


  def apply(
      listType: com.twitter.thrift.descriptors.ListType,
      setType: com.twitter.thrift.descriptors.SetType,
      mapType: com.twitter.thrift.descriptors.MapType
  ): SimpleContainerType = {
    val ret = SimpleContainerType.createRawRecord
    ret.listType_=(listType)
    ret.setType_=(setType)
    ret.mapType_=(mapType)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[SimpleContainerType] (private var obj: SimpleContainerType.Raw) {

    def listType(v: com.twitter.thrift.descriptors.ListType): SimpleContainerType.Builder[State] = {
      obj.listType_=(v)
      this
    }

    def listType(vOpt: Option[com.twitter.thrift.descriptors.ListType]): SimpleContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.listType_=(v)
        case None => obj.listTypeUnset()
      }
      this
    }

    def setType(v: com.twitter.thrift.descriptors.SetType): SimpleContainerType.Builder[State] = {
      obj.setType_=(v)
      this
    }

    def setType(vOpt: Option[com.twitter.thrift.descriptors.SetType]): SimpleContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.setType_=(v)
        case None => obj.setTypeUnset()
      }
      this
    }

    def mapType(v: com.twitter.thrift.descriptors.MapType): SimpleContainerType.Builder[State] = {
      obj.mapType_=(v)
      this
    }

    def mapType(vOpt: Option[com.twitter.thrift.descriptors.MapType]): SimpleContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.mapType_=(v)
        case None => obj.mapTypeUnset()
      }
      this
    }

    def resultMutable()(): SimpleContainerType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("SimpleContainerType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): SimpleContainerType = resultMutable()()
  }

  def newBuilder: SimpleContainerType.Builder.AllUnspecified = new Builder(SimpleContainerType.createRawRecord)

  implicit val companionProvider: SimpleContainerTypeCompanionProvider = new SimpleContainerTypeCompanionProvider
}

class SimpleContainerTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[SimpleContainerType] {
  type CompanionT = SimpleContainerType.type
  override def provide: SimpleContainerType.type = SimpleContainerType
}



trait SimpleContainerType

    extends com.foursquare.recordv2.runtime.Record[SimpleContainerType]
    with scala.Ordered[SimpleContainerType]
    with org.apache.thrift.TBase[SimpleContainerType, SimpleContainerType._Fields] {

  override type MetaT = SimpleContainerType.type

  def listTypeOption: Option[com.twitter.thrift.descriptors.ListType]
  def listTypeOrNull: com.twitter.thrift.descriptors.ListType
  def listTypeOrThrow: com.twitter.thrift.descriptors.ListType
  def listTypeIsSet: Boolean
  def setTypeOption: Option[com.twitter.thrift.descriptors.SetType]
  def setTypeOrNull: com.twitter.thrift.descriptors.SetType
  def setTypeOrThrow: com.twitter.thrift.descriptors.SetType
  def setTypeIsSet: Boolean
  def mapTypeOption: Option[com.twitter.thrift.descriptors.MapType]
  def mapTypeOrNull: com.twitter.thrift.descriptors.MapType
  def mapTypeOrThrow: com.twitter.thrift.descriptors.MapType
  def mapTypeIsSet: Boolean
  override def compare(that: SimpleContainerType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.listTypeIsSet.compareTo(that.listTypeIsSet)
      cmp != 0 }) cmp
    else if (this.listTypeIsSet && {
      cmp = this.listTypeOrNull.compareTo(that.listTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.setTypeIsSet.compareTo(that.setTypeIsSet)
      cmp != 0 }) cmp
    else if (this.setTypeIsSet && {
      cmp = this.setTypeOrNull.compareTo(that.setTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.mapTypeIsSet.compareTo(that.mapTypeIsSet)
      cmp != 0 }) cmp
    else if (this.mapTypeIsSet && {
      cmp = this.mapTypeOrNull.compareTo(that.mapTypeOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): SimpleContainerType

  def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): SimpleContainerType

  def mutableCopy(): SimpleContainerType.Mutable = {
    val ret = SimpleContainerType.createRawRecord

    if (listTypeIsSet) ret.listType_=(listTypeOrNull)

    if (setTypeIsSet) ret.setType_=(setTypeOrNull)

    if (mapTypeIsSet) ret.mapType_=(mapTypeOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: SimpleContainerType.Mutable

  def toBuilder() = {
    val ret = new SimpleContainerType.Builder(SimpleContainerType.createRawRecord)

    if (listTypeIsSet) ret.listType(listTypeOrNull)

    if (setTypeIsSet) ret.setType(setTypeOrNull)

    if (mapTypeIsSet) ret.mapType(mapTypeOrNull)
    ret
  }

  def mergeCopy(that: SimpleContainerType): SimpleContainerType

}


trait SimpleContainerTypeProxy extends SimpleContainerType {
  protected def underlying: SimpleContainerType

  override def meta: SimpleContainerType.type = underlying.meta

// field/proxy_ref.ssp
  override def listTypeOption: Option[com.twitter.thrift.descriptors.ListType] = underlying.listTypeOption
  override def listTypeOrNull: com.twitter.thrift.descriptors.ListType = underlying.listTypeOrNull
  override def listTypeOrThrow: com.twitter.thrift.descriptors.ListType = underlying.listTypeOrThrow
  override def listTypeIsSet: Boolean = underlying.listTypeIsSet
// field/proxy_ref.ssp
  override def setTypeOption: Option[com.twitter.thrift.descriptors.SetType] = underlying.setTypeOption
  override def setTypeOrNull: com.twitter.thrift.descriptors.SetType = underlying.setTypeOrNull
  override def setTypeOrThrow: com.twitter.thrift.descriptors.SetType = underlying.setTypeOrThrow
  override def setTypeIsSet: Boolean = underlying.setTypeIsSet
// field/proxy_ref.ssp
  override def mapTypeOption: Option[com.twitter.thrift.descriptors.MapType] = underlying.mapTypeOption
  override def mapTypeOrNull: com.twitter.thrift.descriptors.MapType = underlying.mapTypeOrNull
  override def mapTypeOrThrow: com.twitter.thrift.descriptors.MapType = underlying.mapTypeOrThrow
  override def mapTypeIsSet: Boolean = underlying.mapTypeIsSet

  override def compare(that: SimpleContainerType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): SimpleContainerType = underlying.copy(
    listType = listType,
    setType = setType,
    mapType = mapType
  )

  override def mutableCopy(): SimpleContainerType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: SimpleContainerType): SimpleContainerType = underlying.mergeCopy(that)

  override def mutable: SimpleContainerType.Mutable = underlying.mutable

  override def deepCopy(): SimpleContainerType = underlying.deepCopy()

  override def fieldForId(id: Int): SimpleContainerType._Fields = underlying.fieldForId(id)
  override def isSet(field: SimpleContainerType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: SimpleContainerType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: SimpleContainerType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableSimpleContainerType extends SimpleContainerType {
  def listType_=(x: com.twitter.thrift.descriptors.ListType): Unit
  def listTypeUnset(): Unit
  def setType_=(x: com.twitter.thrift.descriptors.SetType): Unit
  def setTypeUnset(): Unit
  def mapType_=(x: com.twitter.thrift.descriptors.MapType): Unit
  def mapTypeUnset(): Unit

  def merge(that: SimpleContainerType): Unit

  def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): SimpleContainerType.Mutable

  override def mutable: SimpleContainerType.Mutable = this
}

trait MutableSimpleContainerTypeProxy extends MutableSimpleContainerType with SimpleContainerTypeProxy {
  protected def underlying: MutableSimpleContainerType

  override def listType_=(x: com.twitter.thrift.descriptors.ListType): Unit = { underlying.listType_=(x) }
  override def listTypeUnset(): Unit = { underlying.listTypeUnset() }
  override def setType_=(x: com.twitter.thrift.descriptors.SetType): Unit = { underlying.setType_=(x) }
  override def setTypeUnset(): Unit = { underlying.setTypeUnset() }
  override def mapType_=(x: com.twitter.thrift.descriptors.MapType): Unit = { underlying.mapType_=(x) }
  override def mapTypeUnset(): Unit = { underlying.mapTypeUnset() }

  override def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): SimpleContainerType.Mutable = underlying.copy(
    listType = listType,
    setType = setType,
    mapType = mapType
  )

  override def merge(that: SimpleContainerType): Unit = underlying.merge(that)
}



final class RawSimpleContainerType extends MutableSimpleContainerType {
  override def meta: SimpleContainerType.type = SimpleContainerType

  // Field #1 - listType
  private var _listType: com.twitter.thrift.descriptors.ListType = null  // Underlying type: com.twitter.thrift.descriptors.ListType
  override def listType_=(x: com.twitter.thrift.descriptors.ListType): Unit = { _listType = x }
  override def listTypeOption: Option[com.twitter.thrift.descriptors.ListType] = if (listTypeIsSet) Some(_listType) else None
  override def listTypeOrNull: com.twitter.thrift.descriptors.ListType = _listType
  override def listTypeOrThrow: com.twitter.thrift.descriptors.ListType = if (listTypeIsSet) _listType else throw new java.lang.NullPointerException
  override def listTypeIsSet: Boolean = _listType != null
  override def listTypeUnset(): Unit = { _listType = null }
  // Field #2 - setType
  private var _setType: com.twitter.thrift.descriptors.SetType = null  // Underlying type: com.twitter.thrift.descriptors.SetType
  override def setType_=(x: com.twitter.thrift.descriptors.SetType): Unit = { _setType = x }
  override def setTypeOption: Option[com.twitter.thrift.descriptors.SetType] = if (setTypeIsSet) Some(_setType) else None
  override def setTypeOrNull: com.twitter.thrift.descriptors.SetType = _setType
  override def setTypeOrThrow: com.twitter.thrift.descriptors.SetType = if (setTypeIsSet) _setType else throw new java.lang.NullPointerException
  override def setTypeIsSet: Boolean = _setType != null
  override def setTypeUnset(): Unit = { _setType = null }
  // Field #3 - mapType
  private var _mapType: com.twitter.thrift.descriptors.MapType = null  // Underlying type: com.twitter.thrift.descriptors.MapType
  override def mapType_=(x: com.twitter.thrift.descriptors.MapType): Unit = { _mapType = x }
  override def mapTypeOption: Option[com.twitter.thrift.descriptors.MapType] = if (mapTypeIsSet) Some(_mapType) else None
  override def mapTypeOrNull: com.twitter.thrift.descriptors.MapType = _mapType
  override def mapTypeOrThrow: com.twitter.thrift.descriptors.MapType = if (mapTypeIsSet) _mapType else throw new java.lang.NullPointerException
  override def mapTypeIsSet: Boolean = _mapType != null
  override def mapTypeUnset(): Unit = { _mapType = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(SimpleContainerType.SIMPLECONTAINERTYPE_DESC)
    if (listTypeIsSet) {
      oprot.writeFieldBegin(SimpleContainerType.LISTTYPE_DESC)
      _listType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (setTypeIsSet) {
      oprot.writeFieldBegin(SimpleContainerType.SETTYPE_DESC)
      _setType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (mapTypeIsSet) {
      oprot.writeFieldBegin(SimpleContainerType.MAPTYPE_DESC)
      _mapType.write(oprot)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        SimpleContainerType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // listType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _listType = ({
                val s = com.twitter.thrift.descriptors.ListType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // setType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _setType = ({
                val s = com.twitter.thrift.descriptors.SetType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // mapType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _mapType = ({
                val s = com.twitter.thrift.descriptors.MapType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure SimpleContainerType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: SimpleContainerType): Unit = {
    if (that.listTypeIsSet && !this.listTypeIsSet) {
      this.listType_=(that.listTypeOrNull)
    }
    if (that.setTypeIsSet && !this.setTypeIsSet) {
      this.setType_=(that.setTypeOrNull)
    }
    if (that.mapTypeIsSet && !this.mapTypeIsSet) {
      this.mapType_=(that.mapTypeOrNull)
    }
  }

  override def mergeCopy(that: SimpleContainerType): SimpleContainerType = {
    val ret = SimpleContainerType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: SimpleContainerType => this.equals(o)
    case _ => false
  }

  def equals(that: SimpleContainerType): Boolean = {
    that != null &&
    (if (this.listTypeIsSet) (that.listTypeIsSet && this.listTypeOrNull == that.listTypeOrNull) else !that.listTypeIsSet) &&
    (if (this.setTypeIsSet) (that.setTypeIsSet && this.setTypeOrNull == that.setTypeOrNull) else !that.setTypeIsSet) &&
    (if (this.mapTypeIsSet) (that.mapTypeIsSet && this.mapTypeOrNull == that.mapTypeOrNull) else !that.mapTypeIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (listTypeIsSet) hasher.append(_listType.##)
    if (setTypeIsSet) hasher.append(_setType.##)
    if (mapTypeIsSet) hasher.append(_mapType.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (listTypeIsSet) ret = listTypeOrNull :: ret
    if (setTypeIsSet) ret = setTypeOrNull :: ret
    if (mapTypeIsSet) ret = mapTypeOrNull :: ret
    ret.reverse
  }

  override def clear() {
    listTypeUnset()
    setTypeUnset()
    mapTypeUnset()
  }

  def fieldForId(id: Int): SimpleContainerType._Fields = id match {
    case 1 => SimpleContainerType._Fields.listType
    case 2 => SimpleContainerType._Fields.setType
    case 3 => SimpleContainerType._Fields.mapType
    case _ => null
  }

  def isSet(field: SimpleContainerType._Fields): Boolean = field match {
    case SimpleContainerType._Fields.listType => listTypeIsSet
    case SimpleContainerType._Fields.setType => setTypeIsSet
    case SimpleContainerType._Fields.mapType => mapTypeIsSet
    case _ => false
  }

  def getFieldValue(field: SimpleContainerType._Fields): AnyRef = field match {
    case SimpleContainerType._Fields.listType => listTypeOrNull.asInstanceOf[AnyRef]
    case SimpleContainerType._Fields.setType => setTypeOrNull.asInstanceOf[AnyRef]
    case SimpleContainerType._Fields.mapType => mapTypeOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: SimpleContainerType._Fields, value: AnyRef) {
    field match {
      case SimpleContainerType._Fields.listType => listType_=(value.asInstanceOf[com.twitter.thrift.descriptors.ListType])
      case SimpleContainerType._Fields.setType => setType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SetType])
      case SimpleContainerType._Fields.mapType => mapType_=(value.asInstanceOf[com.twitter.thrift.descriptors.MapType])
      case _ =>
    }
  }

  override def deepCopy(): SimpleContainerType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = SimpleContainerType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): SimpleContainerType.Raw = {
    val ret = new SimpleContainerType.Raw
    if (listType != null) ret.listType_=(listType)
    if (setType != null) ret.setType_=(setType)
    if (mapType != null) ret.mapType_=(mapType)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}



object SimpleType
    extends com.foursquare.recordv2.runtime.MetaRecord[SimpleType]
    with com.foursquare.recordv2.runtime.RecordProvider[SimpleType] {
  override def recordName: String = "SimpleType"


  // Thrift descriptors.
  val SIMPLETYPE_DESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("SimpleType")

  val BASETYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "baseType",
      org.apache.thrift.protocol.TType.STRUCT,
      1,
      Map[String, String]().asJava
    )
  val CONTAINERTYPE_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "containerType",
      org.apache.thrift.protocol.TType.STRUCT,
      2,
      Map[String, String]().asJava
    )
  val TYPEREF_DESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeref",
      org.apache.thrift.protocol.TType.STRUCT,
      3,
      Map[String, String]().asJava
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "baseType" -> BASETYPE_DESC,
    "containerType" -> CONTAINERTYPE_DESC,
    "typeref" -> TYPEREF_DESC
  )

  object _Fields {
    case object baseType extends _Fields(1, "baseType")
    case object containerType extends _Fields(2, "containerType")
    case object typeref extends _Fields(3, "typeref")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.baseType,
    2.toShort -> _Fields.containerType,
    3.toShort -> _Fields.typeref
  )

  // Record v2
  override type Self = SimpleType.type
  override type Trait = SimpleType
  override type Mutable = MutableSimpleType
  override type Raw = RawSimpleType

  override def createRecord: SimpleType = createRawRecord
  override def createRawRecord: SimpleType.Raw = new SimpleType.Raw

  override def ifInstanceFrom(x: AnyRef): Option[SimpleType] = {
    if (x.isInstanceOf[SimpleType]) Some(x.asInstanceOf[SimpleType]) else None
  }

  override val annotations: com.foursquare.recordv2.runtime.Annotations =

    com.foursquare.recordv2.runtime.Annotations.empty

  // Record v2 Descriptors.


  val baseType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.BaseType, SimpleType, SimpleType.type](
      name = "baseType",
      longName = "baseType",
      id = 1,
      annotations = Map(),
      owner = SimpleType,
      getter = _.baseTypeOption,
      setterRaw = (r: SimpleType.Raw, v: com.twitter.thrift.descriptors.BaseType) => { r.baseType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.BaseType]
    )

  val containerType =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.ContainerType, SimpleType, SimpleType.type](
      name = "containerType",
      longName = "containerType",
      id = 2,
      annotations = Map(),
      owner = SimpleType,
      getter = _.containerTypeOption,
      setterRaw = (r: SimpleType.Raw, v: com.twitter.thrift.descriptors.ContainerType) => { r.containerType_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.ContainerType]
    )

  val typeref =

    new com.foursquare.recordv2.runtime.OptionalFieldDescriptor[com.twitter.thrift.descriptors.Typeref, SimpleType, SimpleType.type](
      name = "typeref",
      longName = "typeref",
      id = 3,
      annotations = Map(),
      owner = SimpleType,
      getter = _.typerefOption,
      setterRaw = (r: SimpleType.Raw, v: com.twitter.thrift.descriptors.Typeref) => { r.typeref_=(v) },
      manifest = manifest[com.twitter.thrift.descriptors.Typeref]
    )

  override val fields: Seq[com.foursquare.recordv2.runtime.FieldDescriptor[_, SimpleType, SimpleType.type]] =
    Vector[com.foursquare.recordv2.runtime.FieldDescriptor[_, SimpleType, SimpleType.type]](
      baseType,
      containerType,
      typeref
    )


  def apply(
      baseType: com.twitter.thrift.descriptors.BaseType,
      containerType: com.twitter.thrift.descriptors.ContainerType,
      typeref: com.twitter.thrift.descriptors.Typeref
  ): SimpleType = {
    val ret = SimpleType.createRawRecord
    ret.baseType_=(baseType)
    ret.containerType_=(containerType)
    ret.typeref_=(typeref)
    ret
  }



  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[SimpleType] (private var obj: SimpleType.Raw) {

    def baseType(v: com.twitter.thrift.descriptors.BaseType): SimpleType.Builder[State] = {
      obj.baseType_=(v)
      this
    }

    def baseType(vOpt: Option[com.twitter.thrift.descriptors.BaseType]): SimpleType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.baseType_=(v)
        case None => obj.baseTypeUnset()
      }
      this
    }

    def containerType(v: com.twitter.thrift.descriptors.ContainerType): SimpleType.Builder[State] = {
      obj.containerType_=(v)
      this
    }

    def containerType(vOpt: Option[com.twitter.thrift.descriptors.ContainerType]): SimpleType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.containerType_=(v)
        case None => obj.containerTypeUnset()
      }
      this
    }

    def typeref(v: com.twitter.thrift.descriptors.Typeref): SimpleType.Builder[State] = {
      obj.typeref_=(v)
      this
    }

    def typeref(vOpt: Option[com.twitter.thrift.descriptors.Typeref]): SimpleType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.typeref_=(v)
        case None => obj.typerefUnset()
      }
      this
    }

    def resultMutable()(): SimpleType.Mutable = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("SimpleType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(): SimpleType = resultMutable()()
  }

  def newBuilder: SimpleType.Builder.AllUnspecified = new Builder(SimpleType.createRawRecord)

  implicit val companionProvider: SimpleTypeCompanionProvider = new SimpleTypeCompanionProvider
}

class SimpleTypeCompanionProvider extends com.foursquare.recordv2.runtime.CompanionProvider[SimpleType] {
  type CompanionT = SimpleType.type
  override def provide: SimpleType.type = SimpleType
}



trait SimpleType

    extends com.foursquare.recordv2.runtime.Record[SimpleType]
    with scala.Ordered[SimpleType]
    with org.apache.thrift.TBase[SimpleType, SimpleType._Fields] {

  override type MetaT = SimpleType.type

  def baseTypeOption: Option[com.twitter.thrift.descriptors.BaseType]
  def baseTypeOrNull: com.twitter.thrift.descriptors.BaseType
  def baseTypeOrThrow: com.twitter.thrift.descriptors.BaseType
  def baseTypeIsSet: Boolean
  def containerTypeOption: Option[com.twitter.thrift.descriptors.ContainerType]
  def containerTypeOrNull: com.twitter.thrift.descriptors.ContainerType
  def containerTypeOrThrow: com.twitter.thrift.descriptors.ContainerType
  def containerTypeIsSet: Boolean
  def typerefOption: Option[com.twitter.thrift.descriptors.Typeref]
  def typerefOrNull: com.twitter.thrift.descriptors.Typeref
  def typerefOrThrow: com.twitter.thrift.descriptors.Typeref
  def typerefIsSet: Boolean
  override def compare(that: SimpleType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.baseTypeIsSet.compareTo(that.baseTypeIsSet)
      cmp != 0 }) cmp
    else if (this.baseTypeIsSet && {
      cmp = this.baseTypeOrNull.compareTo(that.baseTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.containerTypeIsSet.compareTo(that.containerTypeIsSet)
      cmp != 0 }) cmp
    else if (this.containerTypeIsSet && {
      cmp = this.containerTypeOrNull.compareTo(that.containerTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typerefIsSet.compareTo(that.typerefIsSet)
      cmp != 0 }) cmp
    else if (this.typerefIsSet && {
      cmp = this.typerefOrNull.compareTo(that.typerefOrNull)
      cmp != 0 }) cmp
    else 0
  }

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): SimpleType

  def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): SimpleType

  def mutableCopy(): SimpleType.Mutable = {
    val ret = SimpleType.createRawRecord

    if (baseTypeIsSet) ret.baseType_=(baseTypeOrNull)

    if (containerTypeIsSet) ret.containerType_=(containerTypeOrNull)

    if (typerefIsSet) ret.typeref_=(typerefOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: SimpleType.Mutable

  def toBuilder() = {
    val ret = new SimpleType.Builder(SimpleType.createRawRecord)

    if (baseTypeIsSet) ret.baseType(baseTypeOrNull)

    if (containerTypeIsSet) ret.containerType(containerTypeOrNull)

    if (typerefIsSet) ret.typeref(typerefOrNull)
    ret
  }

  def mergeCopy(that: SimpleType): SimpleType

}


trait SimpleTypeProxy extends SimpleType {
  protected def underlying: SimpleType

  override def meta: SimpleType.type = underlying.meta

// field/proxy_ref.ssp
  override def baseTypeOption: Option[com.twitter.thrift.descriptors.BaseType] = underlying.baseTypeOption
  override def baseTypeOrNull: com.twitter.thrift.descriptors.BaseType = underlying.baseTypeOrNull
  override def baseTypeOrThrow: com.twitter.thrift.descriptors.BaseType = underlying.baseTypeOrThrow
  override def baseTypeIsSet: Boolean = underlying.baseTypeIsSet
// field/proxy_ref.ssp
  override def containerTypeOption: Option[com.twitter.thrift.descriptors.ContainerType] = underlying.containerTypeOption
  override def containerTypeOrNull: com.twitter.thrift.descriptors.ContainerType = underlying.containerTypeOrNull
  override def containerTypeOrThrow: com.twitter.thrift.descriptors.ContainerType = underlying.containerTypeOrThrow
  override def containerTypeIsSet: Boolean = underlying.containerTypeIsSet
// field/proxy_ref.ssp
  override def typerefOption: Option[com.twitter.thrift.descriptors.Typeref] = underlying.typerefOption
  override def typerefOrNull: com.twitter.thrift.descriptors.Typeref = underlying.typerefOrNull
  override def typerefOrThrow: com.twitter.thrift.descriptors.Typeref = underlying.typerefOrThrow
  override def typerefIsSet: Boolean = underlying.typerefIsSet

  override def compare(that: SimpleType): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): SimpleType = underlying.copy(
    baseType = baseType,
    containerType = containerType,
    typeref = typeref
  )

  override def mutableCopy(): SimpleType.Mutable = underlying.mutableCopy()

  override def mergeCopy(that: SimpleType): SimpleType = underlying.mergeCopy(that)

  override def mutable: SimpleType.Mutable = underlying.mutable

  override def deepCopy(): SimpleType = underlying.deepCopy()

  override def fieldForId(id: Int): SimpleType._Fields = underlying.fieldForId(id)
  override def isSet(field: SimpleType._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: SimpleType._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: SimpleType._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}

trait MutableSimpleType extends SimpleType {
  def baseType_=(x: com.twitter.thrift.descriptors.BaseType): Unit
  def baseTypeUnset(): Unit
  def containerType_=(x: com.twitter.thrift.descriptors.ContainerType): Unit
  def containerTypeUnset(): Unit
  def typeref_=(x: com.twitter.thrift.descriptors.Typeref): Unit
  def typerefUnset(): Unit

  def merge(that: SimpleType): Unit

  def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): SimpleType.Mutable

  override def mutable: SimpleType.Mutable = this
}

trait MutableSimpleTypeProxy extends MutableSimpleType with SimpleTypeProxy {
  protected def underlying: MutableSimpleType

  override def baseType_=(x: com.twitter.thrift.descriptors.BaseType): Unit = { underlying.baseType_=(x) }
  override def baseTypeUnset(): Unit = { underlying.baseTypeUnset() }
  override def containerType_=(x: com.twitter.thrift.descriptors.ContainerType): Unit = { underlying.containerType_=(x) }
  override def containerTypeUnset(): Unit = { underlying.containerTypeUnset() }
  override def typeref_=(x: com.twitter.thrift.descriptors.Typeref): Unit = { underlying.typeref_=(x) }
  override def typerefUnset(): Unit = { underlying.typerefUnset() }

  override def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): SimpleType.Mutable = underlying.copy(
    baseType = baseType,
    containerType = containerType,
    typeref = typeref
  )

  override def merge(that: SimpleType): Unit = underlying.merge(that)
}



final class RawSimpleType extends MutableSimpleType {
  override def meta: SimpleType.type = SimpleType

  // Field #1 - baseType
  private var _baseType: com.twitter.thrift.descriptors.BaseType = null  // Underlying type: com.twitter.thrift.descriptors.BaseType
  override def baseType_=(x: com.twitter.thrift.descriptors.BaseType): Unit = { _baseType = x }
  override def baseTypeOption: Option[com.twitter.thrift.descriptors.BaseType] = if (baseTypeIsSet) Some(_baseType) else None
  override def baseTypeOrNull: com.twitter.thrift.descriptors.BaseType = _baseType
  override def baseTypeOrThrow: com.twitter.thrift.descriptors.BaseType = if (baseTypeIsSet) _baseType else throw new java.lang.NullPointerException
  override def baseTypeIsSet: Boolean = _baseType != null
  override def baseTypeUnset(): Unit = { _baseType = null }
  // Field #2 - containerType
  private var _containerType: com.twitter.thrift.descriptors.ContainerType = null  // Underlying type: com.twitter.thrift.descriptors.ContainerType
  override def containerType_=(x: com.twitter.thrift.descriptors.ContainerType): Unit = { _containerType = x }
  override def containerTypeOption: Option[com.twitter.thrift.descriptors.ContainerType] = if (containerTypeIsSet) Some(_containerType) else None
  override def containerTypeOrNull: com.twitter.thrift.descriptors.ContainerType = _containerType
  override def containerTypeOrThrow: com.twitter.thrift.descriptors.ContainerType = if (containerTypeIsSet) _containerType else throw new java.lang.NullPointerException
  override def containerTypeIsSet: Boolean = _containerType != null
  override def containerTypeUnset(): Unit = { _containerType = null }
  // Field #3 - typeref
  private var _typeref: com.twitter.thrift.descriptors.Typeref = null  // Underlying type: com.twitter.thrift.descriptors.Typeref
  override def typeref_=(x: com.twitter.thrift.descriptors.Typeref): Unit = { _typeref = x }
  override def typerefOption: Option[com.twitter.thrift.descriptors.Typeref] = if (typerefIsSet) Some(_typeref) else None
  override def typerefOrNull: com.twitter.thrift.descriptors.Typeref = _typeref
  override def typerefOrThrow: com.twitter.thrift.descriptors.Typeref = if (typerefIsSet) _typeref else throw new java.lang.NullPointerException
  override def typerefIsSet: Boolean = _typeref != null
  override def typerefUnset(): Unit = { _typeref = null }


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    validate()
    oprot.writeStructBegin(SimpleType.SIMPLETYPE_DESC)
    if (baseTypeIsSet) {
      oprot.writeFieldBegin(SimpleType.BASETYPE_DESC)
      _baseType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (containerTypeIsSet) {
      oprot.writeFieldBegin(SimpleType.CONTAINERTYPE_DESC)
      _containerType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (typerefIsSet) {
      oprot.writeFieldBegin(SimpleType.TYPEREF_DESC)
      _typeref.write(oprot)
      oprot.writeFieldEnd()
    }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        SimpleType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // baseType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _baseType = ({
                val s = com.twitter.thrift.descriptors.BaseType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // containerType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _containerType = ({
                val s = com.twitter.thrift.descriptors.ContainerType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // typeref

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _typeref = ({
                val s = com.twitter.thrift.descriptors.Typeref.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure SimpleType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
    validate()
  }

  override def merge(that: SimpleType): Unit = {
    if (that.baseTypeIsSet && !this.baseTypeIsSet) {
      this.baseType_=(that.baseTypeOrNull)
    }
    if (that.containerTypeIsSet && !this.containerTypeIsSet) {
      this.containerType_=(that.containerTypeOrNull)
    }
    if (that.typerefIsSet && !this.typerefIsSet) {
      this.typeref_=(that.typerefOrNull)
    }
  }

  override def mergeCopy(that: SimpleType): SimpleType = {
    val ret = SimpleType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: SimpleType => this.equals(o)
    case _ => false
  }

  def equals(that: SimpleType): Boolean = {
    that != null &&
    (if (this.baseTypeIsSet) (that.baseTypeIsSet && this.baseTypeOrNull == that.baseTypeOrNull) else !that.baseTypeIsSet) &&
    (if (this.containerTypeIsSet) (that.containerTypeIsSet && this.containerTypeOrNull == that.containerTypeOrNull) else !that.containerTypeIsSet) &&
    (if (this.typerefIsSet) (that.typerefIsSet && this.typerefOrNull == that.typerefOrNull) else !that.typerefIsSet) &&
    true
  }

  override def hashCode(): Int = {
    val hasher = new scala.util.MurmurHash[AnyRef](0)  // We use a fixed seed, for consistency.
    if (baseTypeIsSet) hasher.append(_baseType.##)
    if (containerTypeIsSet) hasher.append(_containerType.##)
    if (typerefIsSet) hasher.append(_typeref.##)
    hasher.hash
  }

  def validate(): Boolean = {
    // TODO(benjy): Implement checks that all required fields are set.
    true
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (baseTypeIsSet) ret = baseTypeOrNull :: ret
    if (containerTypeIsSet) ret = containerTypeOrNull :: ret
    if (typerefIsSet) ret = typerefOrNull :: ret
    ret.reverse
  }

  override def clear() {
    baseTypeUnset()
    containerTypeUnset()
    typerefUnset()
  }

  def fieldForId(id: Int): SimpleType._Fields = id match {
    case 1 => SimpleType._Fields.baseType
    case 2 => SimpleType._Fields.containerType
    case 3 => SimpleType._Fields.typeref
    case _ => null
  }

  def isSet(field: SimpleType._Fields): Boolean = field match {
    case SimpleType._Fields.baseType => baseTypeIsSet
    case SimpleType._Fields.containerType => containerTypeIsSet
    case SimpleType._Fields.typeref => typerefIsSet
    case _ => false
  }

  def getFieldValue(field: SimpleType._Fields): AnyRef = field match {
    case SimpleType._Fields.baseType => baseTypeOrNull.asInstanceOf[AnyRef]
    case SimpleType._Fields.containerType => containerTypeOrNull.asInstanceOf[AnyRef]
    case SimpleType._Fields.typeref => typerefOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: SimpleType._Fields, value: AnyRef) {
    field match {
      case SimpleType._Fields.baseType => baseType_=(value.asInstanceOf[com.twitter.thrift.descriptors.BaseType])
      case SimpleType._Fields.containerType => containerType_=(value.asInstanceOf[com.twitter.thrift.descriptors.ContainerType])
      case SimpleType._Fields.typeref => typeref_=(value.asInstanceOf[com.twitter.thrift.descriptors.Typeref])
      case _ =>
    }
  }

  override def deepCopy(): SimpleType.Raw = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = SimpleType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): SimpleType.Raw = {
    val ret = new SimpleType.Raw
    if (baseType != null) ret.baseType_=(baseType)
    if (containerType != null) ret.containerType_=(containerType)
    if (typeref != null) ret.typeref_=(typeref)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val indenter = new org.codehaus.jackson.util.DefaultPrettyPrinter.FixedSpaceIndenter
    val pp = new org.codehaus.jackson.util.DefaultPrettyPrinter
    pp.indentObjectsWith(indenter)
    val oprot = new com.foursquare.common.thrift.json.TReadableJSONProtocol(trans, pp)
    write(oprot)
    trans.toString("UTF8")
  }
}


