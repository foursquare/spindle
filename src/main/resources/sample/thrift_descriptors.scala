
/**
 * GENERATED CODE - DO NOT EDIT!
 * Generated by foursquare.thrift.codegen v3.0.0-M16
 * 

 */


package com.twitter.thrift.descriptors

import scalaj.collection.Imports._
import com.twitter.thrift.descriptors.java_thrift_descriptors._



sealed abstract class SimpleBaseType private (
    override val id: Int,
    override val name: String,
    override val stringValue: String
) extends com.foursquare.spindle.Enum[SimpleBaseType] with JavaSimpleBaseType with org.apache.thrift.TEnum {
  override def toString: String = stringValue
  override def getValue: Int = id
  override def meta = SimpleBaseType
}

object SimpleBaseType extends com.foursquare.spindle.EnumMeta[SimpleBaseType] {

    object BOOL extends SimpleBaseType(0, "BOOL", "BOOL")
    object BYTE extends SimpleBaseType(1, "BYTE", "BYTE")
    object I16 extends SimpleBaseType(2, "I16", "I16")
    object I32 extends SimpleBaseType(3, "I32", "I32")
    object I64 extends SimpleBaseType(4, "I64", "I64")
    object DOUBLE extends SimpleBaseType(5, "DOUBLE", "DOUBLE")
    object STRING extends SimpleBaseType(6, "STRING", "STRING")
    object BINARY extends SimpleBaseType(7, "BINARY", "BINARY")

  final case class UnknownWireValue(val v: Any) extends SimpleBaseType(if (v.isInstanceOf[Int]) v.asInstanceOf[Int] else -1, "?", if (v.isInstanceOf[String]) v.asInstanceOf[String] else "?")

  override val values: Vector[SimpleBaseType] =
    Vector(
      BOOL,
      BYTE,
      I16,
      I32,
      I64,
      DOUBLE,
      STRING,
      BINARY
    )

  override def findByIdOrNull(id: Int): SimpleBaseType = id match {
    case 0 => BOOL
    case 1 => BYTE
    case 2 => I16
    case 3 => I32
    case 4 => I64
    case 5 => DOUBLE
    case 6 => STRING
    case 7 => BINARY
    case _ => null
  }

  override def findByIdOrUnknown(id: Int): SimpleBaseType = findByIdOrNull(id) match {
    case null => new UnknownWireValue(id)
    case x: SimpleBaseType => x
  }

  override def findByNameOrNull(name: String): SimpleBaseType = name match {
    case "BOOL" => BOOL
    case "BYTE" => BYTE
    case "I16" => I16
    case "I32" => I32
    case "I64" => I64
    case "DOUBLE" => DOUBLE
    case "STRING" => STRING
    case "BINARY" => BINARY
    case _ => null
  }

  override def findByStringValueOrNull(v: String): SimpleBaseType = v match {
    case "BOOL" => SimpleBaseType.BOOL
    case "BYTE" => SimpleBaseType.BYTE
    case "I16" => SimpleBaseType.I16
    case "I32" => SimpleBaseType.I32
    case "I64" => SimpleBaseType.I64
    case "DOUBLE" => SimpleBaseType.DOUBLE
    case "STRING" => SimpleBaseType.STRING
    case "BINARY" => SimpleBaseType.BINARY
    case _ => null
  }

  override def findByStringValueOrUnknown(v: String): SimpleBaseType = findByStringValueOrNull(v) match {
    case null => new UnknownWireValue(v)
    case x: SimpleBaseType => x
  }
}

sealed abstract class Requiredness private (
    override val id: Int,
    override val name: String,
    override val stringValue: String
) extends com.foursquare.spindle.Enum[Requiredness] with JavaRequiredness with org.apache.thrift.TEnum {
  override def toString: String = stringValue
  override def getValue: Int = id
  override def meta = Requiredness
}

object Requiredness extends com.foursquare.spindle.EnumMeta[Requiredness] {

    object REQUIRED extends Requiredness(0, "REQUIRED", "REQUIRED")
    object OPTIONAL extends Requiredness(1, "OPTIONAL", "OPTIONAL")

  final case class UnknownWireValue(val v: Any) extends Requiredness(if (v.isInstanceOf[Int]) v.asInstanceOf[Int] else -1, "?", if (v.isInstanceOf[String]) v.asInstanceOf[String] else "?")

  override val values: Vector[Requiredness] =
    Vector(
      REQUIRED,
      OPTIONAL
    )

  override def findByIdOrNull(id: Int): Requiredness = id match {
    case 0 => REQUIRED
    case 1 => OPTIONAL
    case _ => null
  }

  override def findByIdOrUnknown(id: Int): Requiredness = findByIdOrNull(id) match {
    case null => new UnknownWireValue(id)
    case x: Requiredness => x
  }

  override def findByNameOrNull(name: String): Requiredness = name match {
    case "REQUIRED" => REQUIRED
    case "OPTIONAL" => OPTIONAL
    case _ => null
  }

  override def findByStringValueOrNull(v: String): Requiredness = v match {
    case "REQUIRED" => Requiredness.REQUIRED
    case "OPTIONAL" => Requiredness.OPTIONAL
    case _ => null
  }

  override def findByStringValueOrUnknown(v: String): Requiredness = findByStringValueOrNull(v) match {
    case null => new UnknownWireValue(v)
    case x: Requiredness => x
  }
}




object Include extends IncludeMeta {


  object Builder {
    sealed trait HasPath

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasPath
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Include] (private var obj: RawInclude) {
    def path(v: String): Include.Builder[State with Builder.HasPath] = {
      obj.path_=(v)
      this.asInstanceOf[Include.Builder[State with Builder.HasPath]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasPath): MutableInclude = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Include.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasPath): Include = resultMutable()(ev0)
  }

  def newBuilder: Include.Builder.AllUnspecified = new Builder(Include.createRawRecord)

  implicit val companionProvider: IncludeCompanionProvider = new IncludeCompanionProvider
}

class IncludeMeta
    extends JavaIncludeMeta[Include, RawInclude, IncludeMeta]
    with com.foursquare.spindle.RecordProvider[Include] {
  override def recordName: String = "Include"


  // Thrift descriptors.
  val INCLUDE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Include")

  val PATH_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "path",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "path" -> PATH_FDESC
  )

  object _Fields {
    case object path extends _Fields(1, "path")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.path
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Include = createRawRecord
  override def createRawRecord: RawInclude = new RawInclude

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Include] = {
    if (x.isInstanceOf[Include]) Some(x.asInstanceOf[Include]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val path =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Include, IncludeMeta](
      name = "path",
      longName = "path",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.pathOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Include], v: String) => { r.asInstanceOf[RawInclude].path_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Include]) => { r.asInstanceOf[RawInclude].pathUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Include, IncludeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Include, IncludeMeta]](
      path
    )


  def apply(
      path: String
  ): Include = {
    val ret = this.createRawRecord
    ret.path_=(path)
    ret
  }
}

class IncludeCompanionProvider extends com.foursquare.spindle.CompanionProvider[Include] {
  type CompanionT = IncludeMeta
  override def provide: IncludeMeta = Include
}


trait Include
    extends JavaInclude[
      Include, RawInclude, IncludeMeta
    ]
    with org.apache.thrift.TBase[Include, Include._Fields] {

  override def meta: IncludeMeta

  override def compare(that: Include): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.pathIsSet.compareTo(that.pathIsSet)
      cmp != 0 }) cmp
    else if (this.pathIsSet && {
      cmp = this.pathOrNull.compareTo(that.pathOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Include): Boolean = { this.compare(that) < 0 }
  override def >(that: Include): Boolean = { this.compare(that) > 0 }
  override def <=(that: Include): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Include): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Include): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Include

  def copy(
      path: String = pathOrNull
  ): Include

  def mutableCopy(): MutableInclude = {
    val ret = Include.createRawRecord

    if (pathIsSet) ret.path_=(pathOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableInclude

  def toBuilder(): Include.Builder.AllSpecified = {
    val ret = new Include.Builder(Include.createRawRecord)

    if (pathIsSet) ret.path(pathOrNull)
    ret
  }

  def mergeCopy(that: Include): Include

}

trait MutableInclude extends Include
    with JavaIncludeMutable[
      Include, RawInclude, IncludeMeta
    ] {
  def path_=(x: String): Unit
  def pathUnset(): Unit

  def merge(that: Include): Unit

  def copy(
      path: String = pathOrNull
  ): MutableInclude

  override def mutable: MutableInclude = this
}



final class RawInclude extends JavaIncludeRaw[
      Include, RawInclude, IncludeMeta
    ]
    with MutableInclude {
  override def meta: IncludeMeta = Include

  // fields
  // Field #1 - path
  private var _path: String = null  // Underlying type: String
  override def path: String = pathOrThrow
  override def path_=(x: String): Unit = { _path = x }
  override def pathOption: Option[String] = if (pathIsSet) Some(_path) else None
  override def pathOrNull: String = _path
  override def pathOrThrow: String = if (pathIsSet) _path else throw new java.lang.NullPointerException("field path of Include missing")
  override def pathIsSet: Boolean = _path != null
  override def pathUnset(): Unit = { _path = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Include.INCLUDE_SDESC)
    if (pathIsSet) {
      oprot.writeFieldBegin(Include.PATH_FDESC)
      oprot.writeString(_path)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Include.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // path

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _path = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Include".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Include): Unit = {
    if (that.pathIsSet && !this.pathIsSet) {
      this.path_=(that.pathOrNull)
    }
  }

  override def mergeCopy(that: Include): Include = {
    val ret = Include.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Include => this.equals(o)
    case _ => false
  }

  def equals(that: Include): Boolean = {
    that != null &&
    (if (this.pathIsSet) (that.pathIsSet && this.pathOrNull == that.pathOrNull) else !that.pathIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (pathIsSet) hasher.append(_path.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (pathIsSet) ret = pathOrNull :: ret
    ret.reverse
  }

  override def clear() {
    pathUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Include._Fields = id match {
    case 1 => Include._Fields.path
    case _ => null
  }

  def isSet(field: Include._Fields): Boolean = field match {
    case Include._Fields.path => pathIsSet
    case _ => false
  }

  def getFieldValue(field: Include._Fields): AnyRef = field match {
    case Include._Fields.path => pathOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Include._Fields, value: AnyRef) {
    field match {
      case Include._Fields.path => path_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawInclude = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Include.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      path: String = pathOrNull
  ): RawInclude = {
    val ret = new RawInclude
    if (path != null) ret.path_=(path)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Namespace extends NamespaceMeta {


  object Builder {
    sealed trait HasLanguage
    sealed trait HasName

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasLanguage with HasName
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Namespace] (private var obj: RawNamespace) {
    def language(v: String): Namespace.Builder[State with Builder.HasLanguage] = {
      obj.language_=(v)
      this.asInstanceOf[Namespace.Builder[State with Builder.HasLanguage]]
    }

    def name(v: String): Namespace.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Namespace.Builder[State with Builder.HasName]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasLanguage, ev1: State <:< Builder.HasName): MutableNamespace = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Namespace.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasLanguage, ev1: State <:< Builder.HasName): Namespace = resultMutable()(ev0, ev1)
  }

  def newBuilder: Namespace.Builder.AllUnspecified = new Builder(Namespace.createRawRecord)

  implicit val companionProvider: NamespaceCompanionProvider = new NamespaceCompanionProvider
}

class NamespaceMeta
    extends JavaNamespaceMeta[Namespace, RawNamespace, NamespaceMeta]
    with com.foursquare.spindle.RecordProvider[Namespace] {
  override def recordName: String = "Namespace"


  // Thrift descriptors.
  val NAMESPACE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Namespace")

  val LANGUAGE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "language",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "language" -> LANGUAGE_FDESC,
    "name" -> NAME_FDESC
  )

  object _Fields {
    case object language extends _Fields(1, "language")
    case object name extends _Fields(2, "name")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.language,
    2.toShort -> _Fields.name
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Namespace = createRawRecord
  override def createRawRecord: RawNamespace = new RawNamespace

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Namespace] = {
    if (x.isInstanceOf[Namespace]) Some(x.asInstanceOf[Namespace]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val language =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Namespace, NamespaceMeta](
      name = "language",
      longName = "language",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.languageOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Namespace], v: String) => { r.asInstanceOf[RawNamespace].language_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Namespace]) => { r.asInstanceOf[RawNamespace].languageUnset() },
      manifest = manifest[String]
    )

  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Namespace, NamespaceMeta](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Namespace], v: String) => { r.asInstanceOf[RawNamespace].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Namespace]) => { r.asInstanceOf[RawNamespace].nameUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Namespace, NamespaceMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Namespace, NamespaceMeta]](
      language,
      name
    )


  def apply(
      language: String,
      name: String
  ): Namespace = {
    val ret = this.createRawRecord
    ret.language_=(language)
    ret.name_=(name)
    ret
  }
}

class NamespaceCompanionProvider extends com.foursquare.spindle.CompanionProvider[Namespace] {
  type CompanionT = NamespaceMeta
  override def provide: NamespaceMeta = Namespace
}


trait Namespace
    extends JavaNamespace[
      Namespace, RawNamespace, NamespaceMeta
    ]
    with org.apache.thrift.TBase[Namespace, Namespace._Fields] {

  override def meta: NamespaceMeta

  override def compare(that: Namespace): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.languageIsSet.compareTo(that.languageIsSet)
      cmp != 0 }) cmp
    else if (this.languageIsSet && {
      cmp = this.languageOrNull.compareTo(that.languageOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Namespace): Boolean = { this.compare(that) < 0 }
  override def >(that: Namespace): Boolean = { this.compare(that) > 0 }
  override def <=(that: Namespace): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Namespace): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Namespace): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Namespace

  def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): Namespace

  def mutableCopy(): MutableNamespace = {
    val ret = Namespace.createRawRecord

    if (languageIsSet) ret.language_=(languageOrNull)

    if (nameIsSet) ret.name_=(nameOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableNamespace

  def toBuilder(): Namespace.Builder.AllSpecified = {
    val ret = new Namespace.Builder(Namespace.createRawRecord)

    if (languageIsSet) ret.language(languageOrNull)

    if (nameIsSet) ret.name(nameOrNull)
    ret
  }

  def mergeCopy(that: Namespace): Namespace

}

trait MutableNamespace extends Namespace
    with JavaNamespaceMutable[
      Namespace, RawNamespace, NamespaceMeta
    ] {
  def language_=(x: String): Unit
  def languageUnset(): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit

  def merge(that: Namespace): Unit

  def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): MutableNamespace

  override def mutable: MutableNamespace = this
}



final class RawNamespace extends JavaNamespaceRaw[
      Namespace, RawNamespace, NamespaceMeta
    ]
    with MutableNamespace {
  override def meta: NamespaceMeta = Namespace

  // fields
  // Field #1 - language
  private var _language: String = null  // Underlying type: String
  override def language: String = languageOrThrow
  override def language_=(x: String): Unit = { _language = x }
  override def languageOption: Option[String] = if (languageIsSet) Some(_language) else None
  override def languageOrNull: String = _language
  override def languageOrThrow: String = if (languageIsSet) _language else throw new java.lang.NullPointerException("field language of Namespace missing")
  override def languageIsSet: Boolean = _language != null
  override def languageUnset(): Unit = { _language = null }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Namespace missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Namespace.NAMESPACE_SDESC)
    if (languageIsSet) {
      oprot.writeFieldBegin(Namespace.LANGUAGE_FDESC)
      oprot.writeString(_language)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(Namespace.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Namespace.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // language

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _language = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Namespace".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Namespace): Unit = {
    if (that.languageIsSet && !this.languageIsSet) {
      this.language_=(that.languageOrNull)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
  }

  override def mergeCopy(that: Namespace): Namespace = {
    val ret = Namespace.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Namespace => this.equals(o)
    case _ => false
  }

  def equals(that: Namespace): Boolean = {
    that != null &&
    (if (this.languageIsSet) (that.languageIsSet && this.languageOrNull == that.languageOrNull) else !that.languageIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (languageIsSet) hasher.append(_language.##)
    if (nameIsSet) hasher.append(_name.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (languageIsSet) ret = languageOrNull :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    ret.reverse
  }

  override def clear() {
    languageUnset()
    nameUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Namespace._Fields = id match {
    case 1 => Namespace._Fields.language
    case 2 => Namespace._Fields.name
    case _ => null
  }

  def isSet(field: Namespace._Fields): Boolean = field match {
    case Namespace._Fields.language => languageIsSet
    case Namespace._Fields.name => nameIsSet
    case _ => false
  }

  def getFieldValue(field: Namespace._Fields): AnyRef = field match {
    case Namespace._Fields.language => languageOrNull.asInstanceOf[AnyRef]
    case Namespace._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Namespace._Fields, value: AnyRef) {
    field match {
      case Namespace._Fields.language => language_=(value.asInstanceOf[String])
      case Namespace._Fields.name => name_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawNamespace = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Namespace.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      language: String = languageOrNull,
      name: String = nameOrNull
  ): RawNamespace = {
    val ret = new RawNamespace
    if (language != null) ret.language_=(language)
    if (name != null) ret.name_=(name)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Annotation extends AnnotationMeta {


  object Builder {
    sealed trait HasKey
    sealed trait HasValue

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasKey with HasValue
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Annotation] (private var obj: RawAnnotation) {
    def key(v: String): Annotation.Builder[State with Builder.HasKey] = {
      obj.key_=(v)
      this.asInstanceOf[Annotation.Builder[State with Builder.HasKey]]
    }

    def value(v: String): Annotation.Builder[State with Builder.HasValue] = {
      obj.value_=(v)
      this.asInstanceOf[Annotation.Builder[State with Builder.HasValue]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasKey, ev1: State <:< Builder.HasValue): MutableAnnotation = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Annotation.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasKey, ev1: State <:< Builder.HasValue): Annotation = resultMutable()(ev0, ev1)
  }

  def newBuilder: Annotation.Builder.AllUnspecified = new Builder(Annotation.createRawRecord)

  implicit val companionProvider: AnnotationCompanionProvider = new AnnotationCompanionProvider
}

class AnnotationMeta
    extends JavaAnnotationMeta[Annotation, RawAnnotation, AnnotationMeta]
    with com.foursquare.spindle.RecordProvider[Annotation] {
  override def recordName: String = "Annotation"


  // Thrift descriptors.
  val ANNOTATION_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Annotation")

  val KEY_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "key",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val VALUE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "value",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "key" -> KEY_FDESC,
    "value" -> VALUE_FDESC
  )

  object _Fields {
    case object key extends _Fields(1, "key")
    case object value extends _Fields(2, "value")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.key,
    2.toShort -> _Fields.value
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Annotation = createRawRecord
  override def createRawRecord: RawAnnotation = new RawAnnotation

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Annotation] = {
    if (x.isInstanceOf[Annotation]) Some(x.asInstanceOf[Annotation]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val key =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Annotation, AnnotationMeta](
      name = "key",
      longName = "key",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.keyOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Annotation], v: String) => { r.asInstanceOf[RawAnnotation].key_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Annotation]) => { r.asInstanceOf[RawAnnotation].keyUnset() },
      manifest = manifest[String]
    )

  val value =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Annotation, AnnotationMeta](
      name = "value",
      longName = "value",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.valueOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Annotation], v: String) => { r.asInstanceOf[RawAnnotation].value_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Annotation]) => { r.asInstanceOf[RawAnnotation].valueUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Annotation, AnnotationMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Annotation, AnnotationMeta]](
      key,
      value
    )


  def apply(
      key: String,
      value: String
  ): Annotation = {
    val ret = this.createRawRecord
    ret.key_=(key)
    ret.value_=(value)
    ret
  }
}

class AnnotationCompanionProvider extends com.foursquare.spindle.CompanionProvider[Annotation] {
  type CompanionT = AnnotationMeta
  override def provide: AnnotationMeta = Annotation
}


trait Annotation
    extends JavaAnnotation[
      Annotation, RawAnnotation, AnnotationMeta
    ]
    with org.apache.thrift.TBase[Annotation, Annotation._Fields] {

  override def meta: AnnotationMeta

  override def compare(that: Annotation): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.keyIsSet.compareTo(that.keyIsSet)
      cmp != 0 }) cmp
    else if (this.keyIsSet && {
      cmp = this.keyOrNull.compareTo(that.keyOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueIsSet.compareTo(that.valueIsSet)
      cmp != 0 }) cmp
    else if (this.valueIsSet && {
      cmp = this.valueOrNull.compareTo(that.valueOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Annotation): Boolean = { this.compare(that) < 0 }
  override def >(that: Annotation): Boolean = { this.compare(that) > 0 }
  override def <=(that: Annotation): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Annotation): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Annotation): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Annotation

  def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): Annotation

  def mutableCopy(): MutableAnnotation = {
    val ret = Annotation.createRawRecord

    if (keyIsSet) ret.key_=(keyOrNull)

    if (valueIsSet) ret.value_=(valueOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableAnnotation

  def toBuilder(): Annotation.Builder.AllSpecified = {
    val ret = new Annotation.Builder(Annotation.createRawRecord)

    if (keyIsSet) ret.key(keyOrNull)

    if (valueIsSet) ret.value(valueOrNull)
    ret
  }

  def mergeCopy(that: Annotation): Annotation

}

trait MutableAnnotation extends Annotation
    with JavaAnnotationMutable[
      Annotation, RawAnnotation, AnnotationMeta
    ] {
  def key_=(x: String): Unit
  def keyUnset(): Unit
  def value_=(x: String): Unit
  def valueUnset(): Unit

  def merge(that: Annotation): Unit

  def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): MutableAnnotation

  override def mutable: MutableAnnotation = this
}



final class RawAnnotation extends JavaAnnotationRaw[
      Annotation, RawAnnotation, AnnotationMeta
    ]
    with MutableAnnotation {
  override def meta: AnnotationMeta = Annotation

  // fields
  // Field #1 - key
  private var _key: String = null  // Underlying type: String
  override def key: String = keyOrThrow
  override def key_=(x: String): Unit = { _key = x }
  override def keyOption: Option[String] = if (keyIsSet) Some(_key) else None
  override def keyOrNull: String = _key
  override def keyOrThrow: String = if (keyIsSet) _key else throw new java.lang.NullPointerException("field key of Annotation missing")
  override def keyIsSet: Boolean = _key != null
  override def keyUnset(): Unit = { _key = null }
  // Field #2 - value
  private var _value: String = null  // Underlying type: String
  override def value: String = valueOrThrow
  override def value_=(x: String): Unit = { _value = x }
  override def valueOption: Option[String] = if (valueIsSet) Some(_value) else None
  override def valueOrNull: String = _value
  override def valueOrThrow: String = if (valueIsSet) _value else throw new java.lang.NullPointerException("field value of Annotation missing")
  override def valueIsSet: Boolean = _value != null
  override def valueUnset(): Unit = { _value = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Annotation.ANNOTATION_SDESC)
    if (keyIsSet) {
      oprot.writeFieldBegin(Annotation.KEY_FDESC)
      oprot.writeString(_key)
      oprot.writeFieldEnd()
    }
    if (valueIsSet) {
      oprot.writeFieldBegin(Annotation.VALUE_FDESC)
      oprot.writeString(_value)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Annotation.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // key

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _key = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // value

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _value = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Annotation".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Annotation): Unit = {
    if (that.keyIsSet && !this.keyIsSet) {
      this.key_=(that.keyOrNull)
    }
    if (that.valueIsSet && !this.valueIsSet) {
      this.value_=(that.valueOrNull)
    }
  }

  override def mergeCopy(that: Annotation): Annotation = {
    val ret = Annotation.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Annotation => this.equals(o)
    case _ => false
  }

  def equals(that: Annotation): Boolean = {
    that != null &&
    (if (this.keyIsSet) (that.keyIsSet && this.keyOrNull == that.keyOrNull) else !that.keyIsSet) &&
    (if (this.valueIsSet) (that.valueIsSet && this.valueOrNull == that.valueOrNull) else !that.valueIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (keyIsSet) hasher.append(_key.##)
    if (valueIsSet) hasher.append(_value.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (keyIsSet) ret = keyOrNull :: ret
    if (valueIsSet) ret = valueOrNull :: ret
    ret.reverse
  }

  override def clear() {
    keyUnset()
    valueUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Annotation._Fields = id match {
    case 1 => Annotation._Fields.key
    case 2 => Annotation._Fields.value
    case _ => null
  }

  def isSet(field: Annotation._Fields): Boolean = field match {
    case Annotation._Fields.key => keyIsSet
    case Annotation._Fields.value => valueIsSet
    case _ => false
  }

  def getFieldValue(field: Annotation._Fields): AnyRef = field match {
    case Annotation._Fields.key => keyOrNull.asInstanceOf[AnyRef]
    case Annotation._Fields.value => valueOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Annotation._Fields, value: AnyRef) {
    field match {
      case Annotation._Fields.key => key_=(value.asInstanceOf[String])
      case Annotation._Fields.value => value_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawAnnotation = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Annotation.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      key: String = keyOrNull,
      value: String = valueOrNull
  ): RawAnnotation = {
    val ret = new RawAnnotation
    if (key != null) ret.key_=(key)
    if (value != null) ret.value_=(value)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object BaseType extends BaseTypeMeta {


  object Builder {
    sealed trait HasSimpleBaseType

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasSimpleBaseType
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[BaseType] (private var obj: RawBaseType) {
    def simpleBaseType(v: com.twitter.thrift.descriptors.SimpleBaseType): BaseType.Builder[State with Builder.HasSimpleBaseType] = {
      obj.simpleBaseType_=(v)
      this.asInstanceOf[BaseType.Builder[State with Builder.HasSimpleBaseType]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): BaseType.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): BaseType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasSimpleBaseType): MutableBaseType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("BaseType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasSimpleBaseType): BaseType = resultMutable()(ev0)
  }

  def newBuilder: BaseType.Builder.AllUnspecified = new Builder(BaseType.createRawRecord)

  implicit val companionProvider: BaseTypeCompanionProvider = new BaseTypeCompanionProvider
}

class BaseTypeMeta
    extends JavaBaseTypeMeta[BaseType, RawBaseType, BaseTypeMeta]
    with com.foursquare.spindle.RecordProvider[BaseType] {
  override def recordName: String = "BaseType"


  // Thrift descriptors.
  val BASETYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("BaseType")

  val SIMPLEBASETYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "simpleBaseType",
      org.apache.thrift.protocol.TType.I32,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "simpleBaseType" -> SIMPLEBASETYPE_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object simpleBaseType extends _Fields(1, "simpleBaseType")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.simpleBaseType,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: BaseType = createRawRecord
  override def createRawRecord: RawBaseType = new RawBaseType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[BaseType] = {
    if (x.isInstanceOf[BaseType]) Some(x.asInstanceOf[BaseType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val simpleBaseType =

    new com.foursquare.spindle.OptionalFieldDescriptor[com.twitter.thrift.descriptors.SimpleBaseType, BaseType, BaseTypeMeta](
      name = "simpleBaseType",
      longName = "simpleBaseType",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.simpleBaseTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[BaseType], v: com.twitter.thrift.descriptors.SimpleBaseType) => { r.asInstanceOf[RawBaseType].simpleBaseType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[BaseType]) => { r.asInstanceOf[RawBaseType].simpleBaseTypeUnset() },
      manifest = manifest[com.twitter.thrift.descriptors.SimpleBaseType]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], BaseType, BaseTypeMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[BaseType], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawBaseType].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[BaseType]) => { r.asInstanceOf[RawBaseType].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, BaseType, BaseTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, BaseType, BaseTypeMeta]](
      simpleBaseType,
      __annotations
    )


  def apply(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): BaseType = {
    val ret = this.createRawRecord
    ret.simpleBaseType_=(simpleBaseType)
    ret.__annotations_=(__annotations)
    ret
  }
}

class BaseTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[BaseType] {
  type CompanionT = BaseTypeMeta
  override def provide: BaseTypeMeta = BaseType
}


trait BaseType
    extends JavaBaseType[com.twitter.thrift.descriptors.Annotation,
      BaseType, RawBaseType, BaseTypeMeta
    ]
    with org.apache.thrift.TBase[BaseType, BaseType._Fields] {

  override def meta: BaseTypeMeta

  override def compare(that: BaseType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.simpleBaseTypeIsSet.compareTo(that.simpleBaseTypeIsSet)
      cmp != 0 }) cmp
    else if (this.simpleBaseTypeIsSet && {
      cmp = this.simpleBaseTypeOrNull.compareTo(that.simpleBaseTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: BaseType): Boolean = { this.compare(that) < 0 }
  override def >(that: BaseType): Boolean = { this.compare(that) > 0 }
  override def <=(that: BaseType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: BaseType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: BaseType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): BaseType

  def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): BaseType

  def mutableCopy(): MutableBaseType = {
    val ret = BaseType.createRawRecord

    if (simpleBaseTypeIsSet) ret.simpleBaseType_=(simpleBaseTypeOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableBaseType

  def toBuilder(): BaseType.Builder.AllSpecified = {
    val ret = new BaseType.Builder(BaseType.createRawRecord)

    if (simpleBaseTypeIsSet) ret.simpleBaseType(simpleBaseTypeOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: BaseType): BaseType

}

trait MutableBaseType extends BaseType
    with JavaBaseTypeMutable[com.twitter.thrift.descriptors.Annotation,
      BaseType, RawBaseType, BaseTypeMeta
    ] {
  def simpleBaseType_=(x: com.twitter.thrift.descriptors.SimpleBaseType): Unit
  def simpleBaseTypeUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: BaseType): Unit

  def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableBaseType

  override def mutable: MutableBaseType = this
}



final class RawBaseType extends JavaBaseTypeRaw[com.twitter.thrift.descriptors.Annotation,
      BaseType, RawBaseType, BaseTypeMeta
    ]
    with MutableBaseType {
  override def meta: BaseTypeMeta = BaseType

  // fields
  // Field #1 - simpleBaseType
  private var _simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = null  // Underlying type: com.twitter.thrift.descriptors.SimpleBaseType
  override def simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrThrow
  override def simpleBaseType_=(x: com.twitter.thrift.descriptors.SimpleBaseType): Unit = { _simpleBaseType = x }
  override def simpleBaseTypeOption: Option[com.twitter.thrift.descriptors.SimpleBaseType] = if (simpleBaseTypeIsSet) Some(_simpleBaseType) else None
  override def simpleBaseTypeOrNull: com.twitter.thrift.descriptors.SimpleBaseType = _simpleBaseType
  override def simpleBaseTypeOrThrow: com.twitter.thrift.descriptors.SimpleBaseType = if (simpleBaseTypeIsSet) _simpleBaseType else throw new java.lang.NullPointerException("field simpleBaseType of BaseType missing")
  override def simpleBaseTypeIsSet: Boolean = _simpleBaseType != null
  override def simpleBaseTypeUnset(): Unit = { _simpleBaseType = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of BaseType missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(BaseType.BASETYPE_SDESC)
    if (simpleBaseTypeIsSet) {
      oprot.writeFieldBegin(BaseType.SIMPLEBASETYPE_FDESC)
      oprot.writeI32(_simpleBaseType.getValue())
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(BaseType.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        BaseType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // simpleBaseType

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32 || field_header.`type` == org.apache.thrift.protocol.TType.ENUM) {
              _simpleBaseType = com.twitter.thrift.descriptors.SimpleBaseType.findByIdOrUnknown(iprot.readI32())
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure BaseType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: BaseType): Unit = {
    if (that.simpleBaseTypeIsSet && !this.simpleBaseTypeIsSet) {
      this.simpleBaseType_=(that.simpleBaseTypeOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: BaseType): BaseType = {
    val ret = BaseType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: BaseType => this.equals(o)
    case _ => false
  }

  def equals(that: BaseType): Boolean = {
    that != null &&
    (if (this.simpleBaseTypeIsSet) (that.simpleBaseTypeIsSet && this.simpleBaseTypeOrNull == that.simpleBaseTypeOrNull) else !that.simpleBaseTypeIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (simpleBaseTypeIsSet) hasher.append(_simpleBaseType.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (simpleBaseTypeIsSet) ret = simpleBaseTypeOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    simpleBaseTypeUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): BaseType._Fields = id match {
    case 1 => BaseType._Fields.simpleBaseType
    case 99 => BaseType._Fields.__annotations
    case _ => null
  }

  def isSet(field: BaseType._Fields): Boolean = field match {
    case BaseType._Fields.simpleBaseType => simpleBaseTypeIsSet
    case BaseType._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: BaseType._Fields): AnyRef = field match {
    case BaseType._Fields.simpleBaseType => simpleBaseTypeOrNull.asInstanceOf[AnyRef]
    case BaseType._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: BaseType._Fields, value: AnyRef) {
    field match {
      case BaseType._Fields.simpleBaseType => simpleBaseType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SimpleBaseType])
      case BaseType._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawBaseType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = BaseType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      simpleBaseType: com.twitter.thrift.descriptors.SimpleBaseType = simpleBaseTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawBaseType = {
    val ret = new RawBaseType
    if (simpleBaseType != null) ret.simpleBaseType_=(simpleBaseType)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object ListType extends ListTypeMeta {


  object Builder {
    sealed trait HasElementTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasElementTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[ListType] (private var obj: RawListType) {
    def elementTypeId(v: String): ListType.Builder[State with Builder.HasElementTypeId] = {
      obj.elementTypeId_=(v)
      this.asInstanceOf[ListType.Builder[State with Builder.HasElementTypeId]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasElementTypeId): MutableListType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("ListType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasElementTypeId): ListType = resultMutable()(ev0)
  }

  def newBuilder: ListType.Builder.AllUnspecified = new Builder(ListType.createRawRecord)

  implicit val companionProvider: ListTypeCompanionProvider = new ListTypeCompanionProvider
}

class ListTypeMeta
    extends JavaListTypeMeta[ListType, RawListType, ListTypeMeta]
    with com.foursquare.spindle.RecordProvider[ListType] {
  override def recordName: String = "ListType"


  // Thrift descriptors.
  val LISTTYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("ListType")

  val ELEMENTTYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "elementTypeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "elementTypeId" -> ELEMENTTYPEID_FDESC
  )

  object _Fields {
    case object elementTypeId extends _Fields(1, "elementTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.elementTypeId
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: ListType = createRawRecord
  override def createRawRecord: RawListType = new RawListType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[ListType] = {
    if (x.isInstanceOf[ListType]) Some(x.asInstanceOf[ListType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val elementTypeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, ListType, ListTypeMeta](
      name = "elementTypeId",
      longName = "elementTypeId",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.elementTypeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[ListType], v: String) => { r.asInstanceOf[RawListType].elementTypeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[ListType]) => { r.asInstanceOf[RawListType].elementTypeIdUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, ListType, ListTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, ListType, ListTypeMeta]](
      elementTypeId
    )


  def apply(
      elementTypeId: String
  ): ListType = {
    val ret = this.createRawRecord
    ret.elementTypeId_=(elementTypeId)
    ret
  }
}

class ListTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[ListType] {
  type CompanionT = ListTypeMeta
  override def provide: ListTypeMeta = ListType
}


trait ListType
    extends JavaListType[
      ListType, RawListType, ListTypeMeta
    ]
    with org.apache.thrift.TBase[ListType, ListType._Fields] {

  override def meta: ListTypeMeta

  override def compare(that: ListType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.elementTypeIdIsSet.compareTo(that.elementTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.elementTypeIdIsSet && {
      cmp = this.elementTypeIdOrNull.compareTo(that.elementTypeIdOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: ListType): Boolean = { this.compare(that) < 0 }
  override def >(that: ListType): Boolean = { this.compare(that) > 0 }
  override def <=(that: ListType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: ListType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: ListType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): ListType

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): ListType

  def mutableCopy(): MutableListType = {
    val ret = ListType.createRawRecord

    if (elementTypeIdIsSet) ret.elementTypeId_=(elementTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableListType

  def toBuilder(): ListType.Builder.AllSpecified = {
    val ret = new ListType.Builder(ListType.createRawRecord)

    if (elementTypeIdIsSet) ret.elementTypeId(elementTypeIdOrNull)
    ret
  }

  def mergeCopy(that: ListType): ListType

}

trait MutableListType extends ListType
    with JavaListTypeMutable[
      ListType, RawListType, ListTypeMeta
    ] {
  def elementTypeId_=(x: String): Unit
  def elementTypeIdUnset(): Unit

  def merge(that: ListType): Unit

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): MutableListType

  override def mutable: MutableListType = this
}



final class RawListType extends JavaListTypeRaw[
      ListType, RawListType, ListTypeMeta
    ]
    with MutableListType {
  override def meta: ListTypeMeta = ListType

  // fields
  // Field #1 - elementTypeId
  private var _elementTypeId: String = null  // Underlying type: String
  override def elementTypeId: String = elementTypeIdOrThrow
  override def elementTypeId_=(x: String): Unit = { _elementTypeId = x }
  override def elementTypeIdOption: Option[String] = if (elementTypeIdIsSet) Some(_elementTypeId) else None
  override def elementTypeIdOrNull: String = _elementTypeId
  override def elementTypeIdOrThrow: String = if (elementTypeIdIsSet) _elementTypeId else throw new java.lang.NullPointerException("field elementTypeId of ListType missing")
  override def elementTypeIdIsSet: Boolean = _elementTypeId != null
  override def elementTypeIdUnset(): Unit = { _elementTypeId = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(ListType.LISTTYPE_SDESC)
    if (elementTypeIdIsSet) {
      oprot.writeFieldBegin(ListType.ELEMENTTYPEID_FDESC)
      oprot.writeString(_elementTypeId)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        ListType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // elementTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _elementTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure ListType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: ListType): Unit = {
    if (that.elementTypeIdIsSet && !this.elementTypeIdIsSet) {
      this.elementTypeId_=(that.elementTypeIdOrNull)
    }
  }

  override def mergeCopy(that: ListType): ListType = {
    val ret = ListType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: ListType => this.equals(o)
    case _ => false
  }

  def equals(that: ListType): Boolean = {
    that != null &&
    (if (this.elementTypeIdIsSet) (that.elementTypeIdIsSet && this.elementTypeIdOrNull == that.elementTypeIdOrNull) else !that.elementTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (elementTypeIdIsSet) hasher.append(_elementTypeId.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (elementTypeIdIsSet) ret = elementTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    elementTypeIdUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): ListType._Fields = id match {
    case 1 => ListType._Fields.elementTypeId
    case _ => null
  }

  def isSet(field: ListType._Fields): Boolean = field match {
    case ListType._Fields.elementTypeId => elementTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: ListType._Fields): AnyRef = field match {
    case ListType._Fields.elementTypeId => elementTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: ListType._Fields, value: AnyRef) {
    field match {
      case ListType._Fields.elementTypeId => elementTypeId_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawListType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = ListType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): RawListType = {
    val ret = new RawListType
    if (elementTypeId != null) ret.elementTypeId_=(elementTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object SetType extends SetTypeMeta {


  object Builder {
    sealed trait HasElementTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasElementTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[SetType] (private var obj: RawSetType) {
    def elementTypeId(v: String): SetType.Builder[State with Builder.HasElementTypeId] = {
      obj.elementTypeId_=(v)
      this.asInstanceOf[SetType.Builder[State with Builder.HasElementTypeId]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasElementTypeId): MutableSetType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("SetType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasElementTypeId): SetType = resultMutable()(ev0)
  }

  def newBuilder: SetType.Builder.AllUnspecified = new Builder(SetType.createRawRecord)

  implicit val companionProvider: SetTypeCompanionProvider = new SetTypeCompanionProvider
}

class SetTypeMeta
    extends JavaSetTypeMeta[SetType, RawSetType, SetTypeMeta]
    with com.foursquare.spindle.RecordProvider[SetType] {
  override def recordName: String = "SetType"


  // Thrift descriptors.
  val SETTYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("SetType")

  val ELEMENTTYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "elementTypeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "elementTypeId" -> ELEMENTTYPEID_FDESC
  )

  object _Fields {
    case object elementTypeId extends _Fields(1, "elementTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.elementTypeId
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: SetType = createRawRecord
  override def createRawRecord: RawSetType = new RawSetType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[SetType] = {
    if (x.isInstanceOf[SetType]) Some(x.asInstanceOf[SetType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val elementTypeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, SetType, SetTypeMeta](
      name = "elementTypeId",
      longName = "elementTypeId",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.elementTypeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SetType], v: String) => { r.asInstanceOf[RawSetType].elementTypeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SetType]) => { r.asInstanceOf[RawSetType].elementTypeIdUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, SetType, SetTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, SetType, SetTypeMeta]](
      elementTypeId
    )


  def apply(
      elementTypeId: String
  ): SetType = {
    val ret = this.createRawRecord
    ret.elementTypeId_=(elementTypeId)
    ret
  }
}

class SetTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[SetType] {
  type CompanionT = SetTypeMeta
  override def provide: SetTypeMeta = SetType
}


trait SetType
    extends JavaSetType[
      SetType, RawSetType, SetTypeMeta
    ]
    with org.apache.thrift.TBase[SetType, SetType._Fields] {

  override def meta: SetTypeMeta

  override def compare(that: SetType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.elementTypeIdIsSet.compareTo(that.elementTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.elementTypeIdIsSet && {
      cmp = this.elementTypeIdOrNull.compareTo(that.elementTypeIdOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: SetType): Boolean = { this.compare(that) < 0 }
  override def >(that: SetType): Boolean = { this.compare(that) > 0 }
  override def <=(that: SetType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: SetType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: SetType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): SetType

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): SetType

  def mutableCopy(): MutableSetType = {
    val ret = SetType.createRawRecord

    if (elementTypeIdIsSet) ret.elementTypeId_=(elementTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableSetType

  def toBuilder(): SetType.Builder.AllSpecified = {
    val ret = new SetType.Builder(SetType.createRawRecord)

    if (elementTypeIdIsSet) ret.elementTypeId(elementTypeIdOrNull)
    ret
  }

  def mergeCopy(that: SetType): SetType

}

trait MutableSetType extends SetType
    with JavaSetTypeMutable[
      SetType, RawSetType, SetTypeMeta
    ] {
  def elementTypeId_=(x: String): Unit
  def elementTypeIdUnset(): Unit

  def merge(that: SetType): Unit

  def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): MutableSetType

  override def mutable: MutableSetType = this
}



final class RawSetType extends JavaSetTypeRaw[
      SetType, RawSetType, SetTypeMeta
    ]
    with MutableSetType {
  override def meta: SetTypeMeta = SetType

  // fields
  // Field #1 - elementTypeId
  private var _elementTypeId: String = null  // Underlying type: String
  override def elementTypeId: String = elementTypeIdOrThrow
  override def elementTypeId_=(x: String): Unit = { _elementTypeId = x }
  override def elementTypeIdOption: Option[String] = if (elementTypeIdIsSet) Some(_elementTypeId) else None
  override def elementTypeIdOrNull: String = _elementTypeId
  override def elementTypeIdOrThrow: String = if (elementTypeIdIsSet) _elementTypeId else throw new java.lang.NullPointerException("field elementTypeId of SetType missing")
  override def elementTypeIdIsSet: Boolean = _elementTypeId != null
  override def elementTypeIdUnset(): Unit = { _elementTypeId = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(SetType.SETTYPE_SDESC)
    if (elementTypeIdIsSet) {
      oprot.writeFieldBegin(SetType.ELEMENTTYPEID_FDESC)
      oprot.writeString(_elementTypeId)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        SetType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // elementTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _elementTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure SetType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: SetType): Unit = {
    if (that.elementTypeIdIsSet && !this.elementTypeIdIsSet) {
      this.elementTypeId_=(that.elementTypeIdOrNull)
    }
  }

  override def mergeCopy(that: SetType): SetType = {
    val ret = SetType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: SetType => this.equals(o)
    case _ => false
  }

  def equals(that: SetType): Boolean = {
    that != null &&
    (if (this.elementTypeIdIsSet) (that.elementTypeIdIsSet && this.elementTypeIdOrNull == that.elementTypeIdOrNull) else !that.elementTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (elementTypeIdIsSet) hasher.append(_elementTypeId.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (elementTypeIdIsSet) ret = elementTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    elementTypeIdUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): SetType._Fields = id match {
    case 1 => SetType._Fields.elementTypeId
    case _ => null
  }

  def isSet(field: SetType._Fields): Boolean = field match {
    case SetType._Fields.elementTypeId => elementTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: SetType._Fields): AnyRef = field match {
    case SetType._Fields.elementTypeId => elementTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: SetType._Fields, value: AnyRef) {
    field match {
      case SetType._Fields.elementTypeId => elementTypeId_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawSetType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = SetType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      elementTypeId: String = elementTypeIdOrNull
  ): RawSetType = {
    val ret = new RawSetType
    if (elementTypeId != null) ret.elementTypeId_=(elementTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object MapType extends MapTypeMeta {


  object Builder {
    sealed trait HasKeyTypeId
    sealed trait HasValueTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasKeyTypeId with HasValueTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[MapType] (private var obj: RawMapType) {
    def keyTypeId(v: String): MapType.Builder[State with Builder.HasKeyTypeId] = {
      obj.keyTypeId_=(v)
      this.asInstanceOf[MapType.Builder[State with Builder.HasKeyTypeId]]
    }

    def valueTypeId(v: String): MapType.Builder[State with Builder.HasValueTypeId] = {
      obj.valueTypeId_=(v)
      this.asInstanceOf[MapType.Builder[State with Builder.HasValueTypeId]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasKeyTypeId, ev1: State <:< Builder.HasValueTypeId): MutableMapType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("MapType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasKeyTypeId, ev1: State <:< Builder.HasValueTypeId): MapType = resultMutable()(ev0, ev1)
  }

  def newBuilder: MapType.Builder.AllUnspecified = new Builder(MapType.createRawRecord)

  implicit val companionProvider: MapTypeCompanionProvider = new MapTypeCompanionProvider
}

class MapTypeMeta
    extends JavaMapTypeMeta[MapType, RawMapType, MapTypeMeta]
    with com.foursquare.spindle.RecordProvider[MapType] {
  override def recordName: String = "MapType"


  // Thrift descriptors.
  val MAPTYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("MapType")

  val KEYTYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "keyTypeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val VALUETYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "valueTypeId",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "keyTypeId" -> KEYTYPEID_FDESC,
    "valueTypeId" -> VALUETYPEID_FDESC
  )

  object _Fields {
    case object keyTypeId extends _Fields(1, "keyTypeId")
    case object valueTypeId extends _Fields(2, "valueTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.keyTypeId,
    2.toShort -> _Fields.valueTypeId
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: MapType = createRawRecord
  override def createRawRecord: RawMapType = new RawMapType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[MapType] = {
    if (x.isInstanceOf[MapType]) Some(x.asInstanceOf[MapType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val keyTypeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, MapType, MapTypeMeta](
      name = "keyTypeId",
      longName = "keyTypeId",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.keyTypeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[MapType], v: String) => { r.asInstanceOf[RawMapType].keyTypeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[MapType]) => { r.asInstanceOf[RawMapType].keyTypeIdUnset() },
      manifest = manifest[String]
    )

  val valueTypeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, MapType, MapTypeMeta](
      name = "valueTypeId",
      longName = "valueTypeId",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.valueTypeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[MapType], v: String) => { r.asInstanceOf[RawMapType].valueTypeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[MapType]) => { r.asInstanceOf[RawMapType].valueTypeIdUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, MapType, MapTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, MapType, MapTypeMeta]](
      keyTypeId,
      valueTypeId
    )


  def apply(
      keyTypeId: String,
      valueTypeId: String
  ): MapType = {
    val ret = this.createRawRecord
    ret.keyTypeId_=(keyTypeId)
    ret.valueTypeId_=(valueTypeId)
    ret
  }
}

class MapTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[MapType] {
  type CompanionT = MapTypeMeta
  override def provide: MapTypeMeta = MapType
}


trait MapType
    extends JavaMapType[
      MapType, RawMapType, MapTypeMeta
    ]
    with org.apache.thrift.TBase[MapType, MapType._Fields] {

  override def meta: MapTypeMeta

  override def compare(that: MapType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.keyTypeIdIsSet.compareTo(that.keyTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.keyTypeIdIsSet && {
      cmp = this.keyTypeIdOrNull.compareTo(that.keyTypeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueTypeIdIsSet.compareTo(that.valueTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.valueTypeIdIsSet && {
      cmp = this.valueTypeIdOrNull.compareTo(that.valueTypeIdOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: MapType): Boolean = { this.compare(that) < 0 }
  override def >(that: MapType): Boolean = { this.compare(that) > 0 }
  override def <=(that: MapType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: MapType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: MapType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): MapType

  def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MapType

  def mutableCopy(): MutableMapType = {
    val ret = MapType.createRawRecord

    if (keyTypeIdIsSet) ret.keyTypeId_=(keyTypeIdOrNull)

    if (valueTypeIdIsSet) ret.valueTypeId_=(valueTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableMapType

  def toBuilder(): MapType.Builder.AllSpecified = {
    val ret = new MapType.Builder(MapType.createRawRecord)

    if (keyTypeIdIsSet) ret.keyTypeId(keyTypeIdOrNull)

    if (valueTypeIdIsSet) ret.valueTypeId(valueTypeIdOrNull)
    ret
  }

  def mergeCopy(that: MapType): MapType

}

trait MutableMapType extends MapType
    with JavaMapTypeMutable[
      MapType, RawMapType, MapTypeMeta
    ] {
  def keyTypeId_=(x: String): Unit
  def keyTypeIdUnset(): Unit
  def valueTypeId_=(x: String): Unit
  def valueTypeIdUnset(): Unit

  def merge(that: MapType): Unit

  def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): MutableMapType

  override def mutable: MutableMapType = this
}



final class RawMapType extends JavaMapTypeRaw[
      MapType, RawMapType, MapTypeMeta
    ]
    with MutableMapType {
  override def meta: MapTypeMeta = MapType

  // fields
  // Field #1 - keyTypeId
  private var _keyTypeId: String = null  // Underlying type: String
  override def keyTypeId: String = keyTypeIdOrThrow
  override def keyTypeId_=(x: String): Unit = { _keyTypeId = x }
  override def keyTypeIdOption: Option[String] = if (keyTypeIdIsSet) Some(_keyTypeId) else None
  override def keyTypeIdOrNull: String = _keyTypeId
  override def keyTypeIdOrThrow: String = if (keyTypeIdIsSet) _keyTypeId else throw new java.lang.NullPointerException("field keyTypeId of MapType missing")
  override def keyTypeIdIsSet: Boolean = _keyTypeId != null
  override def keyTypeIdUnset(): Unit = { _keyTypeId = null }
  // Field #2 - valueTypeId
  private var _valueTypeId: String = null  // Underlying type: String
  override def valueTypeId: String = valueTypeIdOrThrow
  override def valueTypeId_=(x: String): Unit = { _valueTypeId = x }
  override def valueTypeIdOption: Option[String] = if (valueTypeIdIsSet) Some(_valueTypeId) else None
  override def valueTypeIdOrNull: String = _valueTypeId
  override def valueTypeIdOrThrow: String = if (valueTypeIdIsSet) _valueTypeId else throw new java.lang.NullPointerException("field valueTypeId of MapType missing")
  override def valueTypeIdIsSet: Boolean = _valueTypeId != null
  override def valueTypeIdUnset(): Unit = { _valueTypeId = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(MapType.MAPTYPE_SDESC)
    if (keyTypeIdIsSet) {
      oprot.writeFieldBegin(MapType.KEYTYPEID_FDESC)
      oprot.writeString(_keyTypeId)
      oprot.writeFieldEnd()
    }
    if (valueTypeIdIsSet) {
      oprot.writeFieldBegin(MapType.VALUETYPEID_FDESC)
      oprot.writeString(_valueTypeId)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        MapType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // keyTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _keyTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // valueTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _valueTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure MapType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: MapType): Unit = {
    if (that.keyTypeIdIsSet && !this.keyTypeIdIsSet) {
      this.keyTypeId_=(that.keyTypeIdOrNull)
    }
    if (that.valueTypeIdIsSet && !this.valueTypeIdIsSet) {
      this.valueTypeId_=(that.valueTypeIdOrNull)
    }
  }

  override def mergeCopy(that: MapType): MapType = {
    val ret = MapType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: MapType => this.equals(o)
    case _ => false
  }

  def equals(that: MapType): Boolean = {
    that != null &&
    (if (this.keyTypeIdIsSet) (that.keyTypeIdIsSet && this.keyTypeIdOrNull == that.keyTypeIdOrNull) else !that.keyTypeIdIsSet) &&
    (if (this.valueTypeIdIsSet) (that.valueTypeIdIsSet && this.valueTypeIdOrNull == that.valueTypeIdOrNull) else !that.valueTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (keyTypeIdIsSet) hasher.append(_keyTypeId.##)
    if (valueTypeIdIsSet) hasher.append(_valueTypeId.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (keyTypeIdIsSet) ret = keyTypeIdOrNull :: ret
    if (valueTypeIdIsSet) ret = valueTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    keyTypeIdUnset()
    valueTypeIdUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): MapType._Fields = id match {
    case 1 => MapType._Fields.keyTypeId
    case 2 => MapType._Fields.valueTypeId
    case _ => null
  }

  def isSet(field: MapType._Fields): Boolean = field match {
    case MapType._Fields.keyTypeId => keyTypeIdIsSet
    case MapType._Fields.valueTypeId => valueTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: MapType._Fields): AnyRef = field match {
    case MapType._Fields.keyTypeId => keyTypeIdOrNull.asInstanceOf[AnyRef]
    case MapType._Fields.valueTypeId => valueTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: MapType._Fields, value: AnyRef) {
    field match {
      case MapType._Fields.keyTypeId => keyTypeId_=(value.asInstanceOf[String])
      case MapType._Fields.valueTypeId => valueTypeId_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawMapType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = MapType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      keyTypeId: String = keyTypeIdOrNull,
      valueTypeId: String = valueTypeIdOrNull
  ): RawMapType = {
    val ret = new RawMapType
    if (keyTypeId != null) ret.keyTypeId_=(keyTypeId)
    if (valueTypeId != null) ret.valueTypeId_=(valueTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object ContainerType extends ContainerTypeMeta {


  object Builder {
    sealed trait HasSimpleContainerType

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasSimpleContainerType
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[ContainerType] (private var obj: RawContainerType) {
    def simpleContainerType(v: com.twitter.thrift.descriptors.SimpleContainerType): ContainerType.Builder[State with Builder.HasSimpleContainerType] = {
      obj.simpleContainerType_=(v)
      this.asInstanceOf[ContainerType.Builder[State with Builder.HasSimpleContainerType]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): ContainerType.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): ContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasSimpleContainerType): MutableContainerType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("ContainerType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasSimpleContainerType): ContainerType = resultMutable()(ev0)
  }

  def newBuilder: ContainerType.Builder.AllUnspecified = new Builder(ContainerType.createRawRecord)

  implicit val companionProvider: ContainerTypeCompanionProvider = new ContainerTypeCompanionProvider
}

class ContainerTypeMeta
    extends JavaContainerTypeMeta[ContainerType, RawContainerType, ContainerTypeMeta]
    with com.foursquare.spindle.RecordProvider[ContainerType] {
  override def recordName: String = "ContainerType"


  // Thrift descriptors.
  val CONTAINERTYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("ContainerType")

  val SIMPLECONTAINERTYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "simpleContainerType",
      org.apache.thrift.protocol.TType.STRUCT,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "simpleContainerType" -> SIMPLECONTAINERTYPE_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object simpleContainerType extends _Fields(1, "simpleContainerType")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.simpleContainerType,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: ContainerType = createRawRecord
  override def createRawRecord: RawContainerType = new RawContainerType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[ContainerType] = {
    if (x.isInstanceOf[ContainerType]) Some(x.asInstanceOf[ContainerType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val simpleContainerType =
    new com.foursquare.spindle.StructFieldDescriptor[ContainerType, ContainerTypeMeta, com.twitter.thrift.descriptors.SimpleContainerType, com.twitter.thrift.descriptors.SimpleContainerTypeMeta](
      name = "simpleContainerType",
      longName = "simpleContainerType",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.simpleContainerTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[ContainerType], v: com.twitter.thrift.descriptors.SimpleContainerType) => { r.asInstanceOf[RawContainerType].simpleContainerType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[ContainerType]) => { r.asInstanceOf[RawContainerType].simpleContainerTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.SimpleContainerType,
      manifest = manifest[com.twitter.thrift.descriptors.SimpleContainerType]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], ContainerType, ContainerTypeMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[ContainerType], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawContainerType].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[ContainerType]) => { r.asInstanceOf[RawContainerType].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, ContainerType, ContainerTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, ContainerType, ContainerTypeMeta]](
      simpleContainerType,
      __annotations
    )


  def apply(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): ContainerType = {
    val ret = this.createRawRecord
    ret.simpleContainerType_=(simpleContainerType)
    ret.__annotations_=(__annotations)
    ret
  }
}

class ContainerTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[ContainerType] {
  type CompanionT = ContainerTypeMeta
  override def provide: ContainerTypeMeta = ContainerType
}


trait ContainerType
    extends JavaContainerType[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.SimpleContainerType,
      ContainerType, RawContainerType, ContainerTypeMeta
    ]
    with org.apache.thrift.TBase[ContainerType, ContainerType._Fields] {

  override def meta: ContainerTypeMeta

  override def compare(that: ContainerType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.simpleContainerTypeIsSet.compareTo(that.simpleContainerTypeIsSet)
      cmp != 0 }) cmp
    else if (this.simpleContainerTypeIsSet && {
      cmp = this.simpleContainerTypeOrNull.compareTo(that.simpleContainerTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: ContainerType): Boolean = { this.compare(that) < 0 }
  override def >(that: ContainerType): Boolean = { this.compare(that) > 0 }
  override def <=(that: ContainerType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: ContainerType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: ContainerType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): ContainerType

  def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): ContainerType

  def mutableCopy(): MutableContainerType = {
    val ret = ContainerType.createRawRecord

    if (simpleContainerTypeIsSet) ret.simpleContainerType_=(simpleContainerTypeOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableContainerType

  def toBuilder(): ContainerType.Builder.AllSpecified = {
    val ret = new ContainerType.Builder(ContainerType.createRawRecord)

    if (simpleContainerTypeIsSet) ret.simpleContainerType(simpleContainerTypeOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: ContainerType): ContainerType

}

trait MutableContainerType extends ContainerType
    with JavaContainerTypeMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.SimpleContainerType,
      ContainerType, RawContainerType, ContainerTypeMeta
    ] {
  def simpleContainerType_=(x: com.twitter.thrift.descriptors.SimpleContainerType): Unit
  def simpleContainerTypeUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: ContainerType): Unit

  def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableContainerType

  override def mutable: MutableContainerType = this
}



final class RawContainerType extends JavaContainerTypeRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.SimpleContainerType,
      ContainerType, RawContainerType, ContainerTypeMeta
    ]
    with MutableContainerType {
  override def meta: ContainerTypeMeta = ContainerType

  // fields
  // Field #1 - simpleContainerType
  private var _simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = null  // Underlying type: com.twitter.thrift.descriptors.SimpleContainerType
  override def simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrThrow
  override def simpleContainerType_=(x: com.twitter.thrift.descriptors.SimpleContainerType): Unit = { _simpleContainerType = x }
  override def simpleContainerTypeOption: Option[com.twitter.thrift.descriptors.SimpleContainerType] = if (simpleContainerTypeIsSet) Some(_simpleContainerType) else None
  override def simpleContainerTypeOrNull: com.twitter.thrift.descriptors.SimpleContainerType = _simpleContainerType
  override def simpleContainerTypeOrThrow: com.twitter.thrift.descriptors.SimpleContainerType = if (simpleContainerTypeIsSet) _simpleContainerType else throw new java.lang.NullPointerException("field simpleContainerType of ContainerType missing")
  override def simpleContainerTypeIsSet: Boolean = _simpleContainerType != null
  override def simpleContainerTypeUnset(): Unit = { _simpleContainerType = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of ContainerType missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(ContainerType.CONTAINERTYPE_SDESC)
    if (simpleContainerTypeIsSet) {
      oprot.writeFieldBegin(ContainerType.SIMPLECONTAINERTYPE_FDESC)
      _simpleContainerType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(ContainerType.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        ContainerType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // simpleContainerType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _simpleContainerType = ({
                val s = com.twitter.thrift.descriptors.SimpleContainerType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure ContainerType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: ContainerType): Unit = {
    if (that.simpleContainerTypeIsSet && !this.simpleContainerTypeIsSet) {
      this.simpleContainerType_=(that.simpleContainerTypeOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: ContainerType): ContainerType = {
    val ret = ContainerType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: ContainerType => this.equals(o)
    case _ => false
  }

  def equals(that: ContainerType): Boolean = {
    that != null &&
    (if (this.simpleContainerTypeIsSet) (that.simpleContainerTypeIsSet && this.simpleContainerTypeOrNull == that.simpleContainerTypeOrNull) else !that.simpleContainerTypeIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (simpleContainerTypeIsSet) hasher.append(_simpleContainerType.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (simpleContainerTypeIsSet) ret = simpleContainerTypeOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    simpleContainerTypeUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): ContainerType._Fields = id match {
    case 1 => ContainerType._Fields.simpleContainerType
    case 99 => ContainerType._Fields.__annotations
    case _ => null
  }

  def isSet(field: ContainerType._Fields): Boolean = field match {
    case ContainerType._Fields.simpleContainerType => simpleContainerTypeIsSet
    case ContainerType._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: ContainerType._Fields): AnyRef = field match {
    case ContainerType._Fields.simpleContainerType => simpleContainerTypeOrNull.asInstanceOf[AnyRef]
    case ContainerType._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: ContainerType._Fields, value: AnyRef) {
    field match {
      case ContainerType._Fields.simpleContainerType => simpleContainerType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SimpleContainerType])
      case ContainerType._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawContainerType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = ContainerType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      simpleContainerType: com.twitter.thrift.descriptors.SimpleContainerType = simpleContainerTypeOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawContainerType = {
    val ret = new RawContainerType
    if (simpleContainerType != null) ret.simpleContainerType_=(simpleContainerType)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Typeref extends TyperefMeta {


  object Builder {
    sealed trait HasTypeAlias

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeAlias
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Typeref] (private var obj: RawTyperef) {
    def typeAlias(v: String): Typeref.Builder[State with Builder.HasTypeAlias] = {
      obj.typeAlias_=(v)
      this.asInstanceOf[Typeref.Builder[State with Builder.HasTypeAlias]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasTypeAlias): MutableTyperef = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Typeref.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeAlias): Typeref = resultMutable()(ev0)
  }

  def newBuilder: Typeref.Builder.AllUnspecified = new Builder(Typeref.createRawRecord)

  implicit val companionProvider: TyperefCompanionProvider = new TyperefCompanionProvider
}

class TyperefMeta
    extends JavaTyperefMeta[Typeref, RawTyperef, TyperefMeta]
    with com.foursquare.spindle.RecordProvider[Typeref] {
  override def recordName: String = "Typeref"


  // Thrift descriptors.
  val TYPEREF_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Typeref")

  val TYPEALIAS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeAlias",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "typeAlias" -> TYPEALIAS_FDESC
  )

  object _Fields {
    case object typeAlias extends _Fields(1, "typeAlias")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.typeAlias
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Typeref = createRawRecord
  override def createRawRecord: RawTyperef = new RawTyperef

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Typeref] = {
    if (x.isInstanceOf[Typeref]) Some(x.asInstanceOf[Typeref]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val typeAlias =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Typeref, TyperefMeta](
      name = "typeAlias",
      longName = "typeAlias",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.typeAliasOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Typeref], v: String) => { r.asInstanceOf[RawTyperef].typeAlias_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Typeref]) => { r.asInstanceOf[RawTyperef].typeAliasUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Typeref, TyperefMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Typeref, TyperefMeta]](
      typeAlias
    )


  def apply(
      typeAlias: String
  ): Typeref = {
    val ret = this.createRawRecord
    ret.typeAlias_=(typeAlias)
    ret
  }
}

class TyperefCompanionProvider extends com.foursquare.spindle.CompanionProvider[Typeref] {
  type CompanionT = TyperefMeta
  override def provide: TyperefMeta = Typeref
}


trait Typeref
    extends JavaTyperef[
      Typeref, RawTyperef, TyperefMeta
    ]
    with org.apache.thrift.TBase[Typeref, Typeref._Fields] {

  override def meta: TyperefMeta

  override def compare(that: Typeref): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.typeAliasIsSet.compareTo(that.typeAliasIsSet)
      cmp != 0 }) cmp
    else if (this.typeAliasIsSet && {
      cmp = this.typeAliasOrNull.compareTo(that.typeAliasOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Typeref): Boolean = { this.compare(that) < 0 }
  override def >(that: Typeref): Boolean = { this.compare(that) > 0 }
  override def <=(that: Typeref): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Typeref): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Typeref): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Typeref

  def copy(
      typeAlias: String = typeAliasOrNull
  ): Typeref

  def mutableCopy(): MutableTyperef = {
    val ret = Typeref.createRawRecord

    if (typeAliasIsSet) ret.typeAlias_=(typeAliasOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableTyperef

  def toBuilder(): Typeref.Builder.AllSpecified = {
    val ret = new Typeref.Builder(Typeref.createRawRecord)

    if (typeAliasIsSet) ret.typeAlias(typeAliasOrNull)
    ret
  }

  def mergeCopy(that: Typeref): Typeref

}

trait MutableTyperef extends Typeref
    with JavaTyperefMutable[
      Typeref, RawTyperef, TyperefMeta
    ] {
  def typeAlias_=(x: String): Unit
  def typeAliasUnset(): Unit

  def merge(that: Typeref): Unit

  def copy(
      typeAlias: String = typeAliasOrNull
  ): MutableTyperef

  override def mutable: MutableTyperef = this
}



final class RawTyperef extends JavaTyperefRaw[
      Typeref, RawTyperef, TyperefMeta
    ]
    with MutableTyperef {
  override def meta: TyperefMeta = Typeref

  // fields
  // Field #1 - typeAlias
  private var _typeAlias: String = null  // Underlying type: String
  override def typeAlias: String = typeAliasOrThrow
  override def typeAlias_=(x: String): Unit = { _typeAlias = x }
  override def typeAliasOption: Option[String] = if (typeAliasIsSet) Some(_typeAlias) else None
  override def typeAliasOrNull: String = _typeAlias
  override def typeAliasOrThrow: String = if (typeAliasIsSet) _typeAlias else throw new java.lang.NullPointerException("field typeAlias of Typeref missing")
  override def typeAliasIsSet: Boolean = _typeAlias != null
  override def typeAliasUnset(): Unit = { _typeAlias = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Typeref.TYPEREF_SDESC)
    if (typeAliasIsSet) {
      oprot.writeFieldBegin(Typeref.TYPEALIAS_FDESC)
      oprot.writeString(_typeAlias)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Typeref.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // typeAlias

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeAlias = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Typeref".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Typeref): Unit = {
    if (that.typeAliasIsSet && !this.typeAliasIsSet) {
      this.typeAlias_=(that.typeAliasOrNull)
    }
  }

  override def mergeCopy(that: Typeref): Typeref = {
    val ret = Typeref.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Typeref => this.equals(o)
    case _ => false
  }

  def equals(that: Typeref): Boolean = {
    that != null &&
    (if (this.typeAliasIsSet) (that.typeAliasIsSet && this.typeAliasOrNull == that.typeAliasOrNull) else !that.typeAliasIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (typeAliasIsSet) hasher.append(_typeAlias.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (typeAliasIsSet) ret = typeAliasOrNull :: ret
    ret.reverse
  }

  override def clear() {
    typeAliasUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Typeref._Fields = id match {
    case 1 => Typeref._Fields.typeAlias
    case _ => null
  }

  def isSet(field: Typeref._Fields): Boolean = field match {
    case Typeref._Fields.typeAlias => typeAliasIsSet
    case _ => false
  }

  def getFieldValue(field: Typeref._Fields): AnyRef = field match {
    case Typeref._Fields.typeAlias => typeAliasOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Typeref._Fields, value: AnyRef) {
    field match {
      case Typeref._Fields.typeAlias => typeAlias_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawTyperef = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Typeref.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      typeAlias: String = typeAliasOrNull
  ): RawTyperef = {
    val ret = new RawTyperef
    if (typeAlias != null) ret.typeAlias_=(typeAlias)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Type extends TypeMeta {


  object Builder {
    sealed trait HasId
    sealed trait HasSimpleType

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasId with HasSimpleType
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Type] (private var obj: RawType) {
    def id(v: String): Type.Builder[State with Builder.HasId] = {
      obj.id_=(v)
      this.asInstanceOf[Type.Builder[State with Builder.HasId]]
    }

    def simpleType(v: com.twitter.thrift.descriptors.SimpleType): Type.Builder[State with Builder.HasSimpleType] = {
      obj.simpleType_=(v)
      this.asInstanceOf[Type.Builder[State with Builder.HasSimpleType]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasId, ev1: State <:< Builder.HasSimpleType): MutableType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Type.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasId, ev1: State <:< Builder.HasSimpleType): Type = resultMutable()(ev0, ev1)
  }

  def newBuilder: Type.Builder.AllUnspecified = new Builder(Type.createRawRecord)

  implicit val companionProvider: TypeCompanionProvider = new TypeCompanionProvider
}

class TypeMeta
    extends JavaTypeMeta[Type, RawType, TypeMeta]
    with com.foursquare.spindle.RecordProvider[Type] {
  override def recordName: String = "Type"


  // Thrift descriptors.
  val TYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Type")

  val ID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "id",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val SIMPLETYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "simpleType",
      org.apache.thrift.protocol.TType.STRUCT,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "id" -> ID_FDESC,
    "simpleType" -> SIMPLETYPE_FDESC
  )

  object _Fields {
    case object id extends _Fields(1, "id")
    case object simpleType extends _Fields(2, "simpleType")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.id,
    2.toShort -> _Fields.simpleType
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Type = createRawRecord
  override def createRawRecord: RawType = new RawType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Type] = {
    if (x.isInstanceOf[Type]) Some(x.asInstanceOf[Type]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val id =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Type, TypeMeta](
      name = "id",
      longName = "id",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.idOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Type], v: String) => { r.asInstanceOf[RawType].id_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Type]) => { r.asInstanceOf[RawType].idUnset() },
      manifest = manifest[String]
    )

  val simpleType =
    new com.foursquare.spindle.StructFieldDescriptor[Type, TypeMeta, com.twitter.thrift.descriptors.SimpleType, com.twitter.thrift.descriptors.SimpleTypeMeta](
      name = "simpleType",
      longName = "simpleType",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.simpleTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Type], v: com.twitter.thrift.descriptors.SimpleType) => { r.asInstanceOf[RawType].simpleType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Type]) => { r.asInstanceOf[RawType].simpleTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.SimpleType,
      manifest = manifest[com.twitter.thrift.descriptors.SimpleType]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Type, TypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Type, TypeMeta]](
      id,
      simpleType
    )


  def apply(
      id: String,
      simpleType: com.twitter.thrift.descriptors.SimpleType
  ): Type = {
    val ret = this.createRawRecord
    ret.id_=(id)
    ret.simpleType_=(simpleType)
    ret
  }
}

class TypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[Type] {
  type CompanionT = TypeMeta
  override def provide: TypeMeta = Type
}


trait Type
    extends JavaType[com.twitter.thrift.descriptors.SimpleType,
      Type, RawType, TypeMeta
    ]
    with org.apache.thrift.TBase[Type, Type._Fields] {

  override def meta: TypeMeta

  override def compare(that: Type): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.idIsSet.compareTo(that.idIsSet)
      cmp != 0 }) cmp
    else if (this.idIsSet && {
      cmp = this.idOrNull.compareTo(that.idOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.simpleTypeIsSet.compareTo(that.simpleTypeIsSet)
      cmp != 0 }) cmp
    else if (this.simpleTypeIsSet && {
      cmp = this.simpleTypeOrNull.compareTo(that.simpleTypeOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Type): Boolean = { this.compare(that) < 0 }
  override def >(that: Type): Boolean = { this.compare(that) > 0 }
  override def <=(that: Type): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Type): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Type): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Type

  def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): Type

  def mutableCopy(): MutableType = {
    val ret = Type.createRawRecord

    if (idIsSet) ret.id_=(idOrNull)

    if (simpleTypeIsSet) ret.simpleType_=(simpleTypeOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableType

  def toBuilder(): Type.Builder.AllSpecified = {
    val ret = new Type.Builder(Type.createRawRecord)

    if (idIsSet) ret.id(idOrNull)

    if (simpleTypeIsSet) ret.simpleType(simpleTypeOrNull)
    ret
  }

  def mergeCopy(that: Type): Type

}

trait MutableType extends Type
    with JavaTypeMutable[com.twitter.thrift.descriptors.SimpleType,
      Type, RawType, TypeMeta
    ] {
  def id_=(x: String): Unit
  def idUnset(): Unit
  def simpleType_=(x: com.twitter.thrift.descriptors.SimpleType): Unit
  def simpleTypeUnset(): Unit

  def merge(that: Type): Unit

  def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): MutableType

  override def mutable: MutableType = this
}



final class RawType extends JavaTypeRaw[com.twitter.thrift.descriptors.SimpleType,
      Type, RawType, TypeMeta
    ]
    with MutableType {
  override def meta: TypeMeta = Type

  // fields
  // Field #1 - id
  private var _id: String = null  // Underlying type: String
  override def id: String = idOrThrow
  override def id_=(x: String): Unit = { _id = x }
  override def idOption: Option[String] = if (idIsSet) Some(_id) else None
  override def idOrNull: String = _id
  override def idOrThrow: String = if (idIsSet) _id else throw new java.lang.NullPointerException("field id of Type missing")
  override def idIsSet: Boolean = _id != null
  override def idUnset(): Unit = { _id = null }
  // Field #2 - simpleType
  private var _simpleType: com.twitter.thrift.descriptors.SimpleType = null  // Underlying type: com.twitter.thrift.descriptors.SimpleType
  override def simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrThrow
  override def simpleType_=(x: com.twitter.thrift.descriptors.SimpleType): Unit = { _simpleType = x }
  override def simpleTypeOption: Option[com.twitter.thrift.descriptors.SimpleType] = if (simpleTypeIsSet) Some(_simpleType) else None
  override def simpleTypeOrNull: com.twitter.thrift.descriptors.SimpleType = _simpleType
  override def simpleTypeOrThrow: com.twitter.thrift.descriptors.SimpleType = if (simpleTypeIsSet) _simpleType else throw new java.lang.NullPointerException("field simpleType of Type missing")
  override def simpleTypeIsSet: Boolean = _simpleType != null
  override def simpleTypeUnset(): Unit = { _simpleType = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Type.TYPE_SDESC)
    if (idIsSet) {
      oprot.writeFieldBegin(Type.ID_FDESC)
      oprot.writeString(_id)
      oprot.writeFieldEnd()
    }
    if (simpleTypeIsSet) {
      oprot.writeFieldBegin(Type.SIMPLETYPE_FDESC)
      _simpleType.write(oprot)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Type.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // id

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _id = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // simpleType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _simpleType = ({
                val s = com.twitter.thrift.descriptors.SimpleType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Type".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Type): Unit = {
    if (that.idIsSet && !this.idIsSet) {
      this.id_=(that.idOrNull)
    }
    if (that.simpleTypeIsSet && !this.simpleTypeIsSet) {
      this.simpleType_=(that.simpleTypeOrNull)
    }
  }

  override def mergeCopy(that: Type): Type = {
    val ret = Type.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Type => this.equals(o)
    case _ => false
  }

  def equals(that: Type): Boolean = {
    that != null &&
    (if (this.idIsSet) (that.idIsSet && this.idOrNull == that.idOrNull) else !that.idIsSet) &&
    (if (this.simpleTypeIsSet) (that.simpleTypeIsSet && this.simpleTypeOrNull == that.simpleTypeOrNull) else !that.simpleTypeIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (idIsSet) hasher.append(_id.##)
    if (simpleTypeIsSet) hasher.append(_simpleType.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (idIsSet) ret = idOrNull :: ret
    if (simpleTypeIsSet) ret = simpleTypeOrNull :: ret
    ret.reverse
  }

  override def clear() {
    idUnset()
    simpleTypeUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Type._Fields = id match {
    case 1 => Type._Fields.id
    case 2 => Type._Fields.simpleType
    case _ => null
  }

  def isSet(field: Type._Fields): Boolean = field match {
    case Type._Fields.id => idIsSet
    case Type._Fields.simpleType => simpleTypeIsSet
    case _ => false
  }

  def getFieldValue(field: Type._Fields): AnyRef = field match {
    case Type._Fields.id => idOrNull.asInstanceOf[AnyRef]
    case Type._Fields.simpleType => simpleTypeOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Type._Fields, value: AnyRef) {
    field match {
      case Type._Fields.id => id_=(value.asInstanceOf[String])
      case Type._Fields.simpleType => simpleType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SimpleType])
      case _ =>
    }
  }

  override def deepCopy(): RawType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Type.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      id: String = idOrNull,
      simpleType: com.twitter.thrift.descriptors.SimpleType = simpleTypeOrNull
  ): RawType = {
    val ret = new RawType
    if (id != null) ret.id_=(id)
    if (simpleType != null) ret.simpleType_=(simpleType)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Typedef extends TypedefMeta {


  object Builder {
    sealed trait HasTypeId
    sealed trait HasTypeAlias

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeId with HasTypeAlias
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Typedef] (private var obj: RawTypedef) {
    def typeId(v: String): Typedef.Builder[State with Builder.HasTypeId] = {
      obj.typeId_=(v)
      this.asInstanceOf[Typedef.Builder[State with Builder.HasTypeId]]
    }

    def typeAlias(v: String): Typedef.Builder[State with Builder.HasTypeAlias] = {
      obj.typeAlias_=(v)
      this.asInstanceOf[Typedef.Builder[State with Builder.HasTypeAlias]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Typedef.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Typedef.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasTypeAlias): MutableTypedef = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Typedef.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasTypeAlias): Typedef = resultMutable()(ev0, ev1)
  }

  def newBuilder: Typedef.Builder.AllUnspecified = new Builder(Typedef.createRawRecord)

  implicit val companionProvider: TypedefCompanionProvider = new TypedefCompanionProvider
}

class TypedefMeta
    extends JavaTypedefMeta[Typedef, RawTypedef, TypedefMeta]
    with com.foursquare.spindle.RecordProvider[Typedef] {
  override def recordName: String = "Typedef"


  // Thrift descriptors.
  val TYPEDEF_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Typedef")

  val TYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEALIAS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeAlias",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "typeId" -> TYPEID_FDESC,
    "typeAlias" -> TYPEALIAS_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object typeId extends _Fields(1, "typeId")
    case object typeAlias extends _Fields(2, "typeAlias")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.typeId,
    2.toShort -> _Fields.typeAlias,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Typedef = createRawRecord
  override def createRawRecord: RawTypedef = new RawTypedef

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Typedef] = {
    if (x.isInstanceOf[Typedef]) Some(x.asInstanceOf[Typedef]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val typeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Typedef, TypedefMeta](
      name = "typeId",
      longName = "typeId",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.typeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Typedef], v: String) => { r.asInstanceOf[RawTypedef].typeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Typedef]) => { r.asInstanceOf[RawTypedef].typeIdUnset() },
      manifest = manifest[String]
    )

  val typeAlias =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Typedef, TypedefMeta](
      name = "typeAlias",
      longName = "typeAlias",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.typeAliasOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Typedef], v: String) => { r.asInstanceOf[RawTypedef].typeAlias_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Typedef]) => { r.asInstanceOf[RawTypedef].typeAliasUnset() },
      manifest = manifest[String]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Typedef, TypedefMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Typedef], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawTypedef].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Typedef]) => { r.asInstanceOf[RawTypedef].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Typedef, TypedefMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Typedef, TypedefMeta]](
      typeId,
      typeAlias,
      __annotations
    )


  def apply(
      typeId: String,
      typeAlias: String,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Typedef = {
    val ret = this.createRawRecord
    ret.typeId_=(typeId)
    ret.typeAlias_=(typeAlias)
    ret.__annotations_=(__annotations)
    ret
  }
}

class TypedefCompanionProvider extends com.foursquare.spindle.CompanionProvider[Typedef] {
  type CompanionT = TypedefMeta
  override def provide: TypedefMeta = Typedef
}


trait Typedef
    extends JavaTypedef[com.twitter.thrift.descriptors.Annotation,
      Typedef, RawTypedef, TypedefMeta
    ]
    with org.apache.thrift.TBase[Typedef, Typedef._Fields] {

  override def meta: TypedefMeta

  override def compare(that: Typedef): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.typeIdIsSet.compareTo(that.typeIdIsSet)
      cmp != 0 }) cmp
    else if (this.typeIdIsSet && {
      cmp = this.typeIdOrNull.compareTo(that.typeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typeAliasIsSet.compareTo(that.typeAliasIsSet)
      cmp != 0 }) cmp
    else if (this.typeAliasIsSet && {
      cmp = this.typeAliasOrNull.compareTo(that.typeAliasOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Typedef): Boolean = { this.compare(that) < 0 }
  override def >(that: Typedef): Boolean = { this.compare(that) > 0 }
  override def <=(that: Typedef): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Typedef): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Typedef): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Typedef

  def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef

  def mutableCopy(): MutableTypedef = {
    val ret = Typedef.createRawRecord

    if (typeIdIsSet) ret.typeId_=(typeIdOrNull)

    if (typeAliasIsSet) ret.typeAlias_=(typeAliasOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableTypedef

  def toBuilder(): Typedef.Builder.AllSpecified = {
    val ret = new Typedef.Builder(Typedef.createRawRecord)

    if (typeIdIsSet) ret.typeId(typeIdOrNull)

    if (typeAliasIsSet) ret.typeAlias(typeAliasOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Typedef): Typedef

}

trait MutableTypedef extends Typedef
    with JavaTypedefMutable[com.twitter.thrift.descriptors.Annotation,
      Typedef, RawTypedef, TypedefMeta
    ] {
  def typeId_=(x: String): Unit
  def typeIdUnset(): Unit
  def typeAlias_=(x: String): Unit
  def typeAliasUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Typedef): Unit

  def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableTypedef

  override def mutable: MutableTypedef = this
}


trait TypedefProxy extends Typedef {
  protected def underlying: Typedef

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def typeId: String = underlying.typeId
  override def typeIdOption: Option[String] = underlying.typeIdOption
  override def typeIdOrNull: String = underlying.typeIdOrNull
  override def typeIdOrThrow: String = underlying.typeIdOrThrow
  override def typeIdIsSet: Boolean = underlying.typeIdIsSet
// field/proxy_ref.ssp

  override def typeAlias: String = underlying.typeAlias
  override def typeAliasOption: Option[String] = underlying.typeAliasOption
  override def typeAliasOrNull: String = underlying.typeAliasOrNull
  override def typeAliasOrThrow: String = underlying.typeAliasOrThrow
  override def typeAliasIsSet: Boolean = underlying.typeAliasIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Typedef): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Typedef = underlying.copy(
    typeId = typeId,
    typeAlias = typeAlias,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableTypedef = underlying.mutableCopy()

  override def mergeCopy(that: Typedef): Typedef = underlying.mergeCopy(that)

  override def mutable: MutableTypedef = underlying.mutable

  override def deepCopy(): Typedef = underlying.deepCopy()

  override def fieldForId(id: Int): Typedef._Fields = underlying.fieldForId(id)
  override def isSet(field: Typedef._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Typedef._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Typedef._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableTypedefProxy extends MutableTypedef with TypedefProxy {
  protected def underlying: MutableTypedef

  override def typeId_=(x: String): Unit = { underlying.typeId_=(x) }
  override def typeIdUnset(): Unit = { underlying.typeIdUnset() }
  override def typeAlias_=(x: String): Unit = { underlying.typeAlias_=(x) }
  override def typeAliasUnset(): Unit = { underlying.typeAliasUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableTypedef = underlying.copy(
    typeId = typeId,
    typeAlias = typeAlias,
    __annotations = __annotations
  )

  override def merge(that: Typedef): Unit = underlying.merge(that)
}


final class RawTypedef extends JavaTypedefRaw[com.twitter.thrift.descriptors.Annotation,
      Typedef, RawTypedef, TypedefMeta
    ]
    with MutableTypedef {
  override def meta: TypedefMeta = Typedef

  // fields
  // Field #1 - typeId
  private var _typeId: String = null  // Underlying type: String
  override def typeId: String = typeIdOrThrow
  override def typeId_=(x: String): Unit = { _typeId = x }
  override def typeIdOption: Option[String] = if (typeIdIsSet) Some(_typeId) else None
  override def typeIdOrNull: String = _typeId
  override def typeIdOrThrow: String = if (typeIdIsSet) _typeId else throw new java.lang.NullPointerException("field typeId of Typedef missing")
  override def typeIdIsSet: Boolean = _typeId != null
  override def typeIdUnset(): Unit = { _typeId = null }
  // Field #2 - typeAlias
  private var _typeAlias: String = null  // Underlying type: String
  override def typeAlias: String = typeAliasOrThrow
  override def typeAlias_=(x: String): Unit = { _typeAlias = x }
  override def typeAliasOption: Option[String] = if (typeAliasIsSet) Some(_typeAlias) else None
  override def typeAliasOrNull: String = _typeAlias
  override def typeAliasOrThrow: String = if (typeAliasIsSet) _typeAlias else throw new java.lang.NullPointerException("field typeAlias of Typedef missing")
  override def typeAliasIsSet: Boolean = _typeAlias != null
  override def typeAliasUnset(): Unit = { _typeAlias = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Typedef missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Typedef.TYPEDEF_SDESC)
    if (typeIdIsSet) {
      oprot.writeFieldBegin(Typedef.TYPEID_FDESC)
      oprot.writeString(_typeId)
      oprot.writeFieldEnd()
    }
    if (typeAliasIsSet) {
      oprot.writeFieldBegin(Typedef.TYPEALIAS_FDESC)
      oprot.writeString(_typeAlias)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Typedef.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Typedef.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // typeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // typeAlias

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeAlias = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Typedef".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Typedef): Unit = {
    if (that.typeIdIsSet && !this.typeIdIsSet) {
      this.typeId_=(that.typeIdOrNull)
    }
    if (that.typeAliasIsSet && !this.typeAliasIsSet) {
      this.typeAlias_=(that.typeAliasOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Typedef): Typedef = {
    val ret = Typedef.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Typedef => this.equals(o)
    case _ => false
  }

  def equals(that: Typedef): Boolean = {
    that != null &&
    (if (this.typeIdIsSet) (that.typeIdIsSet && this.typeIdOrNull == that.typeIdOrNull) else !that.typeIdIsSet) &&
    (if (this.typeAliasIsSet) (that.typeAliasIsSet && this.typeAliasOrNull == that.typeAliasOrNull) else !that.typeAliasIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (typeIdIsSet) hasher.append(_typeId.##)
    if (typeAliasIsSet) hasher.append(_typeAlias.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (typeIdIsSet) ret = typeIdOrNull :: ret
    if (typeAliasIsSet) ret = typeAliasOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    typeIdUnset()
    typeAliasUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Typedef._Fields = id match {
    case 1 => Typedef._Fields.typeId
    case 2 => Typedef._Fields.typeAlias
    case 99 => Typedef._Fields.__annotations
    case _ => null
  }

  def isSet(field: Typedef._Fields): Boolean = field match {
    case Typedef._Fields.typeId => typeIdIsSet
    case Typedef._Fields.typeAlias => typeAliasIsSet
    case Typedef._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Typedef._Fields): AnyRef = field match {
    case Typedef._Fields.typeId => typeIdOrNull.asInstanceOf[AnyRef]
    case Typedef._Fields.typeAlias => typeAliasOrNull.asInstanceOf[AnyRef]
    case Typedef._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Typedef._Fields, value: AnyRef) {
    field match {
      case Typedef._Fields.typeId => typeId_=(value.asInstanceOf[String])
      case Typedef._Fields.typeAlias => typeAlias_=(value.asInstanceOf[String])
      case Typedef._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawTypedef = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Typedef.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      typeId: String = typeIdOrNull,
      typeAlias: String = typeAliasOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawTypedef = {
    val ret = new RawTypedef
    if (typeId != null) ret.typeId_=(typeId)
    if (typeAlias != null) ret.typeAlias_=(typeAlias)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object TypeRegistry extends TypeRegistryMeta {


  object Builder {
    sealed trait HasIdToType
    sealed trait HasAliasToTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasIdToType with HasAliasToTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[TypeRegistry] (private var obj: RawTypeRegistry) {
    def idToType(v: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): TypeRegistry.Builder[State with Builder.HasIdToType] = {
      obj.idToType_=(v)
      this.asInstanceOf[TypeRegistry.Builder[State with Builder.HasIdToType]]
    }

    def aliasToTypeId(v: scala.collection.immutable.Map[String, String]): TypeRegistry.Builder[State with Builder.HasAliasToTypeId] = {
      obj.aliasToTypeId_=(v)
      this.asInstanceOf[TypeRegistry.Builder[State with Builder.HasAliasToTypeId]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasIdToType, ev1: State <:< Builder.HasAliasToTypeId): MutableTypeRegistry = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("TypeRegistry.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasIdToType, ev1: State <:< Builder.HasAliasToTypeId): TypeRegistry = resultMutable()(ev0, ev1)
  }

  def newBuilder: TypeRegistry.Builder.AllUnspecified = new Builder(TypeRegistry.createRawRecord)

  implicit val companionProvider: TypeRegistryCompanionProvider = new TypeRegistryCompanionProvider
}

class TypeRegistryMeta
    extends JavaTypeRegistryMeta[TypeRegistry, RawTypeRegistry, TypeRegistryMeta]
    with com.foursquare.spindle.RecordProvider[TypeRegistry] {
  override def recordName: String = "TypeRegistry"


  // Thrift descriptors.
  val TYPEREGISTRY_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("TypeRegistry")

  val IDTOTYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "idToType",
      org.apache.thrift.protocol.TType.MAP,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ALIASTOTYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "aliasToTypeId",
      org.apache.thrift.protocol.TType.MAP,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "idToType" -> IDTOTYPE_FDESC,
    "aliasToTypeId" -> ALIASTOTYPEID_FDESC
  )

  object _Fields {
    case object idToType extends _Fields(1, "idToType")
    case object aliasToTypeId extends _Fields(2, "aliasToTypeId")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.idToType,
    2.toShort -> _Fields.aliasToTypeId
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: TypeRegistry = createRawRecord
  override def createRawRecord: RawTypeRegistry = new RawTypeRegistry

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[TypeRegistry] = {
    if (x.isInstanceOf[TypeRegistry]) Some(x.asInstanceOf[TypeRegistry]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val idToType =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type], TypeRegistry, TypeRegistryMeta](
      name = "idToType",
      longName = "idToType",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.idToTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[TypeRegistry], v: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]) => { r.asInstanceOf[RawTypeRegistry].idToType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[TypeRegistry]) => { r.asInstanceOf[RawTypeRegistry].idToTypeUnset() },
      manifest = manifest[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]]
    )

  val aliasToTypeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.immutable.Map[String, String], TypeRegistry, TypeRegistryMeta](
      name = "aliasToTypeId",
      longName = "aliasToTypeId",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.aliasToTypeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[TypeRegistry], v: scala.collection.immutable.Map[String, String]) => { r.asInstanceOf[RawTypeRegistry].aliasToTypeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[TypeRegistry]) => { r.asInstanceOf[RawTypeRegistry].aliasToTypeIdUnset() },
      manifest = manifest[scala.collection.immutable.Map[String, String]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, TypeRegistry, TypeRegistryMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, TypeRegistry, TypeRegistryMeta]](
      idToType,
      aliasToTypeId
    )


  def apply(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type],
      aliasToTypeId: scala.collection.immutable.Map[String, String]
  ): TypeRegistry = {
    val ret = this.createRawRecord
    ret.idToType_=(idToType)
    ret.aliasToTypeId_=(aliasToTypeId)
    ret
  }
}

class TypeRegistryCompanionProvider extends com.foursquare.spindle.CompanionProvider[TypeRegistry] {
  type CompanionT = TypeRegistryMeta
  override def provide: TypeRegistryMeta = TypeRegistry
}


trait TypeRegistry
    extends JavaTypeRegistry[com.twitter.thrift.descriptors.Type,
      TypeRegistry, RawTypeRegistry, TypeRegistryMeta
    ]
    with org.apache.thrift.TBase[TypeRegistry, TypeRegistry._Fields] {

  override def meta: TypeRegistryMeta

  override def compare(that: TypeRegistry): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.idToTypeIsSet.compareTo(that.idToTypeIsSet)
      cmp != 0 }) cmp
    else if (this.idToTypeIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSMap(this.idToType).asJava, scalaj.collection.Implicits.RichSMap(that.idToType).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.aliasToTypeIdIsSet.compareTo(that.aliasToTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.aliasToTypeIdIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSMap(this.aliasToTypeId).asJava, scalaj.collection.Implicits.RichSMap(that.aliasToTypeId).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: TypeRegistry): Boolean = { this.compare(that) < 0 }
  override def >(that: TypeRegistry): Boolean = { this.compare(that) > 0 }
  override def <=(that: TypeRegistry): Boolean = { this.compare(that) <= 0 }
  override def >=(that: TypeRegistry): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: TypeRegistry): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): TypeRegistry

  def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): TypeRegistry

  def mutableCopy(): MutableTypeRegistry = {
    val ret = TypeRegistry.createRawRecord

    if (idToTypeIsSet) ret.idToType_=(idToTypeOrNull)

    if (aliasToTypeIdIsSet) ret.aliasToTypeId_=(aliasToTypeIdOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableTypeRegistry

  def toBuilder(): TypeRegistry.Builder.AllSpecified = {
    val ret = new TypeRegistry.Builder(TypeRegistry.createRawRecord)

    if (idToTypeIsSet) ret.idToType(idToTypeOrNull)

    if (aliasToTypeIdIsSet) ret.aliasToTypeId(aliasToTypeIdOrNull)
    ret
  }

  def mergeCopy(that: TypeRegistry): TypeRegistry

}

trait MutableTypeRegistry extends TypeRegistry
    with JavaTypeRegistryMutable[com.twitter.thrift.descriptors.Type,
      TypeRegistry, RawTypeRegistry, TypeRegistryMeta
    ] {
  def idToType_=(x: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): Unit
  def idToTypeUnset(): Unit
  def aliasToTypeId_=(x: scala.collection.immutable.Map[String, String]): Unit
  def aliasToTypeIdUnset(): Unit

  def merge(that: TypeRegistry): Unit

  def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): MutableTypeRegistry

  override def mutable: MutableTypeRegistry = this
}



final class RawTypeRegistry extends JavaTypeRegistryRaw[com.twitter.thrift.descriptors.Type,
      TypeRegistry, RawTypeRegistry, TypeRegistryMeta
    ]
    with MutableTypeRegistry {
  override def meta: TypeRegistryMeta = TypeRegistry

  // fields
  // Field #1 - idToType
  private var _idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = null  // Underlying type: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]
  override def idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrDefault
  override def idToType_=(x: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]): Unit = { _idToType = x }
  override def idToTypeOption: Option[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]] = if (idToTypeIsSet) Some(_idToType) else None
  override def idToTypeOrDefault: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = if (idToTypeIsSet) _idToType else scala.collection.immutable.Map.empty
  override def idToTypeOrNull: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = _idToType
  override def idToTypeOrThrow: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = if (idToTypeIsSet) _idToType else throw new java.lang.NullPointerException("field idToType of TypeRegistry missing")
  override def idToTypeIsSet: Boolean = _idToType != null
  override def idToTypeUnset(): Unit = { _idToType = null }
  // Field #2 - aliasToTypeId
  private var _aliasToTypeId: scala.collection.immutable.Map[String, String] = null  // Underlying type: scala.collection.immutable.Map[String, String]
  override def aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrDefault
  override def aliasToTypeId_=(x: scala.collection.immutable.Map[String, String]): Unit = { _aliasToTypeId = x }
  override def aliasToTypeIdOption: Option[scala.collection.immutable.Map[String, String]] = if (aliasToTypeIdIsSet) Some(_aliasToTypeId) else None
  override def aliasToTypeIdOrDefault: scala.collection.immutable.Map[String, String] = if (aliasToTypeIdIsSet) _aliasToTypeId else scala.collection.immutable.Map.empty
  override def aliasToTypeIdOrNull: scala.collection.immutable.Map[String, String] = _aliasToTypeId
  override def aliasToTypeIdOrThrow: scala.collection.immutable.Map[String, String] = if (aliasToTypeIdIsSet) _aliasToTypeId else throw new java.lang.NullPointerException("field aliasToTypeId of TypeRegistry missing")
  override def aliasToTypeIdIsSet: Boolean = _aliasToTypeId != null
  override def aliasToTypeIdUnset(): Unit = { _aliasToTypeId = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(TypeRegistry.TYPEREGISTRY_SDESC)
    if (idToTypeIsSet) {
      oprot.writeFieldBegin(TypeRegistry.IDTOTYPE_FDESC)
      oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRUCT, _idToType.size))
      _idToType.foreach(item => {
        oprot.writeString(item._1)
        item._2.write(oprot)
      })
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    }
    if (aliasToTypeIdIsSet) {
      oprot.writeFieldBegin(TypeRegistry.ALIASTOTYPEID_FDESC)
      oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, _aliasToTypeId.size))
      _aliasToTypeId.foreach(item => {
        oprot.writeString(item._1)
        oprot.writeString(item._2)
      })
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        TypeRegistry.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // idToType

            if (field_header.`type` == org.apache.thrift.protocol.TType.MAP) {
              _idToType = {
                val tmap: org.apache.thrift.protocol.TMap = iprot.readMapBegin()
                val builder = scala.collection.immutable.Map.newBuilder[String, com.twitter.thrift.descriptors.Type]
                builder.sizeHint(tmap.size)
                var i: Int = tmap.size
                while (i > 0) {
                  val k = iprot.readString()
                  val v = ({
                    val s = com.twitter.thrift.descriptors.Type.createRawRecord
                    s.read(iprot)
                    s
                  })
                  builder += ((k, v))
                  i -= 1
                }
                builder.result()
              }
              iprot.readMapEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // aliasToTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.MAP) {
              _aliasToTypeId = {
                val tmap: org.apache.thrift.protocol.TMap = iprot.readMapBegin()
                val builder = scala.collection.immutable.Map.newBuilder[String, String]
                builder.sizeHint(tmap.size)
                var i: Int = tmap.size
                while (i > 0) {
                  val k = iprot.readString()
                  val v = iprot.readString()
                  builder += ((k, v))
                  i -= 1
                }
                builder.result()
              }
              iprot.readMapEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure TypeRegistry".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: TypeRegistry): Unit = {
    if (that.idToTypeIsSet && !this.idToTypeIsSet) {
      this.idToType_=(that.idToTypeOrNull)

    } else if (that.idToTypeIsSet && this.idToTypeIsSet) {
      this.idToType_=(this.idToType ++ that.idToType)
    }
    if (that.aliasToTypeIdIsSet && !this.aliasToTypeIdIsSet) {
      this.aliasToTypeId_=(that.aliasToTypeIdOrNull)

    } else if (that.aliasToTypeIdIsSet && this.aliasToTypeIdIsSet) {
      this.aliasToTypeId_=(this.aliasToTypeId ++ that.aliasToTypeId)
    }
  }

  override def mergeCopy(that: TypeRegistry): TypeRegistry = {
    val ret = TypeRegistry.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: TypeRegistry => this.equals(o)
    case _ => false
  }

  def equals(that: TypeRegistry): Boolean = {
    that != null &&
    (if (this.idToTypeIsSet) (that.idToTypeIsSet && this.idToTypeOrNull == that.idToTypeOrNull) else !that.idToTypeIsSet) &&
    (if (this.aliasToTypeIdIsSet) (that.aliasToTypeIdIsSet && this.aliasToTypeIdOrNull == that.aliasToTypeIdOrNull) else !that.aliasToTypeIdIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (idToTypeIsSet) hasher.append(_idToType.##)
    if (aliasToTypeIdIsSet) hasher.append(_aliasToTypeId.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (idToTypeIsSet) ret = idToTypeOrNull :: ret
    if (aliasToTypeIdIsSet) ret = aliasToTypeIdOrNull :: ret
    ret.reverse
  }

  override def clear() {
    idToTypeUnset()
    aliasToTypeIdUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): TypeRegistry._Fields = id match {
    case 1 => TypeRegistry._Fields.idToType
    case 2 => TypeRegistry._Fields.aliasToTypeId
    case _ => null
  }

  def isSet(field: TypeRegistry._Fields): Boolean = field match {
    case TypeRegistry._Fields.idToType => idToTypeIsSet
    case TypeRegistry._Fields.aliasToTypeId => aliasToTypeIdIsSet
    case _ => false
  }

  def getFieldValue(field: TypeRegistry._Fields): AnyRef = field match {
    case TypeRegistry._Fields.idToType => idToTypeOrNull.asInstanceOf[AnyRef]
    case TypeRegistry._Fields.aliasToTypeId => aliasToTypeIdOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: TypeRegistry._Fields, value: AnyRef) {
    field match {
      case TypeRegistry._Fields.idToType => idToType_=(value.asInstanceOf[scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type]])
      case TypeRegistry._Fields.aliasToTypeId => aliasToTypeId_=(value.asInstanceOf[scala.collection.immutable.Map[String, String]])
      case _ =>
    }
  }

  override def deepCopy(): RawTypeRegistry = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = TypeRegistry.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      idToType: scala.collection.immutable.Map[String, com.twitter.thrift.descriptors.Type] = idToTypeOrNull,
      aliasToTypeId: scala.collection.immutable.Map[String, String] = aliasToTypeIdOrNull
  ): RawTypeRegistry = {
    val ret = new RawTypeRegistry
    if (idToType != null) ret.idToType_=(idToType)
    if (aliasToTypeId != null) ret.aliasToTypeId_=(aliasToTypeId)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Const extends ConstMeta {


  object Builder {
    sealed trait HasTypeId
    sealed trait HasName
    sealed trait HasValue

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeId with HasName with HasValue
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Const] (private var obj: RawConst) {
    def typeId(v: String): Const.Builder[State with Builder.HasTypeId] = {
      obj.typeId_=(v)
      this.asInstanceOf[Const.Builder[State with Builder.HasTypeId]]
    }

    def name(v: String): Const.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Const.Builder[State with Builder.HasName]]
    }

    def value(v: String): Const.Builder[State with Builder.HasValue] = {
      obj.value_=(v)
      this.asInstanceOf[Const.Builder[State with Builder.HasValue]]
    }


    def resultMutable()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasValue): MutableConst = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Const.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeId, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasValue): Const = resultMutable()(ev0, ev1, ev2)
  }

  def newBuilder: Const.Builder.AllUnspecified = new Builder(Const.createRawRecord)

  implicit val companionProvider: ConstCompanionProvider = new ConstCompanionProvider
}

class ConstMeta
    extends JavaConstMeta[Const, RawConst, ConstMeta]
    with com.foursquare.spindle.RecordProvider[Const] {
  override def recordName: String = "Const"


  // Thrift descriptors.
  val CONST_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Const")

  val TYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeId",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val VALUE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "value",
      org.apache.thrift.protocol.TType.STRING,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "typeId" -> TYPEID_FDESC,
    "name" -> NAME_FDESC,
    "value" -> VALUE_FDESC
  )

  object _Fields {
    case object typeId extends _Fields(1, "typeId")
    case object name extends _Fields(2, "name")
    case object value extends _Fields(3, "value")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.typeId,
    2.toShort -> _Fields.name,
    3.toShort -> _Fields.value
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Const = createRawRecord
  override def createRawRecord: RawConst = new RawConst

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Const] = {
    if (x.isInstanceOf[Const]) Some(x.asInstanceOf[Const]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val typeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Const, ConstMeta](
      name = "typeId",
      longName = "typeId",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.typeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Const], v: String) => { r.asInstanceOf[RawConst].typeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Const]) => { r.asInstanceOf[RawConst].typeIdUnset() },
      manifest = manifest[String]
    )

  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Const, ConstMeta](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Const], v: String) => { r.asInstanceOf[RawConst].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Const]) => { r.asInstanceOf[RawConst].nameUnset() },
      manifest = manifest[String]
    )

  val value =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Const, ConstMeta](
      name = "value",
      longName = "value",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.valueOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Const], v: String) => { r.asInstanceOf[RawConst].value_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Const]) => { r.asInstanceOf[RawConst].valueUnset() },
      manifest = manifest[String]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Const, ConstMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Const, ConstMeta]](
      typeId,
      name,
      value
    )


  def apply(
      typeId: String,
      name: String,
      value: String
  ): Const = {
    val ret = this.createRawRecord
    ret.typeId_=(typeId)
    ret.name_=(name)
    ret.value_=(value)
    ret
  }
}

class ConstCompanionProvider extends com.foursquare.spindle.CompanionProvider[Const] {
  type CompanionT = ConstMeta
  override def provide: ConstMeta = Const
}


trait Const
    extends JavaConst[
      Const, RawConst, ConstMeta
    ]
    with org.apache.thrift.TBase[Const, Const._Fields] {

  override def meta: ConstMeta

  override def compare(that: Const): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.typeIdIsSet.compareTo(that.typeIdIsSet)
      cmp != 0 }) cmp
    else if (this.typeIdIsSet && {
      cmp = this.typeIdOrNull.compareTo(that.typeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueIsSet.compareTo(that.valueIsSet)
      cmp != 0 }) cmp
    else if (this.valueIsSet && {
      cmp = this.valueOrNull.compareTo(that.valueOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Const): Boolean = { this.compare(that) < 0 }
  override def >(that: Const): Boolean = { this.compare(that) > 0 }
  override def <=(that: Const): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Const): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Const): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Const

  def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const

  def mutableCopy(): MutableConst = {
    val ret = Const.createRawRecord

    if (typeIdIsSet) ret.typeId_=(typeIdOrNull)

    if (nameIsSet) ret.name_=(nameOrNull)

    if (valueIsSet) ret.value_=(valueOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableConst

  def toBuilder(): Const.Builder.AllSpecified = {
    val ret = new Const.Builder(Const.createRawRecord)

    if (typeIdIsSet) ret.typeId(typeIdOrNull)

    if (nameIsSet) ret.name(nameOrNull)

    if (valueIsSet) ret.value(valueOrNull)
    ret
  }

  def mergeCopy(that: Const): Const

}

trait MutableConst extends Const
    with JavaConstMutable[
      Const, RawConst, ConstMeta
    ] {
  def typeId_=(x: String): Unit
  def typeIdUnset(): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def value_=(x: String): Unit
  def valueUnset(): Unit

  def merge(that: Const): Unit

  def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): MutableConst

  override def mutable: MutableConst = this
}


trait ConstProxy extends Const {
  protected def underlying: Const

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def typeId: String = underlying.typeId
  override def typeIdOption: Option[String] = underlying.typeIdOption
  override def typeIdOrNull: String = underlying.typeIdOrNull
  override def typeIdOrThrow: String = underlying.typeIdOrThrow
  override def typeIdIsSet: Boolean = underlying.typeIdIsSet
// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp

  override def value: String = underlying.value
  override def valueOption: Option[String] = underlying.valueOption
  override def valueOrNull: String = underlying.valueOrNull
  override def valueOrThrow: String = underlying.valueOrThrow
  override def valueIsSet: Boolean = underlying.valueIsSet

  override def compare(that: Const): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): Const = underlying.copy(
    typeId = typeId,
    name = name,
    value = value
  )

  override def mutableCopy(): MutableConst = underlying.mutableCopy()

  override def mergeCopy(that: Const): Const = underlying.mergeCopy(that)

  override def mutable: MutableConst = underlying.mutable

  override def deepCopy(): Const = underlying.deepCopy()

  override def fieldForId(id: Int): Const._Fields = underlying.fieldForId(id)
  override def isSet(field: Const._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Const._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Const._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableConstProxy extends MutableConst with ConstProxy {
  protected def underlying: MutableConst

  override def typeId_=(x: String): Unit = { underlying.typeId_=(x) }
  override def typeIdUnset(): Unit = { underlying.typeIdUnset() }
  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def value_=(x: String): Unit = { underlying.value_=(x) }
  override def valueUnset(): Unit = { underlying.valueUnset() }

  override def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): MutableConst = underlying.copy(
    typeId = typeId,
    name = name,
    value = value
  )

  override def merge(that: Const): Unit = underlying.merge(that)
}


final class RawConst extends JavaConstRaw[
      Const, RawConst, ConstMeta
    ]
    with MutableConst {
  override def meta: ConstMeta = Const

  // fields
  // Field #1 - typeId
  private var _typeId: String = null  // Underlying type: String
  override def typeId: String = typeIdOrThrow
  override def typeId_=(x: String): Unit = { _typeId = x }
  override def typeIdOption: Option[String] = if (typeIdIsSet) Some(_typeId) else None
  override def typeIdOrNull: String = _typeId
  override def typeIdOrThrow: String = if (typeIdIsSet) _typeId else throw new java.lang.NullPointerException("field typeId of Const missing")
  override def typeIdIsSet: Boolean = _typeId != null
  override def typeIdUnset(): Unit = { _typeId = null }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Const missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #3 - value
  private var _value: String = null  // Underlying type: String
  override def value: String = valueOrThrow
  override def value_=(x: String): Unit = { _value = x }
  override def valueOption: Option[String] = if (valueIsSet) Some(_value) else None
  override def valueOrNull: String = _value
  override def valueOrThrow: String = if (valueIsSet) _value else throw new java.lang.NullPointerException("field value of Const missing")
  override def valueIsSet: Boolean = _value != null
  override def valueUnset(): Unit = { _value = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Const.CONST_SDESC)
    if (typeIdIsSet) {
      oprot.writeFieldBegin(Const.TYPEID_FDESC)
      oprot.writeString(_typeId)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(Const.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (valueIsSet) {
      oprot.writeFieldBegin(Const.VALUE_FDESC)
      oprot.writeString(_value)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Const.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // typeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // value

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _value = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Const".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Const): Unit = {
    if (that.typeIdIsSet && !this.typeIdIsSet) {
      this.typeId_=(that.typeIdOrNull)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.valueIsSet && !this.valueIsSet) {
      this.value_=(that.valueOrNull)
    }
  }

  override def mergeCopy(that: Const): Const = {
    val ret = Const.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Const => this.equals(o)
    case _ => false
  }

  def equals(that: Const): Boolean = {
    that != null &&
    (if (this.typeIdIsSet) (that.typeIdIsSet && this.typeIdOrNull == that.typeIdOrNull) else !that.typeIdIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.valueIsSet) (that.valueIsSet && this.valueOrNull == that.valueOrNull) else !that.valueIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (typeIdIsSet) hasher.append(_typeId.##)
    if (nameIsSet) hasher.append(_name.##)
    if (valueIsSet) hasher.append(_value.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (typeIdIsSet) ret = typeIdOrNull :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    if (valueIsSet) ret = valueOrNull :: ret
    ret.reverse
  }

  override def clear() {
    typeIdUnset()
    nameUnset()
    valueUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Const._Fields = id match {
    case 1 => Const._Fields.typeId
    case 2 => Const._Fields.name
    case 3 => Const._Fields.value
    case _ => null
  }

  def isSet(field: Const._Fields): Boolean = field match {
    case Const._Fields.typeId => typeIdIsSet
    case Const._Fields.name => nameIsSet
    case Const._Fields.value => valueIsSet
    case _ => false
  }

  def getFieldValue(field: Const._Fields): AnyRef = field match {
    case Const._Fields.typeId => typeIdOrNull.asInstanceOf[AnyRef]
    case Const._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Const._Fields.value => valueOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Const._Fields, value: AnyRef) {
    field match {
      case Const._Fields.typeId => typeId_=(value.asInstanceOf[String])
      case Const._Fields.name => name_=(value.asInstanceOf[String])
      case Const._Fields.value => value_=(value.asInstanceOf[String])
      case _ =>
    }
  }

  override def deepCopy(): RawConst = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Const.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      typeId: String = typeIdOrNull,
      name: String = nameOrNull,
      value: String = valueOrNull
  ): RawConst = {
    val ret = new RawConst
    if (typeId != null) ret.typeId_=(typeId)
    if (name != null) ret.name_=(name)
    if (value != null) ret.value_=(value)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object EnumElement extends EnumElementMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasValue

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasValue
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[EnumElement] (private var obj: RawEnumElement) {
    def name(v: String): EnumElement.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[EnumElement.Builder[State with Builder.HasName]]
    }

    def value(v: Int): EnumElement.Builder[State with Builder.HasValue] = {
      obj.value_=(v)
      this.asInstanceOf[EnumElement.Builder[State with Builder.HasValue]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): EnumElement.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): EnumElement.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasValue): MutableEnumElement = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("EnumElement.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasValue): EnumElement = resultMutable()(ev0, ev1)
  }

  def newBuilder: EnumElement.Builder.AllUnspecified = new Builder(EnumElement.createRawRecord)

  implicit val companionProvider: EnumElementCompanionProvider = new EnumElementCompanionProvider
}

class EnumElementMeta
    extends JavaEnumElementMeta[EnumElement, RawEnumElement, EnumElementMeta]
    with com.foursquare.spindle.RecordProvider[EnumElement] {
  override def recordName: String = "EnumElement"


  // Thrift descriptors.
  val ENUMELEMENT_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("EnumElement")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val VALUE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "value",
      org.apache.thrift.protocol.TType.I32,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "value" -> VALUE_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object value extends _Fields(2, "value")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.value,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: EnumElement = createRawRecord
  override def createRawRecord: RawEnumElement = new RawEnumElement

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[EnumElement] = {
    if (x.isInstanceOf[EnumElement]) Some(x.asInstanceOf[EnumElement]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, EnumElement, EnumElementMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[EnumElement], v: String) => { r.asInstanceOf[RawEnumElement].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[EnumElement]) => { r.asInstanceOf[RawEnumElement].nameUnset() },
      manifest = manifest[String]
    )

  val value =

    new com.foursquare.spindle.OptionalFieldDescriptor[Int, EnumElement, EnumElementMeta](
      name = "value",
      longName = "value",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.valueOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[EnumElement], v: Int) => { r.asInstanceOf[RawEnumElement].value_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[EnumElement]) => { r.asInstanceOf[RawEnumElement].valueUnset() },
      manifest = manifest[Int]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], EnumElement, EnumElementMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[EnumElement], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawEnumElement].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[EnumElement]) => { r.asInstanceOf[RawEnumElement].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, EnumElement, EnumElementMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, EnumElement, EnumElementMeta]](
      name,
      value,
      __annotations
    )


  def apply(
      name: String,
      value: Int,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): EnumElement = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.value_=(value)
    ret.__annotations_=(__annotations)
    ret
  }
}

class EnumElementCompanionProvider extends com.foursquare.spindle.CompanionProvider[EnumElement] {
  type CompanionT = EnumElementMeta
  override def provide: EnumElementMeta = EnumElement
}


trait EnumElement
    extends JavaEnumElement[com.twitter.thrift.descriptors.Annotation,
      EnumElement, RawEnumElement, EnumElementMeta
    ]
    with org.apache.thrift.TBase[EnumElement, EnumElement._Fields] {

  override def meta: EnumElementMeta

  override def compare(that: EnumElement): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.valueIsSet.compareTo(that.valueIsSet)
      cmp != 0 }) cmp
    else if (this.valueIsSet && {
      cmp = this.value.compareTo(that.value)

      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: EnumElement): Boolean = { this.compare(that) < 0 }
  override def >(that: EnumElement): Boolean = { this.compare(that) > 0 }
  override def <=(that: EnumElement): Boolean = { this.compare(that) <= 0 }
  override def >=(that: EnumElement): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: EnumElement): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): EnumElement

  def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement

  def mutableCopy(): MutableEnumElement = {
    val ret = EnumElement.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (valueIsSet) ret.value_=(valueOrDefault)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableEnumElement

  def toBuilder(): EnumElement.Builder.AllSpecified = {
    val ret = new EnumElement.Builder(EnumElement.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (valueIsSet) ret.value(valueOrDefault)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: EnumElement): EnumElement

}

trait MutableEnumElement extends EnumElement
    with JavaEnumElementMutable[com.twitter.thrift.descriptors.Annotation,
      EnumElement, RawEnumElement, EnumElementMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def value_=(x: Int): Unit
  def valueUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: EnumElement): Unit

  def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableEnumElement

  override def mutable: MutableEnumElement = this
}


trait EnumElementProxy extends EnumElement {
  protected def underlying: EnumElement

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_primitive.ssp
  override def value: Int = underlying.value
  override def valueOption: Option[Int] = underlying.valueOption
  override def valueOrDefault: Int = underlying.valueOrDefault
  override def valueOrNull: java.lang.Integer = underlying.valueOrNull
  override def valueOrThrow: Int = underlying.valueOrThrow
  override def valueIsSet: Boolean = underlying.valueIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: EnumElement): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): EnumElement = underlying.copy(
    name = name,
    value = value,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableEnumElement = underlying.mutableCopy()

  override def mergeCopy(that: EnumElement): EnumElement = underlying.mergeCopy(that)

  override def mutable: MutableEnumElement = underlying.mutable

  override def deepCopy(): EnumElement = underlying.deepCopy()

  override def fieldForId(id: Int): EnumElement._Fields = underlying.fieldForId(id)
  override def isSet(field: EnumElement._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: EnumElement._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: EnumElement._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableEnumElementProxy extends MutableEnumElement with EnumElementProxy {
  protected def underlying: MutableEnumElement

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def value_=(x: Int): Unit = { underlying.value_=(x) }
  override def valueUnset(): Unit = { underlying.valueUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableEnumElement = underlying.copy(
    name = name,
    value = value,
    __annotations = __annotations
  )

  override def merge(that: EnumElement): Unit = underlying.merge(that)
}


final class RawEnumElement extends JavaEnumElementRaw[com.twitter.thrift.descriptors.Annotation,
      EnumElement, RawEnumElement, EnumElementMeta
    ]
    with MutableEnumElement {
  override def meta: EnumElementMeta = EnumElement

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of EnumElement missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - value
  private var _value: Int = 0  // Underlying type: Int
  private var _valueIsSet: Boolean = false
  override def value: Int = valueOrDefault
  override def value_=(x: Int): Unit = { _value = x ; _valueIsSet = true }
  override def valueOption: Option[Int] = if (valueIsSet) Some(_value) else None
  override def valueOrDefault: Int = _value
  override def valueOrNull: java.lang.Integer = if (valueIsSet) _value else null
  override def valueOrThrow: Int = if (valueIsSet) _value else throw new java.lang.NullPointerException("field value of EnumElement missing")
  override def valueIsSet: Boolean = _valueIsSet
  override def valueUnset(): Unit = { _valueIsSet = false; _value = 0 }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of EnumElement missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(EnumElement.ENUMELEMENT_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(EnumElement.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (valueIsSet) {
      oprot.writeFieldBegin(EnumElement.VALUE_FDESC)
      oprot.writeI32(_value)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(EnumElement.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        EnumElement.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // value

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32) {
              _value = iprot.readI32()

              _valueIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure EnumElement".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: EnumElement): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.valueIsSet && !this.valueIsSet) {
      this.value_=(that.valueOrDefault)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: EnumElement): EnumElement = {
    val ret = EnumElement.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: EnumElement => this.equals(o)
    case _ => false
  }

  def equals(that: EnumElement): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.valueIsSet) (that.valueIsSet && this.valueOrDefault == that.valueOrDefault) else !that.valueIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (valueIsSet) hasher.append(_value.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (valueIsSet) ret = valueOrDefault :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    valueUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): EnumElement._Fields = id match {
    case 1 => EnumElement._Fields.name
    case 2 => EnumElement._Fields.value
    case 99 => EnumElement._Fields.__annotations
    case _ => null
  }

  def isSet(field: EnumElement._Fields): Boolean = field match {
    case EnumElement._Fields.name => nameIsSet
    case EnumElement._Fields.value => valueIsSet
    case EnumElement._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: EnumElement._Fields): AnyRef = field match {
    case EnumElement._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case EnumElement._Fields.value => valueOrDefault.asInstanceOf[AnyRef]
    case EnumElement._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: EnumElement._Fields, value: AnyRef) {
    field match {
      case EnumElement._Fields.name => name_=(value.asInstanceOf[String])
      case EnumElement._Fields.value => value_=(value.asInstanceOf[Int])
      case EnumElement._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawEnumElement = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = EnumElement.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      value: java.lang.Integer = valueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawEnumElement = {
    val ret = new RawEnumElement
    if (name != null) ret.name_=(name)
    if (value != null) ret.value_=(value)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Enum extends EnumMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasElements

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasElements
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Enum] (private var obj: RawEnum) {
    def name(v: String): Enum.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Enum.Builder[State with Builder.HasName]]
    }

    def elements(v: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Enum.Builder[State with Builder.HasElements] = {
      obj.elements_=(v)
      this.asInstanceOf[Enum.Builder[State with Builder.HasElements]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Enum.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Enum.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasElements): MutableEnum = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Enum.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasElements): Enum = resultMutable()(ev0, ev1)
  }

  def newBuilder: Enum.Builder.AllUnspecified = new Builder(Enum.createRawRecord)

  implicit val companionProvider: EnumCompanionProvider = new EnumCompanionProvider
}

class EnumMeta
    extends JavaEnumMeta[Enum, RawEnum, EnumMeta]
    with com.foursquare.spindle.RecordProvider[Enum] {
  override def recordName: String = "Enum"


  // Thrift descriptors.
  val ENUM_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Enum")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ELEMENTS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "elements",
      org.apache.thrift.protocol.TType.LIST,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "elements" -> ELEMENTS_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object elements extends _Fields(2, "elements")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.elements,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Enum = createRawRecord
  override def createRawRecord: RawEnum = new RawEnum

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Enum] = {
    if (x.isInstanceOf[Enum]) Some(x.asInstanceOf[Enum]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Enum, EnumMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Enum], v: String) => { r.asInstanceOf[RawEnum].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Enum]) => { r.asInstanceOf[RawEnum].nameUnset() },
      manifest = manifest[String]
    )

  val elements =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement], Enum, EnumMeta](
      name = "elements",
      longName = "elements",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.elementsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Enum], v: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]) => { r.asInstanceOf[RawEnum].elements_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Enum]) => { r.asInstanceOf[RawEnum].elementsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Enum, EnumMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Enum], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawEnum].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Enum]) => { r.asInstanceOf[RawEnum].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Enum, EnumMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Enum, EnumMeta]](
      name,
      elements,
      __annotations
    )


  def apply(
      name: String,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Enum = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.elements_=(elements)
    ret.__annotations_=(__annotations)
    ret
  }
}

class EnumCompanionProvider extends com.foursquare.spindle.CompanionProvider[Enum] {
  type CompanionT = EnumMeta
  override def provide: EnumMeta = Enum
}


trait Enum
    extends JavaEnum[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.EnumElement,
      Enum, RawEnum, EnumMeta
    ]
    with org.apache.thrift.TBase[Enum, Enum._Fields] {

  override def meta: EnumMeta

  override def compare(that: Enum): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.elementsIsSet.compareTo(that.elementsIsSet)
      cmp != 0 }) cmp
    else if (this.elementsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.elements).asJava, scalaj.collection.Implicits.RichSSeq(that.elements).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Enum): Boolean = { this.compare(that) < 0 }
  override def >(that: Enum): Boolean = { this.compare(that) > 0 }
  override def <=(that: Enum): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Enum): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Enum): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Enum

  def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum

  def mutableCopy(): MutableEnum = {
    val ret = Enum.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (elementsIsSet) ret.elements_=(elementsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableEnum

  def toBuilder(): Enum.Builder.AllSpecified = {
    val ret = new Enum.Builder(Enum.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (elementsIsSet) ret.elements(elementsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Enum): Enum

}

trait MutableEnum extends Enum
    with JavaEnumMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.EnumElement,
      Enum, RawEnum, EnumMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def elements_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Unit
  def elementsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Enum): Unit

  def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableEnum

  override def mutable: MutableEnum = this
}


trait EnumProxy extends Enum {
  protected def underlying: Enum

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elements
  override def elementsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]] = underlying.elementsOption
  override def elementsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elementsOrDefault
  override def elementsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elementsOrNull
  override def elementsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = underlying.elementsOrThrow
  override def elementsIsSet: Boolean = underlying.elementsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Enum): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Enum = underlying.copy(
    name = name,
    elements = elements,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableEnum = underlying.mutableCopy()

  override def mergeCopy(that: Enum): Enum = underlying.mergeCopy(that)

  override def mutable: MutableEnum = underlying.mutable

  override def deepCopy(): Enum = underlying.deepCopy()

  override def fieldForId(id: Int): Enum._Fields = underlying.fieldForId(id)
  override def isSet(field: Enum._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Enum._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Enum._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableEnumProxy extends MutableEnum with EnumProxy {
  protected def underlying: MutableEnum

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def elements_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Unit = { underlying.elements_=(x) }
  override def elementsUnset(): Unit = { underlying.elementsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableEnum = underlying.copy(
    name = name,
    elements = elements,
    __annotations = __annotations
  )

  override def merge(that: Enum): Unit = underlying.merge(that)
}


final class RawEnum extends JavaEnumRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.EnumElement,
      Enum, RawEnum, EnumMeta
    ]
    with MutableEnum {
  override def meta: EnumMeta = Enum

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Enum missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - elements
  private var _elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]
  override def elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrDefault
  override def elements_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]): Unit = { _elements = x }
  override def elementsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]] = if (elementsIsSet) Some(_elements) else None
  override def elementsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = if (elementsIsSet) _elements else scala.collection.Seq.empty
  override def elementsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = _elements
  override def elementsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = if (elementsIsSet) _elements else throw new java.lang.NullPointerException("field elements of Enum missing")
  override def elementsIsSet: Boolean = _elements != null
  override def elementsUnset(): Unit = { _elements = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Enum missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Enum.ENUM_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Enum.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (elementsIsSet) {
      oprot.writeFieldBegin(Enum.ELEMENTS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _elements.size))
      _elements.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Enum.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Enum.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // elements

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _elements = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.EnumElement]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.EnumElement.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Enum".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Enum): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.elementsIsSet && !this.elementsIsSet) {
      this.elements_=(that.elementsOrNull)

    } else if (that.elementsIsSet && this.elementsIsSet) {
      this.elements_=(this.elements ++ that.elements)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Enum): Enum = {
    val ret = Enum.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Enum => this.equals(o)
    case _ => false
  }

  def equals(that: Enum): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.elementsIsSet) (that.elementsIsSet && this.elementsOrNull == that.elementsOrNull) else !that.elementsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (elementsIsSet) hasher.append(_elements.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (elementsIsSet) ret = elementsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    elementsUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Enum._Fields = id match {
    case 1 => Enum._Fields.name
    case 2 => Enum._Fields.elements
    case 99 => Enum._Fields.__annotations
    case _ => null
  }

  def isSet(field: Enum._Fields): Boolean = field match {
    case Enum._Fields.name => nameIsSet
    case Enum._Fields.elements => elementsIsSet
    case Enum._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Enum._Fields): AnyRef = field match {
    case Enum._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Enum._Fields.elements => elementsOrNull.asInstanceOf[AnyRef]
    case Enum._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Enum._Fields, value: AnyRef) {
    field match {
      case Enum._Fields.name => name_=(value.asInstanceOf[String])
      case Enum._Fields.elements => elements_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement]])
      case Enum._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawEnum = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Enum.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      elements: scala.collection.Seq[com.twitter.thrift.descriptors.EnumElement] = elementsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawEnum = {
    val ret = new RawEnum
    if (name != null) ret.name_=(name)
    if (elements != null) ret.elements_=(elements)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Field extends FieldMeta {


  object Builder {
    sealed trait HasIdentifier
    sealed trait HasName
    sealed trait HasTypeId

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasIdentifier with HasName with HasTypeId
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Field] (private var obj: RawField) {
    def identifier(v: Short): Field.Builder[State with Builder.HasIdentifier] = {
      obj.identifier_=(v)
      this.asInstanceOf[Field.Builder[State with Builder.HasIdentifier]]
    }

    def name(v: String): Field.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Field.Builder[State with Builder.HasName]]
    }

    def typeId(v: String): Field.Builder[State with Builder.HasTypeId] = {
      obj.typeId_=(v)
      this.asInstanceOf[Field.Builder[State with Builder.HasTypeId]]
    }


    def requiredness(v: com.twitter.thrift.descriptors.Requiredness): Field.Builder[State] = {
      obj.requiredness_=(v)
      this
    }

    def requiredness(vOpt: Option[com.twitter.thrift.descriptors.Requiredness]): Field.Builder[State] = {
      vOpt match {
        case Some(v) => obj.requiredness_=(v)
        case None => obj.requirednessUnset()
      }
      this
    }

    def defaultValue(v: String): Field.Builder[State] = {
      obj.defaultValue_=(v)
      this
    }

    def defaultValue(vOpt: Option[String]): Field.Builder[State] = {
      vOpt match {
        case Some(v) => obj.defaultValue_=(v)
        case None => obj.defaultValueUnset()
      }
      this
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Field.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Field.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasIdentifier, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasTypeId): MutableField = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Field.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasIdentifier, ev1: State <:< Builder.HasName, ev2: State <:< Builder.HasTypeId): Field = resultMutable()(ev0, ev1, ev2)
  }

  def newBuilder: Field.Builder.AllUnspecified = new Builder(Field.createRawRecord)

  implicit val companionProvider: FieldCompanionProvider = new FieldCompanionProvider
}

class FieldMeta
    extends JavaFieldMeta[Field, RawField, FieldMeta]
    with com.foursquare.spindle.RecordProvider[Field] {
  override def recordName: String = "Field"


  // Thrift descriptors.
  val FIELD_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Field")

  val IDENTIFIER_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "identifier",
      org.apache.thrift.protocol.TType.I16,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeId",
      org.apache.thrift.protocol.TType.STRING,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val REQUIREDNESS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "requiredness",
      org.apache.thrift.protocol.TType.I32,
      4,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val DEFAULTVALUE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "defaultValue",
      org.apache.thrift.protocol.TType.STRING,
      5,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "identifier" -> IDENTIFIER_FDESC,
    "name" -> NAME_FDESC,
    "typeId" -> TYPEID_FDESC,
    "requiredness" -> REQUIREDNESS_FDESC,
    "defaultValue" -> DEFAULTVALUE_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object identifier extends _Fields(1, "identifier")
    case object name extends _Fields(2, "name")
    case object typeId extends _Fields(3, "typeId")
    case object requiredness extends _Fields(4, "requiredness")
    case object defaultValue extends _Fields(5, "defaultValue")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.identifier,
    2.toShort -> _Fields.name,
    3.toShort -> _Fields.typeId,
    4.toShort -> _Fields.requiredness,
    5.toShort -> _Fields.defaultValue,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Field = createRawRecord
  override def createRawRecord: RawField = new RawField

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Field] = {
    if (x.isInstanceOf[Field]) Some(x.asInstanceOf[Field]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val identifier =

    new com.foursquare.spindle.OptionalFieldDescriptor[Short, Field, FieldMeta](
      name = "identifier",
      longName = "identifier",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.identifierOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Field], v: Short) => { r.asInstanceOf[RawField].identifier_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Field]) => { r.asInstanceOf[RawField].identifierUnset() },
      manifest = manifest[Short]
    )

  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Field, FieldMeta](
      name = "name",
      longName = "name",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Field], v: String) => { r.asInstanceOf[RawField].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Field]) => { r.asInstanceOf[RawField].nameUnset() },
      manifest = manifest[String]
    )

  val typeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Field, FieldMeta](
      name = "typeId",
      longName = "typeId",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.typeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Field], v: String) => { r.asInstanceOf[RawField].typeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Field]) => { r.asInstanceOf[RawField].typeIdUnset() },
      manifest = manifest[String]
    )

  val requiredness =

    new com.foursquare.spindle.OptionalFieldDescriptor[com.twitter.thrift.descriptors.Requiredness, Field, FieldMeta](
      name = "requiredness",
      longName = "requiredness",
      id = 4,
      annotations = Map(),
      owner = this,
      getter = _.requirednessOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Field], v: com.twitter.thrift.descriptors.Requiredness) => { r.asInstanceOf[RawField].requiredness_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Field]) => { r.asInstanceOf[RawField].requirednessUnset() },
      manifest = manifest[com.twitter.thrift.descriptors.Requiredness]
    )

  val defaultValue =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Field, FieldMeta](
      name = "defaultValue",
      longName = "defaultValue",
      id = 5,
      annotations = Map(),
      owner = this,
      getter = _.defaultValueOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Field], v: String) => { r.asInstanceOf[RawField].defaultValue_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Field]) => { r.asInstanceOf[RawField].defaultValueUnset() },
      manifest = manifest[String]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Field, FieldMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Field], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawField].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Field]) => { r.asInstanceOf[RawField].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Field, FieldMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Field, FieldMeta]](
      identifier,
      name,
      typeId,
      requiredness,
      defaultValue,
      __annotations
    )


  def apply(
      identifier: Short,
      name: String,
      typeId: String,
      requiredness: com.twitter.thrift.descriptors.Requiredness,
      defaultValue: String,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Field = {
    val ret = this.createRawRecord
    ret.identifier_=(identifier)
    ret.name_=(name)
    ret.typeId_=(typeId)
    ret.requiredness_=(requiredness)
    ret.defaultValue_=(defaultValue)
    ret.__annotations_=(__annotations)
    ret
  }
}

class FieldCompanionProvider extends com.foursquare.spindle.CompanionProvider[Field] {
  type CompanionT = FieldMeta
  override def provide: FieldMeta = Field
}


trait Field
    extends JavaField[com.twitter.thrift.descriptors.Annotation,
      Field, RawField, FieldMeta
    ]
    with org.apache.thrift.TBase[Field, Field._Fields] {

  override def meta: FieldMeta

  override def compare(that: Field): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.identifierIsSet.compareTo(that.identifierIsSet)
      cmp != 0 }) cmp
    else if (this.identifierIsSet && {
      cmp = this.identifier.compareTo(that.identifier)

      cmp != 0 }) cmp
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typeIdIsSet.compareTo(that.typeIdIsSet)
      cmp != 0 }) cmp
    else if (this.typeIdIsSet && {
      cmp = this.typeIdOrNull.compareTo(that.typeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.requirednessIsSet.compareTo(that.requirednessIsSet)
      cmp != 0 }) cmp
    else if (this.requirednessIsSet && {
      cmp = this.requirednessOrNull.compareTo(that.requirednessOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.defaultValueIsSet.compareTo(that.defaultValueIsSet)
      cmp != 0 }) cmp
    else if (this.defaultValueIsSet && {
      cmp = this.defaultValueOrNull.compareTo(that.defaultValueOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Field): Boolean = { this.compare(that) < 0 }
  override def >(that: Field): Boolean = { this.compare(that) > 0 }
  override def <=(that: Field): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Field): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Field): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Field

  def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field

  def mutableCopy(): MutableField = {
    val ret = Field.createRawRecord

    if (identifierIsSet) ret.identifier_=(identifierOrDefault)

    if (nameIsSet) ret.name_=(nameOrNull)

    if (typeIdIsSet) ret.typeId_=(typeIdOrNull)

    if (requirednessIsSet) ret.requiredness_=(requirednessOrNull)

    if (defaultValueIsSet) ret.defaultValue_=(defaultValueOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableField

  def toBuilder(): Field.Builder.AllSpecified = {
    val ret = new Field.Builder(Field.createRawRecord)

    if (identifierIsSet) ret.identifier(identifierOrDefault)

    if (nameIsSet) ret.name(nameOrNull)

    if (typeIdIsSet) ret.typeId(typeIdOrNull)

    if (requirednessIsSet) ret.requiredness(requirednessOrNull)

    if (defaultValueIsSet) ret.defaultValue(defaultValueOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Field): Field

}

trait MutableField extends Field
    with JavaFieldMutable[com.twitter.thrift.descriptors.Annotation,
      Field, RawField, FieldMeta
    ] {
  def identifier_=(x: Short): Unit
  def identifierUnset(): Unit
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def typeId_=(x: String): Unit
  def typeIdUnset(): Unit
  def requiredness_=(x: com.twitter.thrift.descriptors.Requiredness): Unit
  def requirednessUnset(): Unit
  def defaultValue_=(x: String): Unit
  def defaultValueUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Field): Unit

  def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableField

  override def mutable: MutableField = this
}


trait FieldProxy extends Field {
  protected def underlying: Field

  override def meta = underlying.meta

// field/proxy_primitive.ssp
  override def identifier: Short = underlying.identifier
  override def identifierOption: Option[Short] = underlying.identifierOption
  override def identifierOrDefault: Short = underlying.identifierOrDefault
  override def identifierOrNull: java.lang.Short = underlying.identifierOrNull
  override def identifierOrThrow: Short = underlying.identifierOrThrow
  override def identifierIsSet: Boolean = underlying.identifierIsSet
// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp

  override def typeId: String = underlying.typeId
  override def typeIdOption: Option[String] = underlying.typeIdOption
  override def typeIdOrNull: String = underlying.typeIdOrNull
  override def typeIdOrThrow: String = underlying.typeIdOrThrow
  override def typeIdIsSet: Boolean = underlying.typeIdIsSet
// field/proxy_ref.ssp
  override def requirednessOption: Option[com.twitter.thrift.descriptors.Requiredness] = underlying.requirednessOption
  override def requirednessOrNull: com.twitter.thrift.descriptors.Requiredness = underlying.requirednessOrNull
  override def requirednessOrThrow: com.twitter.thrift.descriptors.Requiredness = underlying.requirednessOrThrow
  override def requirednessIsSet: Boolean = underlying.requirednessIsSet
// field/proxy_ref.ssp
  override def defaultValueOption: Option[String] = underlying.defaultValueOption
  override def defaultValueOrNull: String = underlying.defaultValueOrNull
  override def defaultValueOrThrow: String = underlying.defaultValueOrThrow
  override def defaultValueIsSet: Boolean = underlying.defaultValueIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Field): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Field = underlying.copy(
    identifier = identifier,
    name = name,
    typeId = typeId,
    requiredness = requiredness,
    defaultValue = defaultValue,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableField = underlying.mutableCopy()

  override def mergeCopy(that: Field): Field = underlying.mergeCopy(that)

  override def mutable: MutableField = underlying.mutable

  override def deepCopy(): Field = underlying.deepCopy()

  override def fieldForId(id: Int): Field._Fields = underlying.fieldForId(id)
  override def isSet(field: Field._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Field._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Field._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableFieldProxy extends MutableField with FieldProxy {
  protected def underlying: MutableField

  override def identifier_=(x: Short): Unit = { underlying.identifier_=(x) }
  override def identifierUnset(): Unit = { underlying.identifierUnset() }
  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def typeId_=(x: String): Unit = { underlying.typeId_=(x) }
  override def typeIdUnset(): Unit = { underlying.typeIdUnset() }
  override def requiredness_=(x: com.twitter.thrift.descriptors.Requiredness): Unit = { underlying.requiredness_=(x) }
  override def requirednessUnset(): Unit = { underlying.requirednessUnset() }
  override def defaultValue_=(x: String): Unit = { underlying.defaultValue_=(x) }
  override def defaultValueUnset(): Unit = { underlying.defaultValueUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableField = underlying.copy(
    identifier = identifier,
    name = name,
    typeId = typeId,
    requiredness = requiredness,
    defaultValue = defaultValue,
    __annotations = __annotations
  )

  override def merge(that: Field): Unit = underlying.merge(that)
}


final class RawField extends JavaFieldRaw[com.twitter.thrift.descriptors.Annotation,
      Field, RawField, FieldMeta
    ]
    with MutableField {
  override def meta: FieldMeta = Field

  // fields
  // Field #1 - identifier
  private var _identifier: Short = 0  // Underlying type: Short
  private var _identifierIsSet: Boolean = false
  override def identifier: Short = identifierOrDefault
  override def identifier_=(x: Short): Unit = { _identifier = x ; _identifierIsSet = true }
  override def identifierOption: Option[Short] = if (identifierIsSet) Some(_identifier) else None
  override def identifierOrDefault: Short = _identifier
  override def identifierOrNull: java.lang.Short = if (identifierIsSet) _identifier else null
  override def identifierOrThrow: Short = if (identifierIsSet) _identifier else throw new java.lang.NullPointerException("field identifier of Field missing")
  override def identifierIsSet: Boolean = _identifierIsSet
  override def identifierUnset(): Unit = { _identifierIsSet = false; _identifier = 0 }
  // Field #2 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Field missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #3 - typeId
  private var _typeId: String = null  // Underlying type: String
  override def typeId: String = typeIdOrThrow
  override def typeId_=(x: String): Unit = { _typeId = x }
  override def typeIdOption: Option[String] = if (typeIdIsSet) Some(_typeId) else None
  override def typeIdOrNull: String = _typeId
  override def typeIdOrThrow: String = if (typeIdIsSet) _typeId else throw new java.lang.NullPointerException("field typeId of Field missing")
  override def typeIdIsSet: Boolean = _typeId != null
  override def typeIdUnset(): Unit = { _typeId = null }
  // Field #4 - requiredness
  private var _requiredness: com.twitter.thrift.descriptors.Requiredness = null  // Underlying type: com.twitter.thrift.descriptors.Requiredness
  override def requiredness_=(x: com.twitter.thrift.descriptors.Requiredness): Unit = { _requiredness = x }
  override def requirednessOption: Option[com.twitter.thrift.descriptors.Requiredness] = if (requirednessIsSet) Some(_requiredness) else None
  override def requirednessOrNull: com.twitter.thrift.descriptors.Requiredness = _requiredness
  override def requirednessOrThrow: com.twitter.thrift.descriptors.Requiredness = if (requirednessIsSet) _requiredness else throw new java.lang.NullPointerException("field requiredness of Field missing")
  override def requirednessIsSet: Boolean = _requiredness != null
  override def requirednessUnset(): Unit = { _requiredness = null }
  // Field #5 - defaultValue
  private var _defaultValue: String = null  // Underlying type: String
  override def defaultValue_=(x: String): Unit = { _defaultValue = x }
  override def defaultValueOption: Option[String] = if (defaultValueIsSet) Some(_defaultValue) else None
  override def defaultValueOrNull: String = _defaultValue
  override def defaultValueOrThrow: String = if (defaultValueIsSet) _defaultValue else throw new java.lang.NullPointerException("field defaultValue of Field missing")
  override def defaultValueIsSet: Boolean = _defaultValue != null
  override def defaultValueUnset(): Unit = { _defaultValue = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Field missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Field.FIELD_SDESC)
    if (identifierIsSet) {
      oprot.writeFieldBegin(Field.IDENTIFIER_FDESC)
      oprot.writeI16(_identifier)
      oprot.writeFieldEnd()
    }
    if (nameIsSet) {
      oprot.writeFieldBegin(Field.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (typeIdIsSet) {
      oprot.writeFieldBegin(Field.TYPEID_FDESC)
      oprot.writeString(_typeId)
      oprot.writeFieldEnd()
    }
    if (requirednessIsSet) {
      oprot.writeFieldBegin(Field.REQUIREDNESS_FDESC)
      oprot.writeI32(_requiredness.getValue())
      oprot.writeFieldEnd()
    }
    if (defaultValueIsSet) {
      oprot.writeFieldBegin(Field.DEFAULTVALUE_FDESC)
      oprot.writeString(_defaultValue)
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Field.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Field.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // identifier

            if (field_header.`type` == org.apache.thrift.protocol.TType.I16) {
              _identifier = iprot.readI16()

              _identifierIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // typeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _typeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // requiredness

            if (field_header.`type` == org.apache.thrift.protocol.TType.I32 || field_header.`type` == org.apache.thrift.protocol.TType.ENUM) {
              _requiredness = com.twitter.thrift.descriptors.Requiredness.findByIdOrUnknown(iprot.readI32())
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // defaultValue

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _defaultValue = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Field".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Field): Unit = {
    if (that.identifierIsSet && !this.identifierIsSet) {
      this.identifier_=(that.identifierOrDefault)
    }
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.typeIdIsSet && !this.typeIdIsSet) {
      this.typeId_=(that.typeIdOrNull)
    }
    if (that.requirednessIsSet && !this.requirednessIsSet) {
      this.requiredness_=(that.requirednessOrNull)
    }
    if (that.defaultValueIsSet && !this.defaultValueIsSet) {
      this.defaultValue_=(that.defaultValueOrNull)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Field): Field = {
    val ret = Field.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Field => this.equals(o)
    case _ => false
  }

  def equals(that: Field): Boolean = {
    that != null &&
    (if (this.identifierIsSet) (that.identifierIsSet && this.identifierOrDefault == that.identifierOrDefault) else !that.identifierIsSet) &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.typeIdIsSet) (that.typeIdIsSet && this.typeIdOrNull == that.typeIdOrNull) else !that.typeIdIsSet) &&
    (if (this.requirednessIsSet) (that.requirednessIsSet && this.requirednessOrNull == that.requirednessOrNull) else !that.requirednessIsSet) &&
    (if (this.defaultValueIsSet) (that.defaultValueIsSet && this.defaultValueOrNull == that.defaultValueOrNull) else !that.defaultValueIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (identifierIsSet) hasher.append(_identifier.##)
    if (nameIsSet) hasher.append(_name.##)
    if (typeIdIsSet) hasher.append(_typeId.##)
    if (requirednessIsSet) hasher.append(_requiredness.##)
    if (defaultValueIsSet) hasher.append(_defaultValue.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (identifierIsSet) ret = identifierOrDefault :: ret
    if (nameIsSet) ret = nameOrNull :: ret
    if (typeIdIsSet) ret = typeIdOrNull :: ret
    if (requirednessIsSet) ret = requirednessOrNull :: ret
    if (defaultValueIsSet) ret = defaultValueOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    identifierUnset()
    nameUnset()
    typeIdUnset()
    requirednessUnset()
    defaultValueUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Field._Fields = id match {
    case 1 => Field._Fields.identifier
    case 2 => Field._Fields.name
    case 3 => Field._Fields.typeId
    case 4 => Field._Fields.requiredness
    case 5 => Field._Fields.defaultValue
    case 99 => Field._Fields.__annotations
    case _ => null
  }

  def isSet(field: Field._Fields): Boolean = field match {
    case Field._Fields.identifier => identifierIsSet
    case Field._Fields.name => nameIsSet
    case Field._Fields.typeId => typeIdIsSet
    case Field._Fields.requiredness => requirednessIsSet
    case Field._Fields.defaultValue => defaultValueIsSet
    case Field._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Field._Fields): AnyRef = field match {
    case Field._Fields.identifier => identifierOrDefault.asInstanceOf[AnyRef]
    case Field._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Field._Fields.typeId => typeIdOrNull.asInstanceOf[AnyRef]
    case Field._Fields.requiredness => requirednessOrNull.asInstanceOf[AnyRef]
    case Field._Fields.defaultValue => defaultValueOrNull.asInstanceOf[AnyRef]
    case Field._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Field._Fields, value: AnyRef) {
    field match {
      case Field._Fields.identifier => identifier_=(value.asInstanceOf[Short])
      case Field._Fields.name => name_=(value.asInstanceOf[String])
      case Field._Fields.typeId => typeId_=(value.asInstanceOf[String])
      case Field._Fields.requiredness => requiredness_=(value.asInstanceOf[com.twitter.thrift.descriptors.Requiredness])
      case Field._Fields.defaultValue => defaultValue_=(value.asInstanceOf[String])
      case Field._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawField = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Field.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      identifier: java.lang.Short = identifierOrNull,
      name: String = nameOrNull,
      typeId: String = typeIdOrNull,
      requiredness: com.twitter.thrift.descriptors.Requiredness = requirednessOrNull,
      defaultValue: String = defaultValueOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawField = {
    val ret = new RawField
    if (identifier != null) ret.identifier_=(identifier)
    if (name != null) ret.name_=(name)
    if (typeId != null) ret.typeId_=(typeId)
    if (requiredness != null) ret.requiredness_=(requiredness)
    if (defaultValue != null) ret.defaultValue_=(defaultValue)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Struct extends StructMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasFields

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFields
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Struct] (private var obj: RawStruct) {
    def name(v: String): Struct.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Struct.Builder[State with Builder.HasName]]
    }

    def __fields(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Struct.Builder[State with Builder.HasFields] = {
      obj.__fields_=(v)
      this.asInstanceOf[Struct.Builder[State with Builder.HasFields]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Struct.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Struct.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): MutableStruct = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Struct.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Struct = resultMutable()(ev0, ev1)
  }

  def newBuilder: Struct.Builder.AllUnspecified = new Builder(Struct.createRawRecord)

  implicit val companionProvider: StructCompanionProvider = new StructCompanionProvider
}

class StructMeta
    extends JavaStructMeta[Struct, RawStruct, StructMeta]
    with com.foursquare.spindle.RecordProvider[Struct] {
  override def recordName: String = "Struct"


  // Thrift descriptors.
  val STRUCT_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Struct")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val FIELDS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "fields",
      org.apache.thrift.protocol.TType.LIST,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "fields" -> FIELDS_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object __fields extends _Fields(2, "fields")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.__fields,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Struct = createRawRecord
  override def createRawRecord: RawStruct = new RawStruct

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Struct] = {
    if (x.isInstanceOf[Struct]) Some(x.asInstanceOf[Struct]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Struct, StructMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Struct], v: String) => { r.asInstanceOf[RawStruct].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Struct]) => { r.asInstanceOf[RawStruct].nameUnset() },
      manifest = manifest[String]
    )

  val __fields =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Struct, StructMeta](
      name = "fields",
      longName = "fields",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.fieldsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Struct], v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.asInstanceOf[RawStruct].__fields_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Struct]) => { r.asInstanceOf[RawStruct].fieldsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Struct, StructMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Struct], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawStruct].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Struct]) => { r.asInstanceOf[RawStruct].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Struct, StructMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Struct, StructMeta]](
      name,
      __fields,
      __annotations
    )


  def apply(
      name: String,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Struct = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.__fields_=(__fields)
    ret.__annotations_=(__annotations)
    ret
  }
}

class StructCompanionProvider extends com.foursquare.spindle.CompanionProvider[Struct] {
  type CompanionT = StructMeta
  override def provide: StructMeta = Struct
}


trait Struct
    extends JavaStruct[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Struct, RawStruct, StructMeta
    ]
    with org.apache.thrift.TBase[Struct, Struct._Fields] {

  override def meta: StructMeta

  override def compare(that: Struct): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.fieldsIsSet.compareTo(that.fieldsIsSet)
      cmp != 0 }) cmp
    else if (this.fieldsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__fields).asJava, scalaj.collection.Implicits.RichSSeq(that.__fields).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Struct): Boolean = { this.compare(that) < 0 }
  override def >(that: Struct): Boolean = { this.compare(that) > 0 }
  override def <=(that: Struct): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Struct): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Struct): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Struct

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct

  def mutableCopy(): MutableStruct = {
    val ret = Struct.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (fieldsIsSet) ret.__fields_=(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableStruct

  def toBuilder(): Struct.Builder.AllSpecified = {
    val ret = new Struct.Builder(Struct.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (fieldsIsSet) ret.__fields(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Struct): Struct

}

trait MutableStruct extends Struct
    with JavaStructMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Struct, RawStruct, StructMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def fieldsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Struct): Unit

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableStruct

  override def mutable: MutableStruct = this
}


trait StructProxy extends Struct {
  protected def underlying: Struct

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.__fields
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.fieldsOption
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrDefault
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrNull
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrThrow
  override def fieldsIsSet: Boolean = underlying.fieldsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Struct): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Struct = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableStruct = underlying.mutableCopy()

  override def mergeCopy(that: Struct): Struct = underlying.mergeCopy(that)

  override def mutable: MutableStruct = underlying.mutable

  override def deepCopy(): Struct = underlying.deepCopy()

  override def fieldForId(id: Int): Struct._Fields = underlying.fieldForId(id)
  override def isSet(field: Struct._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Struct._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Struct._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableStructProxy extends MutableStruct with StructProxy {
  protected def underlying: MutableStruct

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.__fields_=(x) }
  override def fieldsUnset(): Unit = { underlying.fieldsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableStruct = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def merge(that: Struct): Unit = underlying.merge(that)
}


final class RawStruct extends JavaStructRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Struct, RawStruct, StructMeta
    ]
    with MutableStruct {
  override def meta: StructMeta = Struct

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Struct missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - fields
  private var _fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrDefault
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _fields = x }
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (fieldsIsSet) Some(_fields) else None
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else scala.collection.Seq.empty
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _fields
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else throw new java.lang.NullPointerException("field __fields of Struct missing")
  override def fieldsIsSet: Boolean = _fields != null
  override def fieldsUnset(): Unit = { _fields = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Struct missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Struct.STRUCT_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Struct.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (fieldsIsSet) {
      oprot.writeFieldBegin(Struct.FIELDS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _fields.size))
      _fields.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Struct.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Struct.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // fields

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _fields = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Struct".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Struct): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.fieldsIsSet && !this.fieldsIsSet) {
      this.__fields_=(that.fieldsOrNull)

    } else if (that.fieldsIsSet && this.fieldsIsSet) {
      this.__fields_=(this.__fields ++ that.__fields)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Struct): Struct = {
    val ret = Struct.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Struct => this.equals(o)
    case _ => false
  }

  def equals(that: Struct): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.fieldsIsSet) (that.fieldsIsSet && this.fieldsOrNull == that.fieldsOrNull) else !that.fieldsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (fieldsIsSet) hasher.append(_fields.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (fieldsIsSet) ret = fieldsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    fieldsUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Struct._Fields = id match {
    case 1 => Struct._Fields.name
    case 2 => Struct._Fields.__fields
    case 99 => Struct._Fields.__annotations
    case _ => null
  }

  def isSet(field: Struct._Fields): Boolean = field match {
    case Struct._Fields.name => nameIsSet
    case Struct._Fields.__fields => fieldsIsSet
    case Struct._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Struct._Fields): AnyRef = field match {
    case Struct._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Struct._Fields.__fields => fieldsOrNull.asInstanceOf[AnyRef]
    case Struct._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Struct._Fields, value: AnyRef) {
    field match {
      case Struct._Fields.name => name_=(value.asInstanceOf[String])
      case Struct._Fields.__fields => __fields_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Struct._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawStruct = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Struct.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawStruct = {
    val ret = new RawStruct
    if (name != null) ret.name_=(name)
    if (__fields != null) ret.__fields_=(__fields)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Union extends UnionMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasFields

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFields
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Union] (private var obj: RawUnion) {
    def name(v: String): Union.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Union.Builder[State with Builder.HasName]]
    }

    def __fields(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Union.Builder[State with Builder.HasFields] = {
      obj.__fields_=(v)
      this.asInstanceOf[Union.Builder[State with Builder.HasFields]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Union.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Union.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): MutableUnion = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Union.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Union = resultMutable()(ev0, ev1)
  }

  def newBuilder: Union.Builder.AllUnspecified = new Builder(Union.createRawRecord)

  implicit val companionProvider: UnionCompanionProvider = new UnionCompanionProvider
}

class UnionMeta
    extends JavaUnionMeta[Union, RawUnion, UnionMeta]
    with com.foursquare.spindle.RecordProvider[Union] {
  override def recordName: String = "Union"


  // Thrift descriptors.
  val UNION_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Union")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val FIELDS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "fields",
      org.apache.thrift.protocol.TType.LIST,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "fields" -> FIELDS_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object __fields extends _Fields(2, "fields")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.__fields,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Union = createRawRecord
  override def createRawRecord: RawUnion = new RawUnion

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Union] = {
    if (x.isInstanceOf[Union]) Some(x.asInstanceOf[Union]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Union, UnionMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Union], v: String) => { r.asInstanceOf[RawUnion].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Union]) => { r.asInstanceOf[RawUnion].nameUnset() },
      manifest = manifest[String]
    )

  val __fields =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Union, UnionMeta](
      name = "fields",
      longName = "fields",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.fieldsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Union], v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.asInstanceOf[RawUnion].__fields_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Union]) => { r.asInstanceOf[RawUnion].fieldsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Union, UnionMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Union], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawUnion].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Union]) => { r.asInstanceOf[RawUnion].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Union, UnionMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Union, UnionMeta]](
      name,
      __fields,
      __annotations
    )


  def apply(
      name: String,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Union = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.__fields_=(__fields)
    ret.__annotations_=(__annotations)
    ret
  }
}

class UnionCompanionProvider extends com.foursquare.spindle.CompanionProvider[Union] {
  type CompanionT = UnionMeta
  override def provide: UnionMeta = Union
}


trait Union
    extends JavaUnion[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Union, RawUnion, UnionMeta
    ]
    with org.apache.thrift.TBase[Union, Union._Fields] {

  override def meta: UnionMeta

  override def compare(that: Union): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.fieldsIsSet.compareTo(that.fieldsIsSet)
      cmp != 0 }) cmp
    else if (this.fieldsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__fields).asJava, scalaj.collection.Implicits.RichSSeq(that.__fields).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Union): Boolean = { this.compare(that) < 0 }
  override def >(that: Union): Boolean = { this.compare(that) > 0 }
  override def <=(that: Union): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Union): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Union): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Union

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union

  def mutableCopy(): MutableUnion = {
    val ret = Union.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (fieldsIsSet) ret.__fields_=(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableUnion

  def toBuilder(): Union.Builder.AllSpecified = {
    val ret = new Union.Builder(Union.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (fieldsIsSet) ret.__fields(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Union): Union

}

trait MutableUnion extends Union
    with JavaUnionMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Union, RawUnion, UnionMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def fieldsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Union): Unit

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableUnion

  override def mutable: MutableUnion = this
}


trait UnionProxy extends Union {
  protected def underlying: Union

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.__fields
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.fieldsOption
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrDefault
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrNull
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrThrow
  override def fieldsIsSet: Boolean = underlying.fieldsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Union): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Union = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableUnion = underlying.mutableCopy()

  override def mergeCopy(that: Union): Union = underlying.mergeCopy(that)

  override def mutable: MutableUnion = underlying.mutable

  override def deepCopy(): Union = underlying.deepCopy()

  override def fieldForId(id: Int): Union._Fields = underlying.fieldForId(id)
  override def isSet(field: Union._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Union._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Union._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableUnionProxy extends MutableUnion with UnionProxy {
  protected def underlying: MutableUnion

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.__fields_=(x) }
  override def fieldsUnset(): Unit = { underlying.fieldsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableUnion = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def merge(that: Union): Unit = underlying.merge(that)
}


final class RawUnion extends JavaUnionRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Union, RawUnion, UnionMeta
    ]
    with MutableUnion {
  override def meta: UnionMeta = Union

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Union missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - fields
  private var _fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrDefault
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _fields = x }
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (fieldsIsSet) Some(_fields) else None
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else scala.collection.Seq.empty
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _fields
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else throw new java.lang.NullPointerException("field __fields of Union missing")
  override def fieldsIsSet: Boolean = _fields != null
  override def fieldsUnset(): Unit = { _fields = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Union missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Union.UNION_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Union.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (fieldsIsSet) {
      oprot.writeFieldBegin(Union.FIELDS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _fields.size))
      _fields.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Union.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Union.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // fields

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _fields = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Union".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Union): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.fieldsIsSet && !this.fieldsIsSet) {
      this.__fields_=(that.fieldsOrNull)

    } else if (that.fieldsIsSet && this.fieldsIsSet) {
      this.__fields_=(this.__fields ++ that.__fields)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Union): Union = {
    val ret = Union.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Union => this.equals(o)
    case _ => false
  }

  def equals(that: Union): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.fieldsIsSet) (that.fieldsIsSet && this.fieldsOrNull == that.fieldsOrNull) else !that.fieldsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (fieldsIsSet) hasher.append(_fields.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (fieldsIsSet) ret = fieldsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    fieldsUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Union._Fields = id match {
    case 1 => Union._Fields.name
    case 2 => Union._Fields.__fields
    case 99 => Union._Fields.__annotations
    case _ => null
  }

  def isSet(field: Union._Fields): Boolean = field match {
    case Union._Fields.name => nameIsSet
    case Union._Fields.__fields => fieldsIsSet
    case Union._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Union._Fields): AnyRef = field match {
    case Union._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Union._Fields.__fields => fieldsOrNull.asInstanceOf[AnyRef]
    case Union._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Union._Fields, value: AnyRef) {
    field match {
      case Union._Fields.name => name_=(value.asInstanceOf[String])
      case Union._Fields.__fields => __fields_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Union._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawUnion = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Union.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawUnion = {
    val ret = new RawUnion
    if (name != null) ret.name_=(name)
    if (__fields != null) ret.__fields_=(__fields)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Exception extends ExceptionMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasFields

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFields
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Exception] (private var obj: RawException) {
    def name(v: String): Exception.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Exception.Builder[State with Builder.HasName]]
    }

    def __fields(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Exception.Builder[State with Builder.HasFields] = {
      obj.__fields_=(v)
      this.asInstanceOf[Exception.Builder[State with Builder.HasFields]]
    }


    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Exception.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Exception.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): MutableException = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Exception.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFields): Exception = resultMutable()(ev0, ev1)
  }

  def newBuilder: Exception.Builder.AllUnspecified = new Builder(Exception.createRawRecord)

  implicit val companionProvider: ExceptionCompanionProvider = new ExceptionCompanionProvider
}

class ExceptionMeta
    extends JavaExceptionMeta[Exception, RawException, ExceptionMeta]
    with com.foursquare.spindle.RecordProvider[Exception] {
  override def recordName: String = "Exception"


  // Thrift descriptors.
  val EXCEPTION_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Exception")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val FIELDS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "fields",
      org.apache.thrift.protocol.TType.LIST,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "fields" -> FIELDS_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object __fields extends _Fields(2, "fields")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.__fields,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Exception = createRawRecord
  override def createRawRecord: RawException = new RawException

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Exception] = {
    if (x.isInstanceOf[Exception]) Some(x.asInstanceOf[Exception]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Exception, ExceptionMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Exception], v: String) => { r.asInstanceOf[RawException].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Exception]) => { r.asInstanceOf[RawException].nameUnset() },
      manifest = manifest[String]
    )

  val __fields =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Exception, ExceptionMeta](
      name = "fields",
      longName = "fields",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.fieldsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Exception], v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.asInstanceOf[RawException].__fields_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Exception]) => { r.asInstanceOf[RawException].fieldsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Exception, ExceptionMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Exception], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawException].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Exception]) => { r.asInstanceOf[RawException].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Exception, ExceptionMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Exception, ExceptionMeta]](
      name,
      __fields,
      __annotations
    )


  def apply(
      name: String,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Exception = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.__fields_=(__fields)
    ret.__annotations_=(__annotations)
    ret
  }
}

class ExceptionCompanionProvider extends com.foursquare.spindle.CompanionProvider[Exception] {
  type CompanionT = ExceptionMeta
  override def provide: ExceptionMeta = Exception
}


trait Exception
    extends JavaException[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Exception, RawException, ExceptionMeta
    ]
    with org.apache.thrift.TBase[Exception, Exception._Fields] {

  override def meta: ExceptionMeta

  override def compare(that: Exception): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.fieldsIsSet.compareTo(that.fieldsIsSet)
      cmp != 0 }) cmp
    else if (this.fieldsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__fields).asJava, scalaj.collection.Implicits.RichSSeq(that.__fields).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Exception): Boolean = { this.compare(that) < 0 }
  override def >(that: Exception): Boolean = { this.compare(that) > 0 }
  override def <=(that: Exception): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Exception): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Exception): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Exception

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception

  def mutableCopy(): MutableException = {
    val ret = Exception.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (fieldsIsSet) ret.__fields_=(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableException

  def toBuilder(): Exception.Builder.AllSpecified = {
    val ret = new Exception.Builder(Exception.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (fieldsIsSet) ret.__fields(fieldsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Exception): Exception

}

trait MutableException extends Exception
    with JavaExceptionMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Exception, RawException, ExceptionMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def fieldsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Exception): Unit

  def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableException

  override def mutable: MutableException = this
}


trait ExceptionProxy extends Exception {
  protected def underlying: Exception

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_container.ssp
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.__fields
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.fieldsOption
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrDefault
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrNull
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.fieldsOrThrow
  override def fieldsIsSet: Boolean = underlying.fieldsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Exception): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Exception = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableException = underlying.mutableCopy()

  override def mergeCopy(that: Exception): Exception = underlying.mergeCopy(that)

  override def mutable: MutableException = underlying.mutable

  override def deepCopy(): Exception = underlying.deepCopy()

  override def fieldForId(id: Int): Exception._Fields = underlying.fieldForId(id)
  override def isSet(field: Exception._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Exception._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Exception._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableExceptionProxy extends MutableException with ExceptionProxy {
  protected def underlying: MutableException

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.__fields_=(x) }
  override def fieldsUnset(): Unit = { underlying.fieldsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableException = underlying.copy(
    name = name,
    __fields = __fields,
    __annotations = __annotations
  )

  override def merge(that: Exception): Unit = underlying.merge(that)
}


final class RawException extends JavaExceptionRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Exception, RawException, ExceptionMeta
    ]
    with MutableException {
  override def meta: ExceptionMeta = Exception

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Exception missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - fields
  private var _fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrDefault
  override def __fields_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _fields = x }
  override def fieldsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (fieldsIsSet) Some(_fields) else None
  override def fieldsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else scala.collection.Seq.empty
  override def fieldsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _fields
  override def fieldsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (fieldsIsSet) _fields else throw new java.lang.NullPointerException("field __fields of Exception missing")
  override def fieldsIsSet: Boolean = _fields != null
  override def fieldsUnset(): Unit = { _fields = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Exception missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Exception.EXCEPTION_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Exception.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (fieldsIsSet) {
      oprot.writeFieldBegin(Exception.FIELDS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _fields.size))
      _fields.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Exception.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Exception.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // fields

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _fields = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Exception".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Exception): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.fieldsIsSet && !this.fieldsIsSet) {
      this.__fields_=(that.fieldsOrNull)

    } else if (that.fieldsIsSet && this.fieldsIsSet) {
      this.__fields_=(this.__fields ++ that.__fields)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Exception): Exception = {
    val ret = Exception.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Exception => this.equals(o)
    case _ => false
  }

  def equals(that: Exception): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.fieldsIsSet) (that.fieldsIsSet && this.fieldsOrNull == that.fieldsOrNull) else !that.fieldsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (fieldsIsSet) hasher.append(_fields.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (fieldsIsSet) ret = fieldsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    fieldsUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Exception._Fields = id match {
    case 1 => Exception._Fields.name
    case 2 => Exception._Fields.__fields
    case 99 => Exception._Fields.__annotations
    case _ => null
  }

  def isSet(field: Exception._Fields): Boolean = field match {
    case Exception._Fields.name => nameIsSet
    case Exception._Fields.__fields => fieldsIsSet
    case Exception._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Exception._Fields): AnyRef = field match {
    case Exception._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Exception._Fields.__fields => fieldsOrNull.asInstanceOf[AnyRef]
    case Exception._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Exception._Fields, value: AnyRef) {
    field match {
      case Exception._Fields.name => name_=(value.asInstanceOf[String])
      case Exception._Fields.__fields => __fields_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Exception._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawException = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Exception.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      __fields: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = fieldsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawException = {
    val ret = new RawException
    if (name != null) ret.name_=(name)
    if (__fields != null) ret.__fields_=(__fields)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Function extends FunctionMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasArgz
    sealed trait HasThrowz

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasArgz with HasThrowz
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Function] (private var obj: RawFunction) {
    def name(v: String): Function.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Function.Builder[State with Builder.HasName]]
    }

    def argz(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Function.Builder[State with Builder.HasArgz] = {
      obj.argz_=(v)
      this.asInstanceOf[Function.Builder[State with Builder.HasArgz]]
    }

    def throwz(v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Function.Builder[State with Builder.HasThrowz] = {
      obj.throwz_=(v)
      this.asInstanceOf[Function.Builder[State with Builder.HasThrowz]]
    }


    def returnTypeId(v: String): Function.Builder[State] = {
      obj.returnTypeId_=(v)
      this
    }

    def returnTypeId(vOpt: Option[String]): Function.Builder[State] = {
      vOpt match {
        case Some(v) => obj.returnTypeId_=(v)
        case None => obj.returnTypeIdUnset()
      }
      this
    }

    def oneWay(v: Boolean): Function.Builder[State] = {
      obj.oneWay_=(v)
      this
    }

    def oneWay(vOpt: Option[Boolean]): Function.Builder[State] = {
      vOpt match {
        case Some(v) => obj.oneWay_=(v)
        case None => obj.oneWayUnset()
      }
      this
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Function.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Function.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasArgz, ev2: State <:< Builder.HasThrowz): MutableFunction = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Function.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasArgz, ev2: State <:< Builder.HasThrowz): Function = resultMutable()(ev0, ev1, ev2)
  }

  def newBuilder: Function.Builder.AllUnspecified = new Builder(Function.createRawRecord)

  implicit val companionProvider: FunctionCompanionProvider = new FunctionCompanionProvider
}

class FunctionMeta
    extends JavaFunctionMeta[Function, RawFunction, FunctionMeta]
    with com.foursquare.spindle.RecordProvider[Function] {
  override def recordName: String = "Function"


  // Thrift descriptors.
  val FUNCTION_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Function")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val RETURNTYPEID_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "returnTypeId",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ONEWAY_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "oneWay",
      org.apache.thrift.protocol.TType.BOOL,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ARGZ_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "argz",
      org.apache.thrift.protocol.TType.LIST,
      4,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val THROWZ_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "throwz",
      org.apache.thrift.protocol.TType.LIST,
      5,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "returnTypeId" -> RETURNTYPEID_FDESC,
    "oneWay" -> ONEWAY_FDESC,
    "argz" -> ARGZ_FDESC,
    "throwz" -> THROWZ_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object returnTypeId extends _Fields(2, "returnTypeId")
    case object oneWay extends _Fields(3, "oneWay")
    case object argz extends _Fields(4, "argz")
    case object throwz extends _Fields(5, "throwz")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.returnTypeId,
    3.toShort -> _Fields.oneWay,
    4.toShort -> _Fields.argz,
    5.toShort -> _Fields.throwz,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Function = createRawRecord
  override def createRawRecord: RawFunction = new RawFunction

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Function] = {
    if (x.isInstanceOf[Function]) Some(x.asInstanceOf[Function]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Function, FunctionMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Function], v: String) => { r.asInstanceOf[RawFunction].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Function]) => { r.asInstanceOf[RawFunction].nameUnset() },
      manifest = manifest[String]
    )

  val returnTypeId =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Function, FunctionMeta](
      name = "returnTypeId",
      longName = "returnTypeId",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.returnTypeIdOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Function], v: String) => { r.asInstanceOf[RawFunction].returnTypeId_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Function]) => { r.asInstanceOf[RawFunction].returnTypeIdUnset() },
      manifest = manifest[String]
    )

  val oneWay =

    new com.foursquare.spindle.OptionalFieldDescriptor[Boolean, Function, FunctionMeta](
      name = "oneWay",
      longName = "oneWay",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.oneWayOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Function], v: Boolean) => { r.asInstanceOf[RawFunction].oneWay_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Function]) => { r.asInstanceOf[RawFunction].oneWayUnset() },
      manifest = manifest[Boolean]
    )

  val argz =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Function, FunctionMeta](
      name = "argz",
      longName = "argz",
      id = 4,
      annotations = Map(),
      owner = this,
      getter = _.argzOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Function], v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.asInstanceOf[RawFunction].argz_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Function]) => { r.asInstanceOf[RawFunction].argzUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val throwz =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Field], Function, FunctionMeta](
      name = "throwz",
      longName = "throwz",
      id = 5,
      annotations = Map(),
      owner = this,
      getter = _.throwzOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Function], v: scala.collection.Seq[com.twitter.thrift.descriptors.Field]) => { r.asInstanceOf[RawFunction].throwz_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Function]) => { r.asInstanceOf[RawFunction].throwzUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Field]]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Function, FunctionMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Function], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawFunction].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Function]) => { r.asInstanceOf[RawFunction].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Function, FunctionMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Function, FunctionMeta]](
      name,
      returnTypeId,
      oneWay,
      argz,
      throwz,
      __annotations
    )


  def apply(
      name: String,
      returnTypeId: String,
      oneWay: Boolean,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Function = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.returnTypeId_=(returnTypeId)
    ret.oneWay_=(oneWay)
    ret.argz_=(argz)
    ret.throwz_=(throwz)
    ret.__annotations_=(__annotations)
    ret
  }
}

class FunctionCompanionProvider extends com.foursquare.spindle.CompanionProvider[Function] {
  type CompanionT = FunctionMeta
  override def provide: FunctionMeta = Function
}


trait Function
    extends JavaFunction[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Function, RawFunction, FunctionMeta
    ]
    with org.apache.thrift.TBase[Function, Function._Fields] {

  override def meta: FunctionMeta

  override def compare(that: Function): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.returnTypeIdIsSet.compareTo(that.returnTypeIdIsSet)
      cmp != 0 }) cmp
    else if (this.returnTypeIdIsSet && {
      cmp = this.returnTypeIdOrNull.compareTo(that.returnTypeIdOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.oneWayIsSet.compareTo(that.oneWayIsSet)
      cmp != 0 }) cmp
    else if (this.oneWayIsSet && {
      cmp = this.oneWay.compareTo(that.oneWay)

      cmp != 0 }) cmp
    else if ({
      cmp = this.argzIsSet.compareTo(that.argzIsSet)
      cmp != 0 }) cmp
    else if (this.argzIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.argz).asJava, scalaj.collection.Implicits.RichSSeq(that.argz).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.throwzIsSet.compareTo(that.throwzIsSet)
      cmp != 0 }) cmp
    else if (this.throwzIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.throwz).asJava, scalaj.collection.Implicits.RichSSeq(that.throwz).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Function): Boolean = { this.compare(that) < 0 }
  override def >(that: Function): Boolean = { this.compare(that) > 0 }
  override def <=(that: Function): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Function): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Function): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Function

  def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function

  def mutableCopy(): MutableFunction = {
    val ret = Function.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (returnTypeIdIsSet) ret.returnTypeId_=(returnTypeIdOrNull)

    if (oneWayIsSet) ret.oneWay_=(oneWayOrDefault)

    if (argzIsSet) ret.argz_=(argzOrNull)

    if (throwzIsSet) ret.throwz_=(throwzOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableFunction

  def toBuilder(): Function.Builder.AllSpecified = {
    val ret = new Function.Builder(Function.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (returnTypeIdIsSet) ret.returnTypeId(returnTypeIdOrNull)

    if (oneWayIsSet) ret.oneWay(oneWayOrDefault)

    if (argzIsSet) ret.argz(argzOrNull)

    if (throwzIsSet) ret.throwz(throwzOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Function): Function

}

trait MutableFunction extends Function
    with JavaFunctionMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Function, RawFunction, FunctionMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def returnTypeId_=(x: String): Unit
  def returnTypeIdUnset(): Unit
  def oneWay_=(x: Boolean): Unit
  def oneWayUnset(): Unit
  def argz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def argzUnset(): Unit
  def throwz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit
  def throwzUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Function): Unit

  def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableFunction

  override def mutable: MutableFunction = this
}


trait FunctionProxy extends Function {
  protected def underlying: Function

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp
  override def returnTypeIdOption: Option[String] = underlying.returnTypeIdOption
  override def returnTypeIdOrNull: String = underlying.returnTypeIdOrNull
  override def returnTypeIdOrThrow: String = underlying.returnTypeIdOrThrow
  override def returnTypeIdIsSet: Boolean = underlying.returnTypeIdIsSet
// field/proxy_primitive.ssp
  override def oneWay: Boolean = underlying.oneWay
  override def oneWayOption: Option[Boolean] = underlying.oneWayOption
  override def oneWayOrDefault: Boolean = underlying.oneWayOrDefault
  override def oneWayOrNull: java.lang.Boolean = underlying.oneWayOrNull
  override def oneWayOrThrow: Boolean = underlying.oneWayOrThrow
  override def oneWayIsSet: Boolean = underlying.oneWayIsSet
// field/proxy_container.ssp
  override def argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argz
  override def argzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.argzOption
  override def argzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argzOrDefault
  override def argzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argzOrNull
  override def argzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.argzOrThrow
  override def argzIsSet: Boolean = underlying.argzIsSet
// field/proxy_container.ssp
  override def throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwz
  override def throwzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = underlying.throwzOption
  override def throwzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwzOrDefault
  override def throwzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwzOrNull
  override def throwzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = underlying.throwzOrThrow
  override def throwzIsSet: Boolean = underlying.throwzIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Function): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Function = underlying.copy(
    name = name,
    returnTypeId = returnTypeId,
    oneWay = oneWay,
    argz = argz,
    throwz = throwz,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableFunction = underlying.mutableCopy()

  override def mergeCopy(that: Function): Function = underlying.mergeCopy(that)

  override def mutable: MutableFunction = underlying.mutable

  override def deepCopy(): Function = underlying.deepCopy()

  override def fieldForId(id: Int): Function._Fields = underlying.fieldForId(id)
  override def isSet(field: Function._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Function._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Function._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableFunctionProxy extends MutableFunction with FunctionProxy {
  protected def underlying: MutableFunction

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def returnTypeId_=(x: String): Unit = { underlying.returnTypeId_=(x) }
  override def returnTypeIdUnset(): Unit = { underlying.returnTypeIdUnset() }
  override def oneWay_=(x: Boolean): Unit = { underlying.oneWay_=(x) }
  override def oneWayUnset(): Unit = { underlying.oneWayUnset() }
  override def argz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.argz_=(x) }
  override def argzUnset(): Unit = { underlying.argzUnset() }
  override def throwz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { underlying.throwz_=(x) }
  override def throwzUnset(): Unit = { underlying.throwzUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableFunction = underlying.copy(
    name = name,
    returnTypeId = returnTypeId,
    oneWay = oneWay,
    argz = argz,
    throwz = throwz,
    __annotations = __annotations
  )

  override def merge(that: Function): Unit = underlying.merge(that)
}


final class RawFunction extends JavaFunctionRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Field,
      Function, RawFunction, FunctionMeta
    ]
    with MutableFunction {
  override def meta: FunctionMeta = Function

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Function missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - returnTypeId
  private var _returnTypeId: String = null  // Underlying type: String
  override def returnTypeId_=(x: String): Unit = { _returnTypeId = x }
  override def returnTypeIdOption: Option[String] = if (returnTypeIdIsSet) Some(_returnTypeId) else None
  override def returnTypeIdOrNull: String = _returnTypeId
  override def returnTypeIdOrThrow: String = if (returnTypeIdIsSet) _returnTypeId else throw new java.lang.NullPointerException("field returnTypeId of Function missing")
  override def returnTypeIdIsSet: Boolean = _returnTypeId != null
  override def returnTypeIdUnset(): Unit = { _returnTypeId = null }
  // Field #3 - oneWay
  private var _oneWay: Boolean = false  // Underlying type: Boolean
  private var _oneWayIsSet: Boolean = false
  override def oneWay: Boolean = oneWayOrDefault
  override def oneWay_=(x: Boolean): Unit = { _oneWay = x ; _oneWayIsSet = true }
  override def oneWayOption: Option[Boolean] = if (oneWayIsSet) Some(_oneWay) else None
  override def oneWayOrDefault: Boolean = _oneWay
  override def oneWayOrNull: java.lang.Boolean = if (oneWayIsSet) _oneWay else null
  override def oneWayOrThrow: Boolean = if (oneWayIsSet) _oneWay else throw new java.lang.NullPointerException("field oneWay of Function missing")
  override def oneWayIsSet: Boolean = _oneWayIsSet
  override def oneWayUnset(): Unit = { _oneWayIsSet = false; _oneWay = false }
  // Field #4 - argz
  private var _argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrDefault
  override def argz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _argz = x }
  override def argzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (argzIsSet) Some(_argz) else None
  override def argzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (argzIsSet) _argz else scala.collection.Seq.empty
  override def argzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _argz
  override def argzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (argzIsSet) _argz else throw new java.lang.NullPointerException("field argz of Function missing")
  override def argzIsSet: Boolean = _argz != null
  override def argzUnset(): Unit = { _argz = null }
  // Field #5 - throwz
  private var _throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Field]
  override def throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrDefault
  override def throwz_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Field]): Unit = { _throwz = x }
  override def throwzOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Field]] = if (throwzIsSet) Some(_throwz) else None
  override def throwzOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (throwzIsSet) _throwz else scala.collection.Seq.empty
  override def throwzOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = _throwz
  override def throwzOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = if (throwzIsSet) _throwz else throw new java.lang.NullPointerException("field throwz of Function missing")
  override def throwzIsSet: Boolean = _throwz != null
  override def throwzUnset(): Unit = { _throwz = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Function missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Function.FUNCTION_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Function.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (returnTypeIdIsSet) {
      oprot.writeFieldBegin(Function.RETURNTYPEID_FDESC)
      oprot.writeString(_returnTypeId)
      oprot.writeFieldEnd()
    }
    if (oneWayIsSet) {
      oprot.writeFieldBegin(Function.ONEWAY_FDESC)
      oprot.writeBool(_oneWay)
      oprot.writeFieldEnd()
    }
    if (argzIsSet) {
      oprot.writeFieldBegin(Function.ARGZ_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _argz.size))
      _argz.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (throwzIsSet) {
      oprot.writeFieldBegin(Function.THROWZ_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _throwz.size))
      _throwz.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Function.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Function.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // returnTypeId

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _returnTypeId = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // oneWay

            if (field_header.`type` == org.apache.thrift.protocol.TType.BOOL) {
              _oneWay = iprot.readBool()

              _oneWayIsSet = true
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // argz

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _argz = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // throwz

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _throwz = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Field]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Field.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Function".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Function): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.returnTypeIdIsSet && !this.returnTypeIdIsSet) {
      this.returnTypeId_=(that.returnTypeIdOrNull)
    }
    if (that.oneWayIsSet && !this.oneWayIsSet) {
      this.oneWay_=(that.oneWayOrDefault)
    }
    if (that.argzIsSet && !this.argzIsSet) {
      this.argz_=(that.argzOrNull)

    } else if (that.argzIsSet && this.argzIsSet) {
      this.argz_=(this.argz ++ that.argz)
    }
    if (that.throwzIsSet && !this.throwzIsSet) {
      this.throwz_=(that.throwzOrNull)

    } else if (that.throwzIsSet && this.throwzIsSet) {
      this.throwz_=(this.throwz ++ that.throwz)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Function): Function = {
    val ret = Function.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Function => this.equals(o)
    case _ => false
  }

  def equals(that: Function): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.returnTypeIdIsSet) (that.returnTypeIdIsSet && this.returnTypeIdOrNull == that.returnTypeIdOrNull) else !that.returnTypeIdIsSet) &&
    (if (this.oneWayIsSet) (that.oneWayIsSet && this.oneWayOrDefault == that.oneWayOrDefault) else !that.oneWayIsSet) &&
    (if (this.argzIsSet) (that.argzIsSet && this.argzOrNull == that.argzOrNull) else !that.argzIsSet) &&
    (if (this.throwzIsSet) (that.throwzIsSet && this.throwzOrNull == that.throwzOrNull) else !that.throwzIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (returnTypeIdIsSet) hasher.append(_returnTypeId.##)
    if (oneWayIsSet) hasher.append(_oneWay.##)
    if (argzIsSet) hasher.append(_argz.##)
    if (throwzIsSet) hasher.append(_throwz.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (returnTypeIdIsSet) ret = returnTypeIdOrNull :: ret
    if (oneWayIsSet) ret = oneWayOrDefault :: ret
    if (argzIsSet) ret = argzOrNull :: ret
    if (throwzIsSet) ret = throwzOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    returnTypeIdUnset()
    oneWayUnset()
    argzUnset()
    throwzUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Function._Fields = id match {
    case 1 => Function._Fields.name
    case 2 => Function._Fields.returnTypeId
    case 3 => Function._Fields.oneWay
    case 4 => Function._Fields.argz
    case 5 => Function._Fields.throwz
    case 99 => Function._Fields.__annotations
    case _ => null
  }

  def isSet(field: Function._Fields): Boolean = field match {
    case Function._Fields.name => nameIsSet
    case Function._Fields.returnTypeId => returnTypeIdIsSet
    case Function._Fields.oneWay => oneWayIsSet
    case Function._Fields.argz => argzIsSet
    case Function._Fields.throwz => throwzIsSet
    case Function._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Function._Fields): AnyRef = field match {
    case Function._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Function._Fields.returnTypeId => returnTypeIdOrNull.asInstanceOf[AnyRef]
    case Function._Fields.oneWay => oneWayOrDefault.asInstanceOf[AnyRef]
    case Function._Fields.argz => argzOrNull.asInstanceOf[AnyRef]
    case Function._Fields.throwz => throwzOrNull.asInstanceOf[AnyRef]
    case Function._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Function._Fields, value: AnyRef) {
    field match {
      case Function._Fields.name => name_=(value.asInstanceOf[String])
      case Function._Fields.returnTypeId => returnTypeId_=(value.asInstanceOf[String])
      case Function._Fields.oneWay => oneWay_=(value.asInstanceOf[Boolean])
      case Function._Fields.argz => argz_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Function._Fields.throwz => throwz_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Field]])
      case Function._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawFunction = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Function.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      returnTypeId: String = returnTypeIdOrNull,
      oneWay: java.lang.Boolean = oneWayOrNull,
      argz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = argzOrNull,
      throwz: scala.collection.Seq[com.twitter.thrift.descriptors.Field] = throwzOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawFunction = {
    val ret = new RawFunction
    if (name != null) ret.name_=(name)
    if (returnTypeId != null) ret.returnTypeId_=(returnTypeId)
    if (oneWay != null) ret.oneWay_=(oneWay)
    if (argz != null) ret.argz_=(argz)
    if (throwz != null) ret.throwz_=(throwz)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Service extends ServiceMeta {


  object Builder {
    sealed trait HasName
    sealed trait HasFunctions

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasName with HasFunctions
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Service] (private var obj: RawService) {
    def name(v: String): Service.Builder[State with Builder.HasName] = {
      obj.name_=(v)
      this.asInstanceOf[Service.Builder[State with Builder.HasName]]
    }

    def functions(v: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Service.Builder[State with Builder.HasFunctions] = {
      obj.functions_=(v)
      this.asInstanceOf[Service.Builder[State with Builder.HasFunctions]]
    }


    def extendz(v: String): Service.Builder[State] = {
      obj.extendz_=(v)
      this
    }

    def extendz(vOpt: Option[String]): Service.Builder[State] = {
      vOpt match {
        case Some(v) => obj.extendz_=(v)
        case None => obj.extendzUnset()
      }
      this
    }

    def __annotations(v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Service.Builder[State] = {
      obj.__annotations_=(v)
      this
    }

    def __annotations(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]): Service.Builder[State] = {
      vOpt match {
        case Some(v) => obj.__annotations_=(v)
        case None => obj.annotationsUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFunctions): MutableService = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Service.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasName, ev1: State <:< Builder.HasFunctions): Service = resultMutable()(ev0, ev1)
  }

  def newBuilder: Service.Builder.AllUnspecified = new Builder(Service.createRawRecord)

  implicit val companionProvider: ServiceCompanionProvider = new ServiceCompanionProvider
}

class ServiceMeta
    extends JavaServiceMeta[Service, RawService, ServiceMeta]
    with com.foursquare.spindle.RecordProvider[Service] {
  override def recordName: String = "Service"


  // Thrift descriptors.
  val SERVICE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Service")

  val NAME_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "name",
      org.apache.thrift.protocol.TType.STRING,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val EXTENDZ_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "extendz",
      org.apache.thrift.protocol.TType.STRING,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val FUNCTIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "functions",
      org.apache.thrift.protocol.TType.LIST,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ANNOTATIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "annotations",
      org.apache.thrift.protocol.TType.LIST,
      99,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "name" -> NAME_FDESC,
    "extendz" -> EXTENDZ_FDESC,
    "functions" -> FUNCTIONS_FDESC,
    "annotations" -> ANNOTATIONS_FDESC
  )

  object _Fields {
    case object name extends _Fields(1, "name")
    case object extendz extends _Fields(2, "extendz")
    case object functions extends _Fields(3, "functions")
    case object __annotations extends _Fields(99, "annotations")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.name,
    2.toShort -> _Fields.extendz,
    3.toShort -> _Fields.functions,
    99.toShort -> _Fields.__annotations
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Service = createRawRecord
  override def createRawRecord: RawService = new RawService

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Service] = {
    if (x.isInstanceOf[Service]) Some(x.asInstanceOf[Service]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val name =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Service, ServiceMeta](
      name = "name",
      longName = "name",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.nameOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Service], v: String) => { r.asInstanceOf[RawService].name_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Service]) => { r.asInstanceOf[RawService].nameUnset() },
      manifest = manifest[String]
    )

  val extendz =

    new com.foursquare.spindle.OptionalFieldDescriptor[String, Service, ServiceMeta](
      name = "extendz",
      longName = "extendz",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.extendzOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Service], v: String) => { r.asInstanceOf[RawService].extendz_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Service]) => { r.asInstanceOf[RawService].extendzUnset() },
      manifest = manifest[String]
    )

  val functions =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Function], Service, ServiceMeta](
      name = "functions",
      longName = "functions",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.functionsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Service], v: scala.collection.Seq[com.twitter.thrift.descriptors.Function]) => { r.asInstanceOf[RawService].functions_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Service]) => { r.asInstanceOf[RawService].functionsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Function]]
    )

  val __annotations =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation], Service, ServiceMeta](
      name = "annotations",
      longName = "annotations",
      id = 99,
      annotations = Map(),
      owner = this,
      getter = _.annotationsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Service], v: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]) => { r.asInstanceOf[RawService].__annotations_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Service]) => { r.asInstanceOf[RawService].annotationsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Service, ServiceMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Service, ServiceMeta]](
      name,
      extendz,
      functions,
      __annotations
    )


  def apply(
      name: String,
      extendz: String,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function],
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  ): Service = {
    val ret = this.createRawRecord
    ret.name_=(name)
    ret.extendz_=(extendz)
    ret.functions_=(functions)
    ret.__annotations_=(__annotations)
    ret
  }
}

class ServiceCompanionProvider extends com.foursquare.spindle.CompanionProvider[Service] {
  type CompanionT = ServiceMeta
  override def provide: ServiceMeta = Service
}


trait Service
    extends JavaService[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Function,
      Service, RawService, ServiceMeta
    ]
    with org.apache.thrift.TBase[Service, Service._Fields] {

  override def meta: ServiceMeta

  override def compare(that: Service): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.nameIsSet.compareTo(that.nameIsSet)
      cmp != 0 }) cmp
    else if (this.nameIsSet && {
      cmp = this.nameOrNull.compareTo(that.nameOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.extendzIsSet.compareTo(that.extendzIsSet)
      cmp != 0 }) cmp
    else if (this.extendzIsSet && {
      cmp = this.extendzOrNull.compareTo(that.extendzOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.functionsIsSet.compareTo(that.functionsIsSet)
      cmp != 0 }) cmp
    else if (this.functionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.functions).asJava, scalaj.collection.Implicits.RichSSeq(that.functions).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.annotationsIsSet.compareTo(that.annotationsIsSet)
      cmp != 0 }) cmp
    else if (this.annotationsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.__annotations).asJava, scalaj.collection.Implicits.RichSSeq(that.__annotations).asJava)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Service): Boolean = { this.compare(that) < 0 }
  override def >(that: Service): Boolean = { this.compare(that) > 0 }
  override def <=(that: Service): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Service): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Service): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Service

  def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service

  def mutableCopy(): MutableService = {
    val ret = Service.createRawRecord

    if (nameIsSet) ret.name_=(nameOrNull)

    if (extendzIsSet) ret.extendz_=(extendzOrNull)

    if (functionsIsSet) ret.functions_=(functionsOrNull)

    if (annotationsIsSet) ret.__annotations_=(annotationsOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableService

  def toBuilder(): Service.Builder.AllSpecified = {
    val ret = new Service.Builder(Service.createRawRecord)

    if (nameIsSet) ret.name(nameOrNull)

    if (extendzIsSet) ret.extendz(extendzOrNull)

    if (functionsIsSet) ret.functions(functionsOrNull)

    if (annotationsIsSet) ret.__annotations(annotationsOrNull)
    ret
  }

  def mergeCopy(that: Service): Service

}

trait MutableService extends Service
    with JavaServiceMutable[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Function,
      Service, RawService, ServiceMeta
    ] {
  def name_=(x: String): Unit
  def nameUnset(): Unit
  def extendz_=(x: String): Unit
  def extendzUnset(): Unit
  def functions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Unit
  def functionsUnset(): Unit
  def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit
  def annotationsUnset(): Unit

  def merge(that: Service): Unit

  def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableService

  override def mutable: MutableService = this
}


trait ServiceProxy extends Service {
  protected def underlying: Service

  override def meta = underlying.meta

// field/proxy_ref.ssp

  override def name: String = underlying.name
  override def nameOption: Option[String] = underlying.nameOption
  override def nameOrNull: String = underlying.nameOrNull
  override def nameOrThrow: String = underlying.nameOrThrow
  override def nameIsSet: Boolean = underlying.nameIsSet
// field/proxy_ref.ssp
  override def extendzOption: Option[String] = underlying.extendzOption
  override def extendzOrNull: String = underlying.extendzOrNull
  override def extendzOrThrow: String = underlying.extendzOrThrow
  override def extendzIsSet: Boolean = underlying.extendzIsSet
// field/proxy_container.ssp
  override def functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functions
  override def functionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Function]] = underlying.functionsOption
  override def functionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functionsOrDefault
  override def functionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functionsOrNull
  override def functionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = underlying.functionsOrThrow
  override def functionsIsSet: Boolean = underlying.functionsIsSet
// field/proxy_container.ssp
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.__annotations
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = underlying.annotationsOption
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrDefault
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrNull
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = underlying.annotationsOrThrow
  override def annotationsIsSet: Boolean = underlying.annotationsIsSet

  override def compare(that: Service): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): Service = underlying.copy(
    name = name,
    extendz = extendz,
    functions = functions,
    __annotations = __annotations
  )

  override def mutableCopy(): MutableService = underlying.mutableCopy()

  override def mergeCopy(that: Service): Service = underlying.mergeCopy(that)

  override def mutable: MutableService = underlying.mutable

  override def deepCopy(): Service = underlying.deepCopy()

  override def fieldForId(id: Int): Service._Fields = underlying.fieldForId(id)
  override def isSet(field: Service._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Service._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Service._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableServiceProxy extends MutableService with ServiceProxy {
  protected def underlying: MutableService

  override def name_=(x: String): Unit = { underlying.name_=(x) }
  override def nameUnset(): Unit = { underlying.nameUnset() }
  override def extendz_=(x: String): Unit = { underlying.extendz_=(x) }
  override def extendzUnset(): Unit = { underlying.extendzUnset() }
  override def functions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Unit = { underlying.functions_=(x) }
  override def functionsUnset(): Unit = { underlying.functionsUnset() }
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { underlying.__annotations_=(x) }
  override def annotationsUnset(): Unit = { underlying.annotationsUnset() }

  override def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): MutableService = underlying.copy(
    name = name,
    extendz = extendz,
    functions = functions,
    __annotations = __annotations
  )

  override def merge(that: Service): Unit = underlying.merge(that)
}


final class RawService extends JavaServiceRaw[com.twitter.thrift.descriptors.Annotation, com.twitter.thrift.descriptors.Function,
      Service, RawService, ServiceMeta
    ]
    with MutableService {
  override def meta: ServiceMeta = Service

  // fields
  // Field #1 - name
  private var _name: String = null  // Underlying type: String
  override def name: String = nameOrThrow
  override def name_=(x: String): Unit = { _name = x }
  override def nameOption: Option[String] = if (nameIsSet) Some(_name) else None
  override def nameOrNull: String = _name
  override def nameOrThrow: String = if (nameIsSet) _name else throw new java.lang.NullPointerException("field name of Service missing")
  override def nameIsSet: Boolean = _name != null
  override def nameUnset(): Unit = { _name = null }
  // Field #2 - extendz
  private var _extendz: String = null  // Underlying type: String
  override def extendz_=(x: String): Unit = { _extendz = x }
  override def extendzOption: Option[String] = if (extendzIsSet) Some(_extendz) else None
  override def extendzOrNull: String = _extendz
  override def extendzOrThrow: String = if (extendzIsSet) _extendz else throw new java.lang.NullPointerException("field extendz of Service missing")
  override def extendzIsSet: Boolean = _extendz != null
  override def extendzUnset(): Unit = { _extendz = null }
  // Field #3 - functions
  private var _functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Function]
  override def functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrDefault
  override def functions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Function]): Unit = { _functions = x }
  override def functionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Function]] = if (functionsIsSet) Some(_functions) else None
  override def functionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = if (functionsIsSet) _functions else scala.collection.Seq.empty
  override def functionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = _functions
  override def functionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = if (functionsIsSet) _functions else throw new java.lang.NullPointerException("field functions of Service missing")
  override def functionsIsSet: Boolean = _functions != null
  override def functionsUnset(): Unit = { _functions = null }
  // Field #99 - annotations
  private var _annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]
  override def __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrDefault
  override def __annotations_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]): Unit = { _annotations = x }
  override def annotationsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]] = if (annotationsIsSet) Some(_annotations) else None
  override def annotationsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else scala.collection.Seq.empty
  override def annotationsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = _annotations
  override def annotationsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = if (annotationsIsSet) _annotations else throw new java.lang.NullPointerException("field __annotations of Service missing")
  override def annotationsIsSet: Boolean = _annotations != null
  override def annotationsUnset(): Unit = { _annotations = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Service.SERVICE_SDESC)
    if (nameIsSet) {
      oprot.writeFieldBegin(Service.NAME_FDESC)
      oprot.writeString(_name)
      oprot.writeFieldEnd()
    }
    if (extendzIsSet) {
      oprot.writeFieldBegin(Service.EXTENDZ_FDESC)
      oprot.writeString(_extendz)
      oprot.writeFieldEnd()
    }
    if (functionsIsSet) {
      oprot.writeFieldBegin(Service.FUNCTIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _functions.size))
      _functions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (annotationsIsSet) {
      oprot.writeFieldBegin(Service.ANNOTATIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _annotations.size))
      _annotations.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Service.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // name

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _name = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // extendz

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRING) {
              _extendz = iprot.readString()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // functions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _functions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Function]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Function.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 99 => {  // annotations

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _annotations = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Annotation]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Annotation.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Service".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Service): Unit = {
    if (that.nameIsSet && !this.nameIsSet) {
      this.name_=(that.nameOrNull)
    }
    if (that.extendzIsSet && !this.extendzIsSet) {
      this.extendz_=(that.extendzOrNull)
    }
    if (that.functionsIsSet && !this.functionsIsSet) {
      this.functions_=(that.functionsOrNull)

    } else if (that.functionsIsSet && this.functionsIsSet) {
      this.functions_=(this.functions ++ that.functions)
    }
    if (that.annotationsIsSet && !this.annotationsIsSet) {
      this.__annotations_=(that.annotationsOrDefault)

    } else if (that.annotationsIsSet && this.annotationsIsSet) {
      this.__annotations_=(this.__annotations ++ that.__annotations)
    }
  }

  override def mergeCopy(that: Service): Service = {
    val ret = Service.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Service => this.equals(o)
    case _ => false
  }

  def equals(that: Service): Boolean = {
    that != null &&
    (if (this.nameIsSet) (that.nameIsSet && this.nameOrNull == that.nameOrNull) else !that.nameIsSet) &&
    (if (this.extendzIsSet) (that.extendzIsSet && this.extendzOrNull == that.extendzOrNull) else !that.extendzIsSet) &&
    (if (this.functionsIsSet) (that.functionsIsSet && this.functionsOrNull == that.functionsOrNull) else !that.functionsIsSet) &&
    (if (this.annotationsIsSet) (that.annotationsIsSet && this.annotationsOrDefault == that.annotationsOrDefault) else !that.annotationsIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (nameIsSet) hasher.append(_name.##)
    if (extendzIsSet) hasher.append(_extendz.##)
    if (functionsIsSet) hasher.append(_functions.##)
    if (annotationsIsSet) hasher.append(_annotations.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (nameIsSet) ret = nameOrNull :: ret
    if (extendzIsSet) ret = extendzOrNull :: ret
    if (functionsIsSet) ret = functionsOrNull :: ret
    if (annotationsIsSet) ret = annotationsOrDefault :: ret
    ret.reverse
  }

  override def clear() {
    nameUnset()
    extendzUnset()
    functionsUnset()
    annotationsUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Service._Fields = id match {
    case 1 => Service._Fields.name
    case 2 => Service._Fields.extendz
    case 3 => Service._Fields.functions
    case 99 => Service._Fields.__annotations
    case _ => null
  }

  def isSet(field: Service._Fields): Boolean = field match {
    case Service._Fields.name => nameIsSet
    case Service._Fields.extendz => extendzIsSet
    case Service._Fields.functions => functionsIsSet
    case Service._Fields.__annotations => annotationsIsSet
    case _ => false
  }

  def getFieldValue(field: Service._Fields): AnyRef = field match {
    case Service._Fields.name => nameOrNull.asInstanceOf[AnyRef]
    case Service._Fields.extendz => extendzOrNull.asInstanceOf[AnyRef]
    case Service._Fields.functions => functionsOrNull.asInstanceOf[AnyRef]
    case Service._Fields.__annotations => annotationsOrDefault.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Service._Fields, value: AnyRef) {
    field match {
      case Service._Fields.name => name_=(value.asInstanceOf[String])
      case Service._Fields.extendz => extendz_=(value.asInstanceOf[String])
      case Service._Fields.functions => functions_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Function]])
      case Service._Fields.__annotations => __annotations_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Annotation]])
      case _ =>
    }
  }

  override def deepCopy(): RawService = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Service.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      name: String = nameOrNull,
      extendz: String = extendzOrNull,
      functions: scala.collection.Seq[com.twitter.thrift.descriptors.Function] = functionsOrNull,
      __annotations: scala.collection.Seq[com.twitter.thrift.descriptors.Annotation] = annotationsOrNull
  ): RawService = {
    val ret = new RawService
    if (name != null) ret.name_=(name)
    if (extendz != null) ret.extendz_=(extendz)
    if (functions != null) ret.functions_=(functions)
    if (__annotations != null) ret.__annotations_=(__annotations)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


object Program extends ProgramMeta {


  object Builder {
    sealed trait HasTypeRegistry

    sealed trait MaybeSpecified
    sealed class Specified extends MaybeSpecified
    sealed class Unspecified extends MaybeSpecified

    type HasAll = HasTypeRegistry
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[Program] (private var obj: RawProgram) {
    def typeRegistry(v: com.twitter.thrift.descriptors.TypeRegistry): Program.Builder[State with Builder.HasTypeRegistry] = {
      obj.typeRegistry_=(v)
      this.asInstanceOf[Program.Builder[State with Builder.HasTypeRegistry]]
    }


    def namespaces(v: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Program.Builder[State] = {
      obj.namespaces_=(v)
      this
    }

    def namespaces(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.namespaces_=(v)
        case None => obj.namespacesUnset()
      }
      this
    }

    def includes(v: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Program.Builder[State] = {
      obj.includes_=(v)
      this
    }

    def includes(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.includes_=(v)
        case None => obj.includesUnset()
      }
      this
    }

    def constants(v: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Program.Builder[State] = {
      obj.constants_=(v)
      this
    }

    def constants(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.constants_=(v)
        case None => obj.constantsUnset()
      }
      this
    }

    def enums(v: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Program.Builder[State] = {
      obj.enums_=(v)
      this
    }

    def enums(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.enums_=(v)
        case None => obj.enumsUnset()
      }
      this
    }

    def typedefs(v: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Program.Builder[State] = {
      obj.typedefs_=(v)
      this
    }

    def typedefs(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.typedefs_=(v)
        case None => obj.typedefsUnset()
      }
      this
    }

    def structs(v: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Program.Builder[State] = {
      obj.structs_=(v)
      this
    }

    def structs(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.structs_=(v)
        case None => obj.structsUnset()
      }
      this
    }

    def unions(v: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Program.Builder[State] = {
      obj.unions_=(v)
      this
    }

    def unions(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.unions_=(v)
        case None => obj.unionsUnset()
      }
      this
    }

    def exceptions(v: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Program.Builder[State] = {
      obj.exceptions_=(v)
      this
    }

    def exceptions(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.exceptions_=(v)
        case None => obj.exceptionsUnset()
      }
      this
    }

    def services(v: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Program.Builder[State] = {
      obj.services_=(v)
      this
    }

    def services(vOpt: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]]): Program.Builder[State] = {
      vOpt match {
        case Some(v) => obj.services_=(v)
        case None => obj.servicesUnset()
      }
      this
    }

    def resultMutable()(implicit ev0: State <:< Builder.HasTypeRegistry): MutableProgram = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("Program.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result()(implicit ev0: State <:< Builder.HasTypeRegistry): Program = resultMutable()(ev0)
  }

  def newBuilder: Program.Builder.AllUnspecified = new Builder(Program.createRawRecord)

  implicit val companionProvider: ProgramCompanionProvider = new ProgramCompanionProvider
}

class ProgramMeta
    extends JavaProgramMeta[Program, RawProgram, ProgramMeta]
    with com.foursquare.spindle.RecordProvider[Program] {
  override def recordName: String = "Program"


  // Thrift descriptors.
  val PROGRAM_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("Program")

  val NAMESPACES_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "namespaces",
      org.apache.thrift.protocol.TType.LIST,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val INCLUDES_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "includes",
      org.apache.thrift.protocol.TType.LIST,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val CONSTANTS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "constants",
      org.apache.thrift.protocol.TType.LIST,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val ENUMS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "enums",
      org.apache.thrift.protocol.TType.LIST,
      4,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEDEFS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typedefs",
      org.apache.thrift.protocol.TType.LIST,
      5,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val STRUCTS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "structs",
      org.apache.thrift.protocol.TType.LIST,
      6,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val UNIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "unions",
      org.apache.thrift.protocol.TType.LIST,
      7,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val EXCEPTIONS_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "exceptions",
      org.apache.thrift.protocol.TType.LIST,
      8,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val SERVICES_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "services",
      org.apache.thrift.protocol.TType.LIST,
      9,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEREGISTRY_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeRegistry",
      org.apache.thrift.protocol.TType.STRUCT,
      98,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "namespaces" -> NAMESPACES_FDESC,
    "includes" -> INCLUDES_FDESC,
    "constants" -> CONSTANTS_FDESC,
    "enums" -> ENUMS_FDESC,
    "typedefs" -> TYPEDEFS_FDESC,
    "structs" -> STRUCTS_FDESC,
    "unions" -> UNIONS_FDESC,
    "exceptions" -> EXCEPTIONS_FDESC,
    "services" -> SERVICES_FDESC,
    "typeRegistry" -> TYPEREGISTRY_FDESC
  )

  object _Fields {
    case object namespaces extends _Fields(1, "namespaces")
    case object includes extends _Fields(2, "includes")
    case object constants extends _Fields(3, "constants")
    case object enums extends _Fields(4, "enums")
    case object typedefs extends _Fields(5, "typedefs")
    case object structs extends _Fields(6, "structs")
    case object unions extends _Fields(7, "unions")
    case object exceptions extends _Fields(8, "exceptions")
    case object services extends _Fields(9, "services")
    case object typeRegistry extends _Fields(98, "typeRegistry")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.namespaces,
    2.toShort -> _Fields.includes,
    3.toShort -> _Fields.constants,
    4.toShort -> _Fields.enums,
    5.toShort -> _Fields.typedefs,
    6.toShort -> _Fields.structs,
    7.toShort -> _Fields.unions,
    8.toShort -> _Fields.exceptions,
    9.toShort -> _Fields.services,
    98.toShort -> _Fields.typeRegistry
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: Program = createRawRecord
  override def createRawRecord: RawProgram = new RawProgram

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[Program] = {
    if (x.isInstanceOf[Program]) Some(x.asInstanceOf[Program]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    new com.foursquare.spindle.Annotations(scala.collection.immutable.Vector(
      ("generate_proxy", "true")
    ))

  // Spindle Descriptors.


  val namespaces =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace], Program, ProgramMeta](
      name = "namespaces",
      longName = "namespaces",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.namespacesOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]) => { r.asInstanceOf[RawProgram].namespaces_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].namespacesUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]]
    )

  val includes =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Include], Program, ProgramMeta](
      name = "includes",
      longName = "includes",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.includesOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Include]) => { r.asInstanceOf[RawProgram].includes_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].includesUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Include]]
    )

  val constants =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Const], Program, ProgramMeta](
      name = "constants",
      longName = "constants",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.constantsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Const]) => { r.asInstanceOf[RawProgram].constants_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].constantsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Const]]
    )

  val enums =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Enum], Program, ProgramMeta](
      name = "enums",
      longName = "enums",
      id = 4,
      annotations = Map(),
      owner = this,
      getter = _.enumsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]) => { r.asInstanceOf[RawProgram].enums_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].enumsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]]
    )

  val typedefs =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef], Program, ProgramMeta](
      name = "typedefs",
      longName = "typedefs",
      id = 5,
      annotations = Map(),
      owner = this,
      getter = _.typedefsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]) => { r.asInstanceOf[RawProgram].typedefs_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].typedefsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]]
    )

  val structs =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Struct], Program, ProgramMeta](
      name = "structs",
      longName = "structs",
      id = 6,
      annotations = Map(),
      owner = this,
      getter = _.structsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]) => { r.asInstanceOf[RawProgram].structs_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].structsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]]
    )

  val unions =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Union], Program, ProgramMeta](
      name = "unions",
      longName = "unions",
      id = 7,
      annotations = Map(),
      owner = this,
      getter = _.unionsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Union]) => { r.asInstanceOf[RawProgram].unions_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].unionsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Union]]
    )

  val exceptions =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Exception], Program, ProgramMeta](
      name = "exceptions",
      longName = "exceptions",
      id = 8,
      annotations = Map(),
      owner = this,
      getter = _.exceptionsOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]) => { r.asInstanceOf[RawProgram].exceptions_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].exceptionsUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]]
    )

  val services =

    new com.foursquare.spindle.OptionalFieldDescriptor[scala.collection.Seq[com.twitter.thrift.descriptors.Service], Program, ProgramMeta](
      name = "services",
      longName = "services",
      id = 9,
      annotations = Map(),
      owner = this,
      getter = _.servicesOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: scala.collection.Seq[com.twitter.thrift.descriptors.Service]) => { r.asInstanceOf[RawProgram].services_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].servicesUnset() },
      manifest = manifest[scala.collection.Seq[com.twitter.thrift.descriptors.Service]]
    )

  val typeRegistry =
    new com.foursquare.spindle.StructFieldDescriptor[Program, ProgramMeta, com.twitter.thrift.descriptors.TypeRegistry, com.twitter.thrift.descriptors.TypeRegistryMeta](
      name = "typeRegistry",
      longName = "typeRegistry",
      id = 98,
      annotations = Map(),
      owner = this,
      getter = _.typeRegistryOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[Program], v: com.twitter.thrift.descriptors.TypeRegistry) => { r.asInstanceOf[RawProgram].typeRegistry_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[Program]) => { r.asInstanceOf[RawProgram].typeRegistryUnset() },
      structMeta = com.twitter.thrift.descriptors.TypeRegistry,
      manifest = manifest[com.twitter.thrift.descriptors.TypeRegistry]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, Program, ProgramMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, Program, ProgramMeta]](
      namespaces,
      includes,
      constants,
      enums,
      typedefs,
      structs,
      unions,
      exceptions,
      services,
      typeRegistry
    )


  def apply(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace],
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include],
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const],
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum],
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef],
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct],
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union],
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception],
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service],
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry
  ): Program = {
    val ret = this.createRawRecord
    ret.namespaces_=(namespaces)
    ret.includes_=(includes)
    ret.constants_=(constants)
    ret.enums_=(enums)
    ret.typedefs_=(typedefs)
    ret.structs_=(structs)
    ret.unions_=(unions)
    ret.exceptions_=(exceptions)
    ret.services_=(services)
    ret.typeRegistry_=(typeRegistry)
    ret
  }
}

class ProgramCompanionProvider extends com.foursquare.spindle.CompanionProvider[Program] {
  type CompanionT = ProgramMeta
  override def provide: ProgramMeta = Program
}


trait Program
    extends JavaProgram[com.twitter.thrift.descriptors.Const, com.twitter.thrift.descriptors.Enum, com.twitter.thrift.descriptors.Exception, com.twitter.thrift.descriptors.Include, com.twitter.thrift.descriptors.Namespace, com.twitter.thrift.descriptors.Service, com.twitter.thrift.descriptors.Struct, com.twitter.thrift.descriptors.TypeRegistry, com.twitter.thrift.descriptors.Typedef, com.twitter.thrift.descriptors.Union,
      Program, RawProgram, ProgramMeta
    ]
    with org.apache.thrift.TBase[Program, Program._Fields] {

  override def meta: ProgramMeta

  override def compare(that: Program): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.namespacesIsSet.compareTo(that.namespacesIsSet)
      cmp != 0 }) cmp
    else if (this.namespacesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.namespaces).asJava, scalaj.collection.Implicits.RichSSeq(that.namespaces).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.includesIsSet.compareTo(that.includesIsSet)
      cmp != 0 }) cmp
    else if (this.includesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.includes).asJava, scalaj.collection.Implicits.RichSSeq(that.includes).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.constantsIsSet.compareTo(that.constantsIsSet)
      cmp != 0 }) cmp
    else if (this.constantsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.constants).asJava, scalaj.collection.Implicits.RichSSeq(that.constants).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.enumsIsSet.compareTo(that.enumsIsSet)
      cmp != 0 }) cmp
    else if (this.enumsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.enums).asJava, scalaj.collection.Implicits.RichSSeq(that.enums).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typedefsIsSet.compareTo(that.typedefsIsSet)
      cmp != 0 }) cmp
    else if (this.typedefsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.typedefs).asJava, scalaj.collection.Implicits.RichSSeq(that.typedefs).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.structsIsSet.compareTo(that.structsIsSet)
      cmp != 0 }) cmp
    else if (this.structsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.structs).asJava, scalaj.collection.Implicits.RichSSeq(that.structs).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.unionsIsSet.compareTo(that.unionsIsSet)
      cmp != 0 }) cmp
    else if (this.unionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.unions).asJava, scalaj.collection.Implicits.RichSSeq(that.unions).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.exceptionsIsSet.compareTo(that.exceptionsIsSet)
      cmp != 0 }) cmp
    else if (this.exceptionsIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.exceptions).asJava, scalaj.collection.Implicits.RichSSeq(that.exceptions).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.servicesIsSet.compareTo(that.servicesIsSet)
      cmp != 0 }) cmp
    else if (this.servicesIsSet && {
      cmp = org.apache.thrift.TBaseHelper.compareTo(scalaj.collection.Implicits.RichSSeq(this.services).asJava, scalaj.collection.Implicits.RichSSeq(that.services).asJava)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typeRegistryIsSet.compareTo(that.typeRegistryIsSet)
      cmp != 0 }) cmp
    else if (this.typeRegistryIsSet && {
      cmp = this.typeRegistryOrNull.compareTo(that.typeRegistryOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: Program): Boolean = { this.compare(that) < 0 }
  override def >(that: Program): Boolean = { this.compare(that) > 0 }
  override def <=(that: Program): Boolean = { this.compare(that) <= 0 }
  override def >=(that: Program): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: Program): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): Program

  def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program

  def mutableCopy(): MutableProgram = {
    val ret = Program.createRawRecord

    if (namespacesIsSet) ret.namespaces_=(namespacesOrNull)

    if (includesIsSet) ret.includes_=(includesOrNull)

    if (constantsIsSet) ret.constants_=(constantsOrNull)

    if (enumsIsSet) ret.enums_=(enumsOrNull)

    if (typedefsIsSet) ret.typedefs_=(typedefsOrNull)

    if (structsIsSet) ret.structs_=(structsOrNull)

    if (unionsIsSet) ret.unions_=(unionsOrNull)

    if (exceptionsIsSet) ret.exceptions_=(exceptionsOrNull)

    if (servicesIsSet) ret.services_=(servicesOrNull)

    if (typeRegistryIsSet) ret.typeRegistry_=(typeRegistryOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableProgram

  def toBuilder(): Program.Builder.AllSpecified = {
    val ret = new Program.Builder(Program.createRawRecord)

    if (namespacesIsSet) ret.namespaces(namespacesOrNull)

    if (includesIsSet) ret.includes(includesOrNull)

    if (constantsIsSet) ret.constants(constantsOrNull)

    if (enumsIsSet) ret.enums(enumsOrNull)

    if (typedefsIsSet) ret.typedefs(typedefsOrNull)

    if (structsIsSet) ret.structs(structsOrNull)

    if (unionsIsSet) ret.unions(unionsOrNull)

    if (exceptionsIsSet) ret.exceptions(exceptionsOrNull)

    if (servicesIsSet) ret.services(servicesOrNull)

    if (typeRegistryIsSet) ret.typeRegistry(typeRegistryOrNull)
    ret
  }

  def mergeCopy(that: Program): Program

}

trait MutableProgram extends Program
    with JavaProgramMutable[com.twitter.thrift.descriptors.Const, com.twitter.thrift.descriptors.Enum, com.twitter.thrift.descriptors.Exception, com.twitter.thrift.descriptors.Include, com.twitter.thrift.descriptors.Namespace, com.twitter.thrift.descriptors.Service, com.twitter.thrift.descriptors.Struct, com.twitter.thrift.descriptors.TypeRegistry, com.twitter.thrift.descriptors.Typedef, com.twitter.thrift.descriptors.Union,
      Program, RawProgram, ProgramMeta
    ] {
  def namespaces_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Unit
  def namespacesUnset(): Unit
  def includes_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Unit
  def includesUnset(): Unit
  def constants_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Unit
  def constantsUnset(): Unit
  def enums_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Unit
  def enumsUnset(): Unit
  def typedefs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Unit
  def typedefsUnset(): Unit
  def structs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Unit
  def structsUnset(): Unit
  def unions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Unit
  def unionsUnset(): Unit
  def exceptions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Unit
  def exceptionsUnset(): Unit
  def services_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Unit
  def servicesUnset(): Unit
  def typeRegistry_=(x: com.twitter.thrift.descriptors.TypeRegistry): Unit
  def typeRegistryUnset(): Unit

  def merge(that: Program): Unit

  def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): MutableProgram

  override def mutable: MutableProgram = this
}


trait ProgramProxy extends Program {
  protected def underlying: Program

  override def meta = underlying.meta

// field/proxy_container.ssp
  override def namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespaces
  override def namespacesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]] = underlying.namespacesOption
  override def namespacesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespacesOrDefault
  override def namespacesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespacesOrNull
  override def namespacesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = underlying.namespacesOrThrow
  override def namespacesIsSet: Boolean = underlying.namespacesIsSet
// field/proxy_container.ssp
  override def includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includes
  override def includesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]] = underlying.includesOption
  override def includesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includesOrDefault
  override def includesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includesOrNull
  override def includesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = underlying.includesOrThrow
  override def includesIsSet: Boolean = underlying.includesIsSet
// field/proxy_container.ssp
  override def constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constants
  override def constantsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]] = underlying.constantsOption
  override def constantsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constantsOrDefault
  override def constantsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constantsOrNull
  override def constantsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = underlying.constantsOrThrow
  override def constantsIsSet: Boolean = underlying.constantsIsSet
// field/proxy_container.ssp
  override def enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enums
  override def enumsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]] = underlying.enumsOption
  override def enumsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enumsOrDefault
  override def enumsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enumsOrNull
  override def enumsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = underlying.enumsOrThrow
  override def enumsIsSet: Boolean = underlying.enumsIsSet
// field/proxy_container.ssp
  override def typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefs
  override def typedefsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]] = underlying.typedefsOption
  override def typedefsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefsOrDefault
  override def typedefsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefsOrNull
  override def typedefsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = underlying.typedefsOrThrow
  override def typedefsIsSet: Boolean = underlying.typedefsIsSet
// field/proxy_container.ssp
  override def structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structs
  override def structsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]] = underlying.structsOption
  override def structsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structsOrDefault
  override def structsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structsOrNull
  override def structsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = underlying.structsOrThrow
  override def structsIsSet: Boolean = underlying.structsIsSet
// field/proxy_container.ssp
  override def unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unions
  override def unionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]] = underlying.unionsOption
  override def unionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unionsOrDefault
  override def unionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unionsOrNull
  override def unionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = underlying.unionsOrThrow
  override def unionsIsSet: Boolean = underlying.unionsIsSet
// field/proxy_container.ssp
  override def exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptions
  override def exceptionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]] = underlying.exceptionsOption
  override def exceptionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptionsOrDefault
  override def exceptionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptionsOrNull
  override def exceptionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = underlying.exceptionsOrThrow
  override def exceptionsIsSet: Boolean = underlying.exceptionsIsSet
// field/proxy_container.ssp
  override def services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.services
  override def servicesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]] = underlying.servicesOption
  override def servicesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.servicesOrDefault
  override def servicesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.servicesOrNull
  override def servicesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = underlying.servicesOrThrow
  override def servicesIsSet: Boolean = underlying.servicesIsSet
// field/proxy_ref.ssp

  override def typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = underlying.typeRegistry
  override def typeRegistryOption: Option[com.twitter.thrift.descriptors.TypeRegistry] = underlying.typeRegistryOption
  override def typeRegistryOrNull: com.twitter.thrift.descriptors.TypeRegistry = underlying.typeRegistryOrNull
  override def typeRegistryOrThrow: com.twitter.thrift.descriptors.TypeRegistry = underlying.typeRegistryOrThrow
  override def typeRegistryIsSet: Boolean = underlying.typeRegistryIsSet

  override def compare(that: Program): Int = underlying.compare(that)

  override def clear() { underlying.clear }
  override def read(iprot: org.apache.thrift.protocol.TProtocol) { underlying.read(iprot) }
  override def write(oprot: org.apache.thrift.protocol.TProtocol) { underlying.write(oprot) }

  override def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): Program = underlying.copy(
    namespaces = namespaces,
    includes = includes,
    constants = constants,
    enums = enums,
    typedefs = typedefs,
    structs = structs,
    unions = unions,
    exceptions = exceptions,
    services = services,
    typeRegistry = typeRegistry
  )

  override def mutableCopy(): MutableProgram = underlying.mutableCopy()

  override def mergeCopy(that: Program): Program = underlying.mergeCopy(that)

  override def mutable: MutableProgram = underlying.mutable

  override def deepCopy(): Program = underlying.deepCopy()

  override def fieldForId(id: Int): Program._Fields = underlying.fieldForId(id)
  override def isSet(field: Program._Fields): Boolean = underlying.isSet(field)
  override def getFieldValue(field: Program._Fields): AnyRef = underlying.getFieldValue(field)
  override def setFieldValue(field: Program._Fields, value: AnyRef) { underlying.setFieldValue(field, value) }

  override def hashCode(): Int = underlying.hashCode
  override def equals(that: Any): Boolean = underlying.equals(that)
  override def toString(): String = underlying.toString
}
trait MutableProgramProxy extends MutableProgram with ProgramProxy {
  protected def underlying: MutableProgram

  override def namespaces_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Unit = { underlying.namespaces_=(x) }
  override def namespacesUnset(): Unit = { underlying.namespacesUnset() }
  override def includes_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Unit = { underlying.includes_=(x) }
  override def includesUnset(): Unit = { underlying.includesUnset() }
  override def constants_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Unit = { underlying.constants_=(x) }
  override def constantsUnset(): Unit = { underlying.constantsUnset() }
  override def enums_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Unit = { underlying.enums_=(x) }
  override def enumsUnset(): Unit = { underlying.enumsUnset() }
  override def typedefs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Unit = { underlying.typedefs_=(x) }
  override def typedefsUnset(): Unit = { underlying.typedefsUnset() }
  override def structs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Unit = { underlying.structs_=(x) }
  override def structsUnset(): Unit = { underlying.structsUnset() }
  override def unions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Unit = { underlying.unions_=(x) }
  override def unionsUnset(): Unit = { underlying.unionsUnset() }
  override def exceptions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Unit = { underlying.exceptions_=(x) }
  override def exceptionsUnset(): Unit = { underlying.exceptionsUnset() }
  override def services_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Unit = { underlying.services_=(x) }
  override def servicesUnset(): Unit = { underlying.servicesUnset() }
  override def typeRegistry_=(x: com.twitter.thrift.descriptors.TypeRegistry): Unit = { underlying.typeRegistry_=(x) }
  override def typeRegistryUnset(): Unit = { underlying.typeRegistryUnset() }

  override def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): MutableProgram = underlying.copy(
    namespaces = namespaces,
    includes = includes,
    constants = constants,
    enums = enums,
    typedefs = typedefs,
    structs = structs,
    unions = unions,
    exceptions = exceptions,
    services = services,
    typeRegistry = typeRegistry
  )

  override def merge(that: Program): Unit = underlying.merge(that)
}


final class RawProgram extends JavaProgramRaw[com.twitter.thrift.descriptors.Const, com.twitter.thrift.descriptors.Enum, com.twitter.thrift.descriptors.Exception, com.twitter.thrift.descriptors.Include, com.twitter.thrift.descriptors.Namespace, com.twitter.thrift.descriptors.Service, com.twitter.thrift.descriptors.Struct, com.twitter.thrift.descriptors.TypeRegistry, com.twitter.thrift.descriptors.Typedef, com.twitter.thrift.descriptors.Union,
      Program, RawProgram, ProgramMeta
    ]
    with MutableProgram {
  override def meta: ProgramMeta = Program

  // fields
  // Field #1 - namespaces
  private var _namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]
  override def namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrDefault
  override def namespaces_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]): Unit = { _namespaces = x }
  override def namespacesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]] = if (namespacesIsSet) Some(_namespaces) else None
  override def namespacesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = if (namespacesIsSet) _namespaces else scala.collection.Seq.empty
  override def namespacesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = _namespaces
  override def namespacesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = if (namespacesIsSet) _namespaces else throw new java.lang.NullPointerException("field namespaces of Program missing")
  override def namespacesIsSet: Boolean = _namespaces != null
  override def namespacesUnset(): Unit = { _namespaces = null }
  // Field #2 - includes
  private var _includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Include]
  override def includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrDefault
  override def includes_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Include]): Unit = { _includes = x }
  override def includesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Include]] = if (includesIsSet) Some(_includes) else None
  override def includesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = if (includesIsSet) _includes else scala.collection.Seq.empty
  override def includesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = _includes
  override def includesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = if (includesIsSet) _includes else throw new java.lang.NullPointerException("field includes of Program missing")
  override def includesIsSet: Boolean = _includes != null
  override def includesUnset(): Unit = { _includes = null }
  // Field #3 - constants
  private var _constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Const]
  override def constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrDefault
  override def constants_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Const]): Unit = { _constants = x }
  override def constantsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Const]] = if (constantsIsSet) Some(_constants) else None
  override def constantsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = if (constantsIsSet) _constants else scala.collection.Seq.empty
  override def constantsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = _constants
  override def constantsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = if (constantsIsSet) _constants else throw new java.lang.NullPointerException("field constants of Program missing")
  override def constantsIsSet: Boolean = _constants != null
  override def constantsUnset(): Unit = { _constants = null }
  // Field #4 - enums
  private var _enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]
  override def enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrDefault
  override def enums_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Enum]): Unit = { _enums = x }
  override def enumsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]] = if (enumsIsSet) Some(_enums) else None
  override def enumsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = if (enumsIsSet) _enums else scala.collection.Seq.empty
  override def enumsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = _enums
  override def enumsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = if (enumsIsSet) _enums else throw new java.lang.NullPointerException("field enums of Program missing")
  override def enumsIsSet: Boolean = _enums != null
  override def enumsUnset(): Unit = { _enums = null }
  // Field #5 - typedefs
  private var _typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]
  override def typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrDefault
  override def typedefs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]): Unit = { _typedefs = x }
  override def typedefsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]] = if (typedefsIsSet) Some(_typedefs) else None
  override def typedefsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = if (typedefsIsSet) _typedefs else scala.collection.Seq.empty
  override def typedefsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = _typedefs
  override def typedefsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = if (typedefsIsSet) _typedefs else throw new java.lang.NullPointerException("field typedefs of Program missing")
  override def typedefsIsSet: Boolean = _typedefs != null
  override def typedefsUnset(): Unit = { _typedefs = null }
  // Field #6 - structs
  private var _structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]
  override def structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrDefault
  override def structs_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Struct]): Unit = { _structs = x }
  override def structsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]] = if (structsIsSet) Some(_structs) else None
  override def structsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = if (structsIsSet) _structs else scala.collection.Seq.empty
  override def structsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = _structs
  override def structsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = if (structsIsSet) _structs else throw new java.lang.NullPointerException("field structs of Program missing")
  override def structsIsSet: Boolean = _structs != null
  override def structsUnset(): Unit = { _structs = null }
  // Field #7 - unions
  private var _unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Union]
  override def unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrDefault
  override def unions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Union]): Unit = { _unions = x }
  override def unionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Union]] = if (unionsIsSet) Some(_unions) else None
  override def unionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = if (unionsIsSet) _unions else scala.collection.Seq.empty
  override def unionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = _unions
  override def unionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = if (unionsIsSet) _unions else throw new java.lang.NullPointerException("field unions of Program missing")
  override def unionsIsSet: Boolean = _unions != null
  override def unionsUnset(): Unit = { _unions = null }
  // Field #8 - exceptions
  private var _exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]
  override def exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrDefault
  override def exceptions_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Exception]): Unit = { _exceptions = x }
  override def exceptionsOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]] = if (exceptionsIsSet) Some(_exceptions) else None
  override def exceptionsOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = if (exceptionsIsSet) _exceptions else scala.collection.Seq.empty
  override def exceptionsOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = _exceptions
  override def exceptionsOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = if (exceptionsIsSet) _exceptions else throw new java.lang.NullPointerException("field exceptions of Program missing")
  override def exceptionsIsSet: Boolean = _exceptions != null
  override def exceptionsUnset(): Unit = { _exceptions = null }
  // Field #9 - services
  private var _services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = null  // Underlying type: scala.collection.Seq[com.twitter.thrift.descriptors.Service]
  override def services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrDefault
  override def services_=(x: scala.collection.Seq[com.twitter.thrift.descriptors.Service]): Unit = { _services = x }
  override def servicesOption: Option[scala.collection.Seq[com.twitter.thrift.descriptors.Service]] = if (servicesIsSet) Some(_services) else None
  override def servicesOrDefault: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = if (servicesIsSet) _services else scala.collection.Seq.empty
  override def servicesOrNull: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = _services
  override def servicesOrThrow: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = if (servicesIsSet) _services else throw new java.lang.NullPointerException("field services of Program missing")
  override def servicesIsSet: Boolean = _services != null
  override def servicesUnset(): Unit = { _services = null }
  // Field #98 - typeRegistry
  private var _typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = null  // Underlying type: com.twitter.thrift.descriptors.TypeRegistry
  override def typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrThrow
  override def typeRegistry_=(x: com.twitter.thrift.descriptors.TypeRegistry): Unit = { _typeRegistry = x }
  override def typeRegistryOption: Option[com.twitter.thrift.descriptors.TypeRegistry] = if (typeRegistryIsSet) Some(_typeRegistry) else None
  override def typeRegistryOrNull: com.twitter.thrift.descriptors.TypeRegistry = _typeRegistry
  override def typeRegistryOrThrow: com.twitter.thrift.descriptors.TypeRegistry = if (typeRegistryIsSet) _typeRegistry else throw new java.lang.NullPointerException("field typeRegistry of Program missing")
  override def typeRegistryIsSet: Boolean = _typeRegistry != null
  override def typeRegistryUnset(): Unit = { _typeRegistry = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(Program.PROGRAM_SDESC)
    if (namespacesIsSet) {
      oprot.writeFieldBegin(Program.NAMESPACES_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _namespaces.size))
      _namespaces.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (includesIsSet) {
      oprot.writeFieldBegin(Program.INCLUDES_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _includes.size))
      _includes.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (constantsIsSet) {
      oprot.writeFieldBegin(Program.CONSTANTS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _constants.size))
      _constants.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (enumsIsSet) {
      oprot.writeFieldBegin(Program.ENUMS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _enums.size))
      _enums.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (typedefsIsSet) {
      oprot.writeFieldBegin(Program.TYPEDEFS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _typedefs.size))
      _typedefs.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (structsIsSet) {
      oprot.writeFieldBegin(Program.STRUCTS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _structs.size))
      _structs.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (unionsIsSet) {
      oprot.writeFieldBegin(Program.UNIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _unions.size))
      _unions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (exceptionsIsSet) {
      oprot.writeFieldBegin(Program.EXCEPTIONS_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _exceptions.size))
      _exceptions.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (servicesIsSet) {
      oprot.writeFieldBegin(Program.SERVICES_FDESC)
      oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, _services.size))
      _services.foreach(element => {
        element.write(oprot)
      })
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    }
    if (typeRegistryIsSet) {
      oprot.writeFieldBegin(Program.TYPEREGISTRY_FDESC)
      _typeRegistry.write(oprot)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        Program.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // namespaces

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _namespaces = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Namespace]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Namespace.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // includes

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _includes = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Include]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Include.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // constants

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _constants = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Const]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Const.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 4 => {  // enums

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _enums = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Enum]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Enum.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 5 => {  // typedefs

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _typedefs = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Typedef]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Typedef.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 6 => {  // structs

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _structs = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Struct]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Struct.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 7 => {  // unions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _unions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Union]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Union.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 8 => {  // exceptions

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _exceptions = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Exception]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Exception.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 9 => {  // services

            if (field_header.`type` == org.apache.thrift.protocol.TType.LIST) {
              _services = {
                val tlist: org.apache.thrift.protocol.TList = iprot.readListBegin()
                val builder = scala.collection.immutable.Vector.newBuilder[com.twitter.thrift.descriptors.Service]
                var i: Int = tlist.size
                builder.sizeHint(tlist.size)
                while (i > 0) {
                  builder += ({
                    val s = com.twitter.thrift.descriptors.Service.createRawRecord
                    s.read(iprot)
                    s
                  })
                  i -= 1
                }
                builder.result()
              }
              iprot.readListEnd()
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 98 => {  // typeRegistry

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _typeRegistry = ({
                val s = com.twitter.thrift.descriptors.TypeRegistry.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure Program".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: Program): Unit = {
    if (that.namespacesIsSet && !this.namespacesIsSet) {
      this.namespaces_=(that.namespacesOrDefault)

    } else if (that.namespacesIsSet && this.namespacesIsSet) {
      this.namespaces_=(this.namespaces ++ that.namespaces)
    }
    if (that.includesIsSet && !this.includesIsSet) {
      this.includes_=(that.includesOrDefault)

    } else if (that.includesIsSet && this.includesIsSet) {
      this.includes_=(this.includes ++ that.includes)
    }
    if (that.constantsIsSet && !this.constantsIsSet) {
      this.constants_=(that.constantsOrDefault)

    } else if (that.constantsIsSet && this.constantsIsSet) {
      this.constants_=(this.constants ++ that.constants)
    }
    if (that.enumsIsSet && !this.enumsIsSet) {
      this.enums_=(that.enumsOrDefault)

    } else if (that.enumsIsSet && this.enumsIsSet) {
      this.enums_=(this.enums ++ that.enums)
    }
    if (that.typedefsIsSet && !this.typedefsIsSet) {
      this.typedefs_=(that.typedefsOrDefault)

    } else if (that.typedefsIsSet && this.typedefsIsSet) {
      this.typedefs_=(this.typedefs ++ that.typedefs)
    }
    if (that.structsIsSet && !this.structsIsSet) {
      this.structs_=(that.structsOrDefault)

    } else if (that.structsIsSet && this.structsIsSet) {
      this.structs_=(this.structs ++ that.structs)
    }
    if (that.unionsIsSet && !this.unionsIsSet) {
      this.unions_=(that.unionsOrDefault)

    } else if (that.unionsIsSet && this.unionsIsSet) {
      this.unions_=(this.unions ++ that.unions)
    }
    if (that.exceptionsIsSet && !this.exceptionsIsSet) {
      this.exceptions_=(that.exceptionsOrDefault)

    } else if (that.exceptionsIsSet && this.exceptionsIsSet) {
      this.exceptions_=(this.exceptions ++ that.exceptions)
    }
    if (that.servicesIsSet && !this.servicesIsSet) {
      this.services_=(that.servicesOrDefault)

    } else if (that.servicesIsSet && this.servicesIsSet) {
      this.services_=(this.services ++ that.services)
    }
    if (that.typeRegistryIsSet && !this.typeRegistryIsSet) {
      this.typeRegistry_=(that.typeRegistryOrNull)
    }
  }

  override def mergeCopy(that: Program): Program = {
    val ret = Program.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: Program => this.equals(o)
    case _ => false
  }

  def equals(that: Program): Boolean = {
    that != null &&
    (if (this.namespacesIsSet) (that.namespacesIsSet && this.namespacesOrDefault == that.namespacesOrDefault) else !that.namespacesIsSet) &&
    (if (this.includesIsSet) (that.includesIsSet && this.includesOrDefault == that.includesOrDefault) else !that.includesIsSet) &&
    (if (this.constantsIsSet) (that.constantsIsSet && this.constantsOrDefault == that.constantsOrDefault) else !that.constantsIsSet) &&
    (if (this.enumsIsSet) (that.enumsIsSet && this.enumsOrDefault == that.enumsOrDefault) else !that.enumsIsSet) &&
    (if (this.typedefsIsSet) (that.typedefsIsSet && this.typedefsOrDefault == that.typedefsOrDefault) else !that.typedefsIsSet) &&
    (if (this.structsIsSet) (that.structsIsSet && this.structsOrDefault == that.structsOrDefault) else !that.structsIsSet) &&
    (if (this.unionsIsSet) (that.unionsIsSet && this.unionsOrDefault == that.unionsOrDefault) else !that.unionsIsSet) &&
    (if (this.exceptionsIsSet) (that.exceptionsIsSet && this.exceptionsOrDefault == that.exceptionsOrDefault) else !that.exceptionsIsSet) &&
    (if (this.servicesIsSet) (that.servicesIsSet && this.servicesOrDefault == that.servicesOrDefault) else !that.servicesIsSet) &&
    (if (this.typeRegistryIsSet) (that.typeRegistryIsSet && this.typeRegistryOrNull == that.typeRegistryOrNull) else !that.typeRegistryIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (namespacesIsSet) hasher.append(_namespaces.##)
    if (includesIsSet) hasher.append(_includes.##)
    if (constantsIsSet) hasher.append(_constants.##)
    if (enumsIsSet) hasher.append(_enums.##)
    if (typedefsIsSet) hasher.append(_typedefs.##)
    if (structsIsSet) hasher.append(_structs.##)
    if (unionsIsSet) hasher.append(_unions.##)
    if (exceptionsIsSet) hasher.append(_exceptions.##)
    if (servicesIsSet) hasher.append(_services.##)
    if (typeRegistryIsSet) hasher.append(_typeRegistry.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (namespacesIsSet) ret = namespacesOrDefault :: ret
    if (includesIsSet) ret = includesOrDefault :: ret
    if (constantsIsSet) ret = constantsOrDefault :: ret
    if (enumsIsSet) ret = enumsOrDefault :: ret
    if (typedefsIsSet) ret = typedefsOrDefault :: ret
    if (structsIsSet) ret = structsOrDefault :: ret
    if (unionsIsSet) ret = unionsOrDefault :: ret
    if (exceptionsIsSet) ret = exceptionsOrDefault :: ret
    if (servicesIsSet) ret = servicesOrDefault :: ret
    if (typeRegistryIsSet) ret = typeRegistryOrNull :: ret
    ret.reverse
  }

  override def clear() {
    namespacesUnset()
    includesUnset()
    constantsUnset()
    enumsUnset()
    typedefsUnset()
    structsUnset()
    unionsUnset()
    exceptionsUnset()
    servicesUnset()
    typeRegistryUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): Program._Fields = id match {
    case 1 => Program._Fields.namespaces
    case 2 => Program._Fields.includes
    case 3 => Program._Fields.constants
    case 4 => Program._Fields.enums
    case 5 => Program._Fields.typedefs
    case 6 => Program._Fields.structs
    case 7 => Program._Fields.unions
    case 8 => Program._Fields.exceptions
    case 9 => Program._Fields.services
    case 98 => Program._Fields.typeRegistry
    case _ => null
  }

  def isSet(field: Program._Fields): Boolean = field match {
    case Program._Fields.namespaces => namespacesIsSet
    case Program._Fields.includes => includesIsSet
    case Program._Fields.constants => constantsIsSet
    case Program._Fields.enums => enumsIsSet
    case Program._Fields.typedefs => typedefsIsSet
    case Program._Fields.structs => structsIsSet
    case Program._Fields.unions => unionsIsSet
    case Program._Fields.exceptions => exceptionsIsSet
    case Program._Fields.services => servicesIsSet
    case Program._Fields.typeRegistry => typeRegistryIsSet
    case _ => false
  }

  def getFieldValue(field: Program._Fields): AnyRef = field match {
    case Program._Fields.namespaces => namespacesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.includes => includesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.constants => constantsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.enums => enumsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.typedefs => typedefsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.structs => structsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.unions => unionsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.exceptions => exceptionsOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.services => servicesOrDefault.asInstanceOf[AnyRef]
    case Program._Fields.typeRegistry => typeRegistryOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: Program._Fields, value: AnyRef) {
    field match {
      case Program._Fields.namespaces => namespaces_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Namespace]])
      case Program._Fields.includes => includes_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Include]])
      case Program._Fields.constants => constants_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Const]])
      case Program._Fields.enums => enums_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Enum]])
      case Program._Fields.typedefs => typedefs_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Typedef]])
      case Program._Fields.structs => structs_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Struct]])
      case Program._Fields.unions => unions_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Union]])
      case Program._Fields.exceptions => exceptions_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Exception]])
      case Program._Fields.services => services_=(value.asInstanceOf[scala.collection.Seq[com.twitter.thrift.descriptors.Service]])
      case Program._Fields.typeRegistry => typeRegistry_=(value.asInstanceOf[com.twitter.thrift.descriptors.TypeRegistry])
      case _ =>
    }
  }

  override def deepCopy(): RawProgram = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = Program.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      namespaces: scala.collection.Seq[com.twitter.thrift.descriptors.Namespace] = namespacesOrNull,
      includes: scala.collection.Seq[com.twitter.thrift.descriptors.Include] = includesOrNull,
      constants: scala.collection.Seq[com.twitter.thrift.descriptors.Const] = constantsOrNull,
      enums: scala.collection.Seq[com.twitter.thrift.descriptors.Enum] = enumsOrNull,
      typedefs: scala.collection.Seq[com.twitter.thrift.descriptors.Typedef] = typedefsOrNull,
      structs: scala.collection.Seq[com.twitter.thrift.descriptors.Struct] = structsOrNull,
      unions: scala.collection.Seq[com.twitter.thrift.descriptors.Union] = unionsOrNull,
      exceptions: scala.collection.Seq[com.twitter.thrift.descriptors.Exception] = exceptionsOrNull,
      services: scala.collection.Seq[com.twitter.thrift.descriptors.Service] = servicesOrNull,
      typeRegistry: com.twitter.thrift.descriptors.TypeRegistry = typeRegistryOrNull
  ): RawProgram = {
    val ret = new RawProgram
    if (namespaces != null) ret.namespaces_=(namespaces)
    if (includes != null) ret.includes_=(includes)
    if (constants != null) ret.constants_=(constants)
    if (enums != null) ret.enums_=(enums)
    if (typedefs != null) ret.typedefs_=(typedefs)
    if (structs != null) ret.structs_=(structs)
    if (unions != null) ret.unions_=(unions)
    if (exceptions != null) ret.exceptions_=(exceptions)
    if (services != null) ret.services_=(services)
    if (typeRegistry != null) ret.typeRegistry_=(typeRegistry)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}




object SimpleContainerType extends SimpleContainerTypeMeta {


  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[SimpleContainerType] (private var obj: RawSimpleContainerType) {

    def listType(v: com.twitter.thrift.descriptors.ListType): SimpleContainerType.Builder[State] = {
      obj.listType_=(v)
      this
    }

    def listType(vOpt: Option[com.twitter.thrift.descriptors.ListType]): SimpleContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.listType_=(v)
        case None => obj.listTypeUnset()
      }
      this
    }

    def setType(v: com.twitter.thrift.descriptors.SetType): SimpleContainerType.Builder[State] = {
      obj.setType_=(v)
      this
    }

    def setType(vOpt: Option[com.twitter.thrift.descriptors.SetType]): SimpleContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.setType_=(v)
        case None => obj.setTypeUnset()
      }
      this
    }

    def mapType(v: com.twitter.thrift.descriptors.MapType): SimpleContainerType.Builder[State] = {
      obj.mapType_=(v)
      this
    }

    def mapType(vOpt: Option[com.twitter.thrift.descriptors.MapType]): SimpleContainerType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.mapType_=(v)
        case None => obj.mapTypeUnset()
      }
      this
    }

    def resultMutable(): MutableSimpleContainerType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("SimpleContainerType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result(): SimpleContainerType = resultMutable()
  }

  def newBuilder: SimpleContainerType.Builder.AllUnspecified = new Builder(SimpleContainerType.createRawRecord)

  implicit val companionProvider: SimpleContainerTypeCompanionProvider = new SimpleContainerTypeCompanionProvider
}

class SimpleContainerTypeMeta
    extends JavaSimpleContainerTypeMeta[SimpleContainerType, RawSimpleContainerType, SimpleContainerTypeMeta]
    with com.foursquare.spindle.RecordProvider[SimpleContainerType] {
  override def recordName: String = "SimpleContainerType"


  // Thrift descriptors.
  val SIMPLECONTAINERTYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("SimpleContainerType")

  val LISTTYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "listType",
      org.apache.thrift.protocol.TType.STRUCT,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val SETTYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "setType",
      org.apache.thrift.protocol.TType.STRUCT,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val MAPTYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "mapType",
      org.apache.thrift.protocol.TType.STRUCT,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "listType" -> LISTTYPE_FDESC,
    "setType" -> SETTYPE_FDESC,
    "mapType" -> MAPTYPE_FDESC
  )

  object _Fields {
    case object listType extends _Fields(1, "listType")
    case object setType extends _Fields(2, "setType")
    case object mapType extends _Fields(3, "mapType")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.listType,
    2.toShort -> _Fields.setType,
    3.toShort -> _Fields.mapType
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: SimpleContainerType = createRawRecord
  override def createRawRecord: RawSimpleContainerType = new RawSimpleContainerType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[SimpleContainerType] = {
    if (x.isInstanceOf[SimpleContainerType]) Some(x.asInstanceOf[SimpleContainerType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val listType =
    new com.foursquare.spindle.StructFieldDescriptor[SimpleContainerType, SimpleContainerTypeMeta, com.twitter.thrift.descriptors.ListType, com.twitter.thrift.descriptors.ListTypeMeta](
      name = "listType",
      longName = "listType",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.listTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleContainerType], v: com.twitter.thrift.descriptors.ListType) => { r.asInstanceOf[RawSimpleContainerType].listType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleContainerType]) => { r.asInstanceOf[RawSimpleContainerType].listTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.ListType,
      manifest = manifest[com.twitter.thrift.descriptors.ListType]
    )

  val setType =
    new com.foursquare.spindle.StructFieldDescriptor[SimpleContainerType, SimpleContainerTypeMeta, com.twitter.thrift.descriptors.SetType, com.twitter.thrift.descriptors.SetTypeMeta](
      name = "setType",
      longName = "setType",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.setTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleContainerType], v: com.twitter.thrift.descriptors.SetType) => { r.asInstanceOf[RawSimpleContainerType].setType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleContainerType]) => { r.asInstanceOf[RawSimpleContainerType].setTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.SetType,
      manifest = manifest[com.twitter.thrift.descriptors.SetType]
    )

  val mapType =
    new com.foursquare.spindle.StructFieldDescriptor[SimpleContainerType, SimpleContainerTypeMeta, com.twitter.thrift.descriptors.MapType, com.twitter.thrift.descriptors.MapTypeMeta](
      name = "mapType",
      longName = "mapType",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.mapTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleContainerType], v: com.twitter.thrift.descriptors.MapType) => { r.asInstanceOf[RawSimpleContainerType].mapType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleContainerType]) => { r.asInstanceOf[RawSimpleContainerType].mapTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.MapType,
      manifest = manifest[com.twitter.thrift.descriptors.MapType]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, SimpleContainerType, SimpleContainerTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, SimpleContainerType, SimpleContainerTypeMeta]](
      listType,
      setType,
      mapType
    )


  def apply(
      listType: com.twitter.thrift.descriptors.ListType,
      setType: com.twitter.thrift.descriptors.SetType,
      mapType: com.twitter.thrift.descriptors.MapType
  ): SimpleContainerType = {
    val ret = this.createRawRecord
    ret.listType_=(listType)
    ret.setType_=(setType)
    ret.mapType_=(mapType)
    ret
  }
}

class SimpleContainerTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[SimpleContainerType] {
  type CompanionT = SimpleContainerTypeMeta
  override def provide: SimpleContainerTypeMeta = SimpleContainerType
}


trait SimpleContainerType
    extends JavaSimpleContainerType[com.twitter.thrift.descriptors.ListType, com.twitter.thrift.descriptors.MapType, com.twitter.thrift.descriptors.SetType,
      SimpleContainerType, RawSimpleContainerType, SimpleContainerTypeMeta
    ]
    with org.apache.thrift.TBase[SimpleContainerType, SimpleContainerType._Fields] {

  override def meta: SimpleContainerTypeMeta

  override def compare(that: SimpleContainerType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.listTypeIsSet.compareTo(that.listTypeIsSet)
      cmp != 0 }) cmp
    else if (this.listTypeIsSet && {
      cmp = this.listTypeOrNull.compareTo(that.listTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.setTypeIsSet.compareTo(that.setTypeIsSet)
      cmp != 0 }) cmp
    else if (this.setTypeIsSet && {
      cmp = this.setTypeOrNull.compareTo(that.setTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.mapTypeIsSet.compareTo(that.mapTypeIsSet)
      cmp != 0 }) cmp
    else if (this.mapTypeIsSet && {
      cmp = this.mapTypeOrNull.compareTo(that.mapTypeOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: SimpleContainerType): Boolean = { this.compare(that) < 0 }
  override def >(that: SimpleContainerType): Boolean = { this.compare(that) > 0 }
  override def <=(that: SimpleContainerType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: SimpleContainerType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: SimpleContainerType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): SimpleContainerType

  def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): SimpleContainerType

  def mutableCopy(): MutableSimpleContainerType = {
    val ret = SimpleContainerType.createRawRecord

    if (listTypeIsSet) ret.listType_=(listTypeOrNull)

    if (setTypeIsSet) ret.setType_=(setTypeOrNull)

    if (mapTypeIsSet) ret.mapType_=(mapTypeOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableSimpleContainerType

  def toBuilder(): SimpleContainerType.Builder.AllSpecified = {
    val ret = new SimpleContainerType.Builder(SimpleContainerType.createRawRecord)

    if (listTypeIsSet) ret.listType(listTypeOrNull)

    if (setTypeIsSet) ret.setType(setTypeOrNull)

    if (mapTypeIsSet) ret.mapType(mapTypeOrNull)
    ret
  }

  def mergeCopy(that: SimpleContainerType): SimpleContainerType

}

trait MutableSimpleContainerType extends SimpleContainerType
    with JavaSimpleContainerTypeMutable[com.twitter.thrift.descriptors.ListType, com.twitter.thrift.descriptors.MapType, com.twitter.thrift.descriptors.SetType,
      SimpleContainerType, RawSimpleContainerType, SimpleContainerTypeMeta
    ] {
  def listType_=(x: com.twitter.thrift.descriptors.ListType): Unit
  def listTypeUnset(): Unit
  def setType_=(x: com.twitter.thrift.descriptors.SetType): Unit
  def setTypeUnset(): Unit
  def mapType_=(x: com.twitter.thrift.descriptors.MapType): Unit
  def mapTypeUnset(): Unit

  def merge(that: SimpleContainerType): Unit

  def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): MutableSimpleContainerType

  override def mutable: MutableSimpleContainerType = this
}



final class RawSimpleContainerType extends JavaSimpleContainerTypeRaw[com.twitter.thrift.descriptors.ListType, com.twitter.thrift.descriptors.MapType, com.twitter.thrift.descriptors.SetType,
      SimpleContainerType, RawSimpleContainerType, SimpleContainerTypeMeta
    ]
    with MutableSimpleContainerType {
  override def meta: SimpleContainerTypeMeta = SimpleContainerType

  // fields
  // Field #1 - listType
  private var _listType: com.twitter.thrift.descriptors.ListType = null  // Underlying type: com.twitter.thrift.descriptors.ListType
  override def listType_=(x: com.twitter.thrift.descriptors.ListType): Unit = { _listType = x }
  override def listTypeOption: Option[com.twitter.thrift.descriptors.ListType] = if (listTypeIsSet) Some(_listType) else None
  override def listTypeOrNull: com.twitter.thrift.descriptors.ListType = _listType
  override def listTypeOrThrow: com.twitter.thrift.descriptors.ListType = if (listTypeIsSet) _listType else throw new java.lang.NullPointerException("field listType of SimpleContainerType missing")
  override def listTypeIsSet: Boolean = _listType != null
  override def listTypeUnset(): Unit = { _listType = null }
  // Field #2 - setType
  private var _setType: com.twitter.thrift.descriptors.SetType = null  // Underlying type: com.twitter.thrift.descriptors.SetType
  override def setType_=(x: com.twitter.thrift.descriptors.SetType): Unit = { _setType = x }
  override def setTypeOption: Option[com.twitter.thrift.descriptors.SetType] = if (setTypeIsSet) Some(_setType) else None
  override def setTypeOrNull: com.twitter.thrift.descriptors.SetType = _setType
  override def setTypeOrThrow: com.twitter.thrift.descriptors.SetType = if (setTypeIsSet) _setType else throw new java.lang.NullPointerException("field setType of SimpleContainerType missing")
  override def setTypeIsSet: Boolean = _setType != null
  override def setTypeUnset(): Unit = { _setType = null }
  // Field #3 - mapType
  private var _mapType: com.twitter.thrift.descriptors.MapType = null  // Underlying type: com.twitter.thrift.descriptors.MapType
  override def mapType_=(x: com.twitter.thrift.descriptors.MapType): Unit = { _mapType = x }
  override def mapTypeOption: Option[com.twitter.thrift.descriptors.MapType] = if (mapTypeIsSet) Some(_mapType) else None
  override def mapTypeOrNull: com.twitter.thrift.descriptors.MapType = _mapType
  override def mapTypeOrThrow: com.twitter.thrift.descriptors.MapType = if (mapTypeIsSet) _mapType else throw new java.lang.NullPointerException("field mapType of SimpleContainerType missing")
  override def mapTypeIsSet: Boolean = _mapType != null
  override def mapTypeUnset(): Unit = { _mapType = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(SimpleContainerType.SIMPLECONTAINERTYPE_SDESC)
    if (listTypeIsSet) {
      oprot.writeFieldBegin(SimpleContainerType.LISTTYPE_FDESC)
      _listType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (setTypeIsSet) {
      oprot.writeFieldBegin(SimpleContainerType.SETTYPE_FDESC)
      _setType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (mapTypeIsSet) {
      oprot.writeFieldBegin(SimpleContainerType.MAPTYPE_FDESC)
      _mapType.write(oprot)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        SimpleContainerType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // listType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _listType = ({
                val s = com.twitter.thrift.descriptors.ListType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // setType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _setType = ({
                val s = com.twitter.thrift.descriptors.SetType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // mapType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _mapType = ({
                val s = com.twitter.thrift.descriptors.MapType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure SimpleContainerType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: SimpleContainerType): Unit = {
    if (that.listTypeIsSet && !this.listTypeIsSet) {
      this.listType_=(that.listTypeOrNull)
    }
    if (that.setTypeIsSet && !this.setTypeIsSet) {
      this.setType_=(that.setTypeOrNull)
    }
    if (that.mapTypeIsSet && !this.mapTypeIsSet) {
      this.mapType_=(that.mapTypeOrNull)
    }
  }

  override def mergeCopy(that: SimpleContainerType): SimpleContainerType = {
    val ret = SimpleContainerType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: SimpleContainerType => this.equals(o)
    case _ => false
  }

  def equals(that: SimpleContainerType): Boolean = {
    that != null &&
    (if (this.listTypeIsSet) (that.listTypeIsSet && this.listTypeOrNull == that.listTypeOrNull) else !that.listTypeIsSet) &&
    (if (this.setTypeIsSet) (that.setTypeIsSet && this.setTypeOrNull == that.setTypeOrNull) else !that.setTypeIsSet) &&
    (if (this.mapTypeIsSet) (that.mapTypeIsSet && this.mapTypeOrNull == that.mapTypeOrNull) else !that.mapTypeIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (listTypeIsSet) hasher.append(_listType.##)
    if (setTypeIsSet) hasher.append(_setType.##)
    if (mapTypeIsSet) hasher.append(_mapType.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (listTypeIsSet) ret = listTypeOrNull :: ret
    if (setTypeIsSet) ret = setTypeOrNull :: ret
    if (mapTypeIsSet) ret = mapTypeOrNull :: ret
    ret.reverse
  }

  override def clear() {
    listTypeUnset()
    setTypeUnset()
    mapTypeUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): SimpleContainerType._Fields = id match {
    case 1 => SimpleContainerType._Fields.listType
    case 2 => SimpleContainerType._Fields.setType
    case 3 => SimpleContainerType._Fields.mapType
    case _ => null
  }

  def isSet(field: SimpleContainerType._Fields): Boolean = field match {
    case SimpleContainerType._Fields.listType => listTypeIsSet
    case SimpleContainerType._Fields.setType => setTypeIsSet
    case SimpleContainerType._Fields.mapType => mapTypeIsSet
    case _ => false
  }

  def getFieldValue(field: SimpleContainerType._Fields): AnyRef = field match {
    case SimpleContainerType._Fields.listType => listTypeOrNull.asInstanceOf[AnyRef]
    case SimpleContainerType._Fields.setType => setTypeOrNull.asInstanceOf[AnyRef]
    case SimpleContainerType._Fields.mapType => mapTypeOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: SimpleContainerType._Fields, value: AnyRef) {
    field match {
      case SimpleContainerType._Fields.listType => listType_=(value.asInstanceOf[com.twitter.thrift.descriptors.ListType])
      case SimpleContainerType._Fields.setType => setType_=(value.asInstanceOf[com.twitter.thrift.descriptors.SetType])
      case SimpleContainerType._Fields.mapType => mapType_=(value.asInstanceOf[com.twitter.thrift.descriptors.MapType])
      case _ =>
    }
  }

  override def deepCopy(): RawSimpleContainerType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = SimpleContainerType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      listType: com.twitter.thrift.descriptors.ListType = listTypeOrNull,
      setType: com.twitter.thrift.descriptors.SetType = setTypeOrNull,
      mapType: com.twitter.thrift.descriptors.MapType = mapTypeOrNull
  ): RawSimpleContainerType = {
    val ret = new RawSimpleContainerType
    if (listType != null) ret.listType_=(listType)
    if (setType != null) ret.setType_=(setType)
    if (mapType != null) ret.mapType_=(mapType)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}



object SimpleType extends SimpleTypeMeta {


  object Builder {

    type HasAll = Any
    type AllSpecified = Builder[HasAll]
    type AllUnspecified = Builder[Any]
  }

  class Builder[+State] private[SimpleType] (private var obj: RawSimpleType) {

    def baseType(v: com.twitter.thrift.descriptors.BaseType): SimpleType.Builder[State] = {
      obj.baseType_=(v)
      this
    }

    def baseType(vOpt: Option[com.twitter.thrift.descriptors.BaseType]): SimpleType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.baseType_=(v)
        case None => obj.baseTypeUnset()
      }
      this
    }

    def containerType(v: com.twitter.thrift.descriptors.ContainerType): SimpleType.Builder[State] = {
      obj.containerType_=(v)
      this
    }

    def containerType(vOpt: Option[com.twitter.thrift.descriptors.ContainerType]): SimpleType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.containerType_=(v)
        case None => obj.containerTypeUnset()
      }
      this
    }

    def typeref(v: com.twitter.thrift.descriptors.Typeref): SimpleType.Builder[State] = {
      obj.typeref_=(v)
      this
    }

    def typeref(vOpt: Option[com.twitter.thrift.descriptors.Typeref]): SimpleType.Builder[State] = {
      vOpt match {
        case Some(v) => obj.typeref_=(v)
        case None => obj.typerefUnset()
      }
      this
    }

    def resultMutable(): MutableSimpleType = {
      if (obj != null) {
        val ret = obj
        obj = null
        ret
      } else {
        throw new IllegalStateException("SimpleType.Builder.result invoked multiple times. Use a new Builder.")
      }
    }

    def result(): SimpleType = resultMutable()
  }

  def newBuilder: SimpleType.Builder.AllUnspecified = new Builder(SimpleType.createRawRecord)

  implicit val companionProvider: SimpleTypeCompanionProvider = new SimpleTypeCompanionProvider
}

class SimpleTypeMeta
    extends JavaSimpleTypeMeta[SimpleType, RawSimpleType, SimpleTypeMeta]
    with com.foursquare.spindle.RecordProvider[SimpleType] {
  override def recordName: String = "SimpleType"


  // Thrift descriptors.
  val SIMPLETYPE_SDESC: org.apache.thrift.protocol.TStruct = new org.apache.thrift.protocol.TStruct("SimpleType")

  val BASETYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "baseType",
      org.apache.thrift.protocol.TType.STRUCT,
      1,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val CONTAINERTYPE_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "containerType",
      org.apache.thrift.protocol.TType.STRUCT,
      2,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )
  val TYPEREF_FDESC: org.apache.thrift.protocol.TField =
    new com.foursquare.common.thrift.base.EnhancedTField(
      "typeref",
      org.apache.thrift.protocol.TType.STRUCT,
      3,
      {

        java.util.Collections.emptyMap[String, String]
      }
    )

  val UNKNOWN_FIELD: org.apache.thrift.protocol.TField = new org.apache.thrift.protocol.TField("", org.apache.thrift.protocol.TType.VOID, -1);

  val wireNameToTField: Map[String, org.apache.thrift.protocol.TField] = Map(
    "baseType" -> BASETYPE_FDESC,
    "containerType" -> CONTAINERTYPE_FDESC,
    "typeref" -> TYPEREF_FDESC
  )

  object _Fields {
    case object baseType extends _Fields(1, "baseType")
    case object containerType extends _Fields(2, "containerType")
    case object typeref extends _Fields(3, "typeref")
  }

  sealed abstract class _Fields private (id: Short, name: String) extends org.apache.thrift.TFieldIdEnum {
    def getThriftFieldId: Short = id
    def getFieldName: String = name
  }

  val idToTFieldIdEnum: Map[Short, org.apache.thrift.TFieldIdEnum] = Map(
    1.toShort -> _Fields.baseType,
    2.toShort -> _Fields.containerType,
    3.toShort -> _Fields.typeref
  )

  override def createUntypedRawRecord: com.foursquare.spindle.UntypedRecord = createRawRecord
  override def createRecord: SimpleType = createRawRecord
  override def createRawRecord: RawSimpleType = new RawSimpleType

  override def untypedIfInstanceFrom(x: AnyRef): Option[com.foursquare.spindle.UntypedRecord] = ifInstanceFrom(x)
  override def ifInstanceFrom(x: AnyRef): Option[SimpleType] = {
    if (x.isInstanceOf[SimpleType]) Some(x.asInstanceOf[SimpleType]) else None
  }

  override val annotations: com.foursquare.spindle.Annotations =

    com.foursquare.spindle.Annotations.empty

  // Spindle Descriptors.


  val baseType =
    new com.foursquare.spindle.StructFieldDescriptor[SimpleType, SimpleTypeMeta, com.twitter.thrift.descriptors.BaseType, com.twitter.thrift.descriptors.BaseTypeMeta](
      name = "baseType",
      longName = "baseType",
      id = 1,
      annotations = Map(),
      owner = this,
      getter = _.baseTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleType], v: com.twitter.thrift.descriptors.BaseType) => { r.asInstanceOf[RawSimpleType].baseType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleType]) => { r.asInstanceOf[RawSimpleType].baseTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.BaseType,
      manifest = manifest[com.twitter.thrift.descriptors.BaseType]
    )

  val containerType =
    new com.foursquare.spindle.StructFieldDescriptor[SimpleType, SimpleTypeMeta, com.twitter.thrift.descriptors.ContainerType, com.twitter.thrift.descriptors.ContainerTypeMeta](
      name = "containerType",
      longName = "containerType",
      id = 2,
      annotations = Map(),
      owner = this,
      getter = _.containerTypeOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleType], v: com.twitter.thrift.descriptors.ContainerType) => { r.asInstanceOf[RawSimpleType].containerType_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleType]) => { r.asInstanceOf[RawSimpleType].containerTypeUnset() },
      structMeta = com.twitter.thrift.descriptors.ContainerType,
      manifest = manifest[com.twitter.thrift.descriptors.ContainerType]
    )

  val typeref =
    new com.foursquare.spindle.StructFieldDescriptor[SimpleType, SimpleTypeMeta, com.twitter.thrift.descriptors.Typeref, com.twitter.thrift.descriptors.TyperefMeta](
      name = "typeref",
      longName = "typeref",
      id = 3,
      annotations = Map(),
      owner = this,
      getter = _.typerefOption,
      setterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleType], v: com.twitter.thrift.descriptors.Typeref) => { r.asInstanceOf[RawSimpleType].typeref_=(v) },
      unsetterRaw = (r: com.foursquare.spindle.MutableRecord[SimpleType]) => { r.asInstanceOf[RawSimpleType].typerefUnset() },
      structMeta = com.twitter.thrift.descriptors.Typeref,
      manifest = manifest[com.twitter.thrift.descriptors.Typeref]
    )

  override def untypedFields: Seq[com.foursquare.spindle.UntypedFieldDescriptor] = fields
  override val fields: Seq[com.foursquare.spindle.FieldDescriptor[_, SimpleType, SimpleTypeMeta]] =
    Vector[com.foursquare.spindle.FieldDescriptor[_, SimpleType, SimpleTypeMeta]](
      baseType,
      containerType,
      typeref
    )


  def apply(
      baseType: com.twitter.thrift.descriptors.BaseType,
      containerType: com.twitter.thrift.descriptors.ContainerType,
      typeref: com.twitter.thrift.descriptors.Typeref
  ): SimpleType = {
    val ret = this.createRawRecord
    ret.baseType_=(baseType)
    ret.containerType_=(containerType)
    ret.typeref_=(typeref)
    ret
  }
}

class SimpleTypeCompanionProvider extends com.foursquare.spindle.CompanionProvider[SimpleType] {
  type CompanionT = SimpleTypeMeta
  override def provide: SimpleTypeMeta = SimpleType
}


trait SimpleType
    extends JavaSimpleType[com.twitter.thrift.descriptors.BaseType, com.twitter.thrift.descriptors.ContainerType, com.twitter.thrift.descriptors.Typeref,
      SimpleType, RawSimpleType, SimpleTypeMeta
    ]
    with org.apache.thrift.TBase[SimpleType, SimpleType._Fields] {

  override def meta: SimpleTypeMeta

  override def compare(that: SimpleType): Int = {
    var cmp: Int = 0
    if (that == null) {
      1
    }
    else if ({
      cmp = this.baseTypeIsSet.compareTo(that.baseTypeIsSet)
      cmp != 0 }) cmp
    else if (this.baseTypeIsSet && {
      cmp = this.baseTypeOrNull.compareTo(that.baseTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.containerTypeIsSet.compareTo(that.containerTypeIsSet)
      cmp != 0 }) cmp
    else if (this.containerTypeIsSet && {
      cmp = this.containerTypeOrNull.compareTo(that.containerTypeOrNull)
      cmp != 0 }) cmp
    else if ({
      cmp = this.typerefIsSet.compareTo(that.typerefIsSet)
      cmp != 0 }) cmp
    else if (this.typerefIsSet && {
      cmp = this.typerefOrNull.compareTo(that.typerefOrNull)
      cmp != 0 }) cmp
    else 0
  }
  override def <(that: SimpleType): Boolean = { this.compare(that) < 0 }
  override def >(that: SimpleType): Boolean = { this.compare(that) > 0 }
  override def <=(that: SimpleType): Boolean = { this.compare(that) <= 0 }
  override def >=(that: SimpleType): Boolean = { this.compare(that) >= 0 }
  override def compareTo(that: SimpleType): Int = compare(that)

  def write(oprot: org.apache.thrift.protocol.TProtocol): Unit

  def deepCopy(): SimpleType

  def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): SimpleType

  def mutableCopy(): MutableSimpleType = {
    val ret = SimpleType.createRawRecord

    if (baseTypeIsSet) ret.baseType_=(baseTypeOrNull)

    if (containerTypeIsSet) ret.containerType_=(containerTypeOrNull)

    if (typerefIsSet) ret.typeref_=(typerefOrNull)
    ret
  }

  /** Returns a pointer to a Mutable version of this record.
    *
    * If the underlying implementation is mutable, `this` will be returned.
    * If the underlying implementation is immutable, a mutable copy will be returned.
    *
    * After mutating the instance returned by this method, the original instance
    * (on which `mutable` was called) will be in an undefined state. It may or may
    * not have been modified, depending on whether it was immutable or not.
    *
    * This is included as an optimization for when we want access to a Mutable record
    * but don't want to pay the cost of copying every time.
    */
  def mutable: MutableSimpleType

  def toBuilder(): SimpleType.Builder.AllSpecified = {
    val ret = new SimpleType.Builder(SimpleType.createRawRecord)

    if (baseTypeIsSet) ret.baseType(baseTypeOrNull)

    if (containerTypeIsSet) ret.containerType(containerTypeOrNull)

    if (typerefIsSet) ret.typeref(typerefOrNull)
    ret
  }

  def mergeCopy(that: SimpleType): SimpleType

}

trait MutableSimpleType extends SimpleType
    with JavaSimpleTypeMutable[com.twitter.thrift.descriptors.BaseType, com.twitter.thrift.descriptors.ContainerType, com.twitter.thrift.descriptors.Typeref,
      SimpleType, RawSimpleType, SimpleTypeMeta
    ] {
  def baseType_=(x: com.twitter.thrift.descriptors.BaseType): Unit
  def baseTypeUnset(): Unit
  def containerType_=(x: com.twitter.thrift.descriptors.ContainerType): Unit
  def containerTypeUnset(): Unit
  def typeref_=(x: com.twitter.thrift.descriptors.Typeref): Unit
  def typerefUnset(): Unit

  def merge(that: SimpleType): Unit

  def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): MutableSimpleType

  override def mutable: MutableSimpleType = this
}



final class RawSimpleType extends JavaSimpleTypeRaw[com.twitter.thrift.descriptors.BaseType, com.twitter.thrift.descriptors.ContainerType, com.twitter.thrift.descriptors.Typeref,
      SimpleType, RawSimpleType, SimpleTypeMeta
    ]
    with MutableSimpleType {
  override def meta: SimpleTypeMeta = SimpleType

  // fields
  // Field #1 - baseType
  private var _baseType: com.twitter.thrift.descriptors.BaseType = null  // Underlying type: com.twitter.thrift.descriptors.BaseType
  override def baseType_=(x: com.twitter.thrift.descriptors.BaseType): Unit = { _baseType = x }
  override def baseTypeOption: Option[com.twitter.thrift.descriptors.BaseType] = if (baseTypeIsSet) Some(_baseType) else None
  override def baseTypeOrNull: com.twitter.thrift.descriptors.BaseType = _baseType
  override def baseTypeOrThrow: com.twitter.thrift.descriptors.BaseType = if (baseTypeIsSet) _baseType else throw new java.lang.NullPointerException("field baseType of SimpleType missing")
  override def baseTypeIsSet: Boolean = _baseType != null
  override def baseTypeUnset(): Unit = { _baseType = null }
  // Field #2 - containerType
  private var _containerType: com.twitter.thrift.descriptors.ContainerType = null  // Underlying type: com.twitter.thrift.descriptors.ContainerType
  override def containerType_=(x: com.twitter.thrift.descriptors.ContainerType): Unit = { _containerType = x }
  override def containerTypeOption: Option[com.twitter.thrift.descriptors.ContainerType] = if (containerTypeIsSet) Some(_containerType) else None
  override def containerTypeOrNull: com.twitter.thrift.descriptors.ContainerType = _containerType
  override def containerTypeOrThrow: com.twitter.thrift.descriptors.ContainerType = if (containerTypeIsSet) _containerType else throw new java.lang.NullPointerException("field containerType of SimpleType missing")
  override def containerTypeIsSet: Boolean = _containerType != null
  override def containerTypeUnset(): Unit = { _containerType = null }
  // Field #3 - typeref
  private var _typeref: com.twitter.thrift.descriptors.Typeref = null  // Underlying type: com.twitter.thrift.descriptors.Typeref
  override def typeref_=(x: com.twitter.thrift.descriptors.Typeref): Unit = { _typeref = x }
  override def typerefOption: Option[com.twitter.thrift.descriptors.Typeref] = if (typerefIsSet) Some(_typeref) else None
  override def typerefOrNull: com.twitter.thrift.descriptors.Typeref = _typeref
  override def typerefOrThrow: com.twitter.thrift.descriptors.Typeref = if (typerefIsSet) _typeref else throw new java.lang.NullPointerException("field typeref of SimpleType missing")
  override def typerefIsSet: Boolean = _typeref != null
  override def typerefUnset(): Unit = { _typeref = null }
  // end fields


  private var unknownFields: List[com.foursquare.spindle.runtime.UnknownFields] = Nil


  override def write(oprot: org.apache.thrift.protocol.TProtocol): Unit = {
    oprot.writeStructBegin(SimpleType.SIMPLETYPE_SDESC)
    if (baseTypeIsSet) {
      oprot.writeFieldBegin(SimpleType.BASETYPE_FDESC)
      _baseType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (containerTypeIsSet) {
      oprot.writeFieldBegin(SimpleType.CONTAINERTYPE_FDESC)
      _containerType.write(oprot)
      oprot.writeFieldEnd()
    }
    if (typerefIsSet) {
      oprot.writeFieldBegin(SimpleType.TYPEREF_FDESC)
      _typeref.write(oprot)
      oprot.writeFieldEnd()
    }
  if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
    unknownFields.reverse foreach { _.write(oprot) }
  }
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  override def read(iprot: org.apache.thrift.protocol.TProtocol) {
    // Unknown fields in this read go here.
    var currentUnknownFieldsOpt: Option[com.foursquare.spindle.runtime.UnknownFields] = None
    def currentUnknownFields(): com.foursquare.spindle.runtime.UnknownFields = currentUnknownFieldsOpt match {
      case Some(uf) => uf
      case None => {
        val uf = new com.foursquare.spindle.runtime.UnknownFields(
          this,
          com.foursquare.spindle.runtime.TProtocolInfo.getProtocolName(iprot)
        )
        unknownFields = uf :: unknownFields
        currentUnknownFieldsOpt = Some(uf)
        uf
      }
    }
    iprot.readStructBegin()
    var wire_field_header: org.apache.thrift.protocol.TField = iprot.readFieldBegin()
    while (wire_field_header.`type` != org.apache.thrift.protocol.TType.STOP) {
      // Some protocols, e.g., BSON and JSON, serialize the field name, not the id. If we don't have the id we use the
      // name to look up the id and type. This allows us to use those protocols naturally.
      var field_header: org.apache.thrift.protocol.TField = if (wire_field_header.id < 0) {
        SimpleType.wireNameToTField.getOrElse(wire_field_header.name, wire_field_header)
      } else {
        wire_field_header
      }

      try {
        field_header.id match {
          case 1 => {  // baseType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _baseType = ({
                val s = com.twitter.thrift.descriptors.BaseType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 2 => {  // containerType

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _containerType = ({
                val s = com.twitter.thrift.descriptors.ContainerType.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case 3 => {  // typeref

            if (field_header.`type` == org.apache.thrift.protocol.TType.STRUCT) {
              _typeref = ({
                val s = com.twitter.thrift.descriptors.Typeref.createRawRecord
                s.read(iprot)
                s
              })
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
          case _ => {
            if (com.foursquare.spindle.RuntimeHelpers.preserveUnknownFields(this)) {
              currentUnknownFields().readUnknownField(iprot, field_header, this)  // May call this method recursively.
            } else {
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field_header.`type`)
            }
          }
        }  // end match
      } catch {
        case e: org.apache.thrift.TException =>
          throw new org.apache.thrift.TException("Error reading field %d in structure SimpleType".format(field_header.id), e)
      }
      iprot.readFieldEnd()
      wire_field_header = iprot.readFieldBegin()
    } // end while
    iprot.readStructEnd()
  }

  override def merge(that: SimpleType): Unit = {
    if (that.baseTypeIsSet && !this.baseTypeIsSet) {
      this.baseType_=(that.baseTypeOrNull)
    }
    if (that.containerTypeIsSet && !this.containerTypeIsSet) {
      this.containerType_=(that.containerTypeOrNull)
    }
    if (that.typerefIsSet && !this.typerefIsSet) {
      this.typeref_=(that.typerefOrNull)
    }
  }

  override def mergeCopy(that: SimpleType): SimpleType = {
    val ret = SimpleType.createRawRecord
    ret.merge(this)
    ret.merge(that)
    ret
  }

  override def equals(that: Any): Boolean = that match {
    case null => false
    case o: SimpleType => this.equals(o)
    case _ => false
  }

  def equals(that: SimpleType): Boolean = {
    that != null &&
    (if (this.baseTypeIsSet) (that.baseTypeIsSet && this.baseTypeOrNull == that.baseTypeOrNull) else !that.baseTypeIsSet) &&
    (if (this.containerTypeIsSet) (that.containerTypeIsSet && this.containerTypeOrNull == that.containerTypeOrNull) else !that.containerTypeIsSet) &&
    (if (this.typerefIsSet) (that.typerefIsSet && this.typerefOrNull == that.typerefOrNull) else !that.typerefIsSet) &&
    true
  }

  override def hashCode(): Int = {
    // We use a fixed seed, for consistency.
    val hasher = new com.foursquare.spindle.runtime.MurmurHash[AnyRef](0)
    if (baseTypeIsSet) hasher.append(_baseType.##)
    if (containerTypeIsSet) hasher.append(_containerType.##)
    if (typerefIsSet) hasher.append(_typeref.##)
    hasher.hash
  }

  // Returns the values of the set fields on this object, in id order.
  def getSetFields: Seq[Any] = {
    var ret: List[Any] = Nil
    if (baseTypeIsSet) ret = baseTypeOrNull :: ret
    if (containerTypeIsSet) ret = containerTypeOrNull :: ret
    if (typerefIsSet) ret = typerefOrNull :: ret
    ret.reverse
  }

  override def clear() {
    baseTypeUnset()
    containerTypeUnset()
    typerefUnset()
  unknownFields = Nil
  }

  def fieldForId(id: Int): SimpleType._Fields = id match {
    case 1 => SimpleType._Fields.baseType
    case 2 => SimpleType._Fields.containerType
    case 3 => SimpleType._Fields.typeref
    case _ => null
  }

  def isSet(field: SimpleType._Fields): Boolean = field match {
    case SimpleType._Fields.baseType => baseTypeIsSet
    case SimpleType._Fields.containerType => containerTypeIsSet
    case SimpleType._Fields.typeref => typerefIsSet
    case _ => false
  }

  def getFieldValue(field: SimpleType._Fields): AnyRef = field match {
    case SimpleType._Fields.baseType => baseTypeOrNull.asInstanceOf[AnyRef]
    case SimpleType._Fields.containerType => containerTypeOrNull.asInstanceOf[AnyRef]
    case SimpleType._Fields.typeref => typerefOrNull.asInstanceOf[AnyRef]
    case _ => throw new IllegalStateException
  }

  def setFieldValue(field: SimpleType._Fields, value: AnyRef) {
    field match {
      case SimpleType._Fields.baseType => baseType_=(value.asInstanceOf[com.twitter.thrift.descriptors.BaseType])
      case SimpleType._Fields.containerType => containerType_=(value.asInstanceOf[com.twitter.thrift.descriptors.ContainerType])
      case SimpleType._Fields.typeref => typeref_=(value.asInstanceOf[com.twitter.thrift.descriptors.Typeref])
      case _ =>
    }
  }

  override def deepCopy(): RawSimpleType = {
    // May not be the most efficient way to create a deep copy, but we don't expect to use this intensively.
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val prot = new org.apache.thrift.protocol.TBinaryProtocol.Factory().getProtocol(trans)
    write(prot)
    val ret = SimpleType.createRawRecord
    ret.read(prot)
    ret
  }

  override def copy(
      baseType: com.twitter.thrift.descriptors.BaseType = baseTypeOrNull,
      containerType: com.twitter.thrift.descriptors.ContainerType = containerTypeOrNull,
      typeref: com.twitter.thrift.descriptors.Typeref = typerefOrNull
  ): RawSimpleType = {
    val ret = new RawSimpleType
    if (baseType != null) ret.baseType_=(baseType)
    if (containerType != null) ret.containerType_=(containerType)
    if (typeref != null) ret.typeref_=(typeref)
    ret
  }

  override def toString: String = {
    val trans = new org.apache.thrift.transport.TMemoryBuffer(1024)
    val oprot = new com.foursquare.common.thrift.base.TStringProtocol(trans)
    write(oprot)
    trans.toString("UTF8")
  }
}


